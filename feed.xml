<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://blog.k3fu.xyz/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.k3fu.xyz/" rel="alternate" type="text/html" hreflang="en" /><updated>2023-08-06T07:03:35+00:00</updated><id>https://blog.k3fu.xyz/feed.xml</id><title type="html">some random rants</title><subtitle>我的学习记录</subtitle><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><entry><title type="html">maybe_yield_awaiter</title><link href="https://blog.k3fu.xyz/2023/07/26/maybe-yield.html" rel="alternate" type="text/html" title="maybe_yield_awaiter" /><published>2023-07-26T00:00:00+00:00</published><updated>2023-07-26T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2023/07/26/maybe-yield</id><content type="html" xml:base="https://blog.k3fu.xyz/2023/07/26/maybe-yield.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;说说 awaiter 的生命周期，和最近一位同事发现的 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 的 bug。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Seastar 中的协程可以用 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 中途把 CPU 出让给 (yield)
别人。一个协程如果流程很长，而且它运气也很好，没有被打断的话，那么就会长时间地占用 CPU，导致这个核上的其他任务被饿死。我们知道，协程之所有叫做“协”程，就是因为协程和协程大家都是谦谦君子，互相礼让，这样才能有比较好的响应和延迟。&lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 被用来检查当前是不是有正在亟待处理的事件。如果有的话，它就会抢占当前的协程，把它手里的 CPU 借用一会儿，把急事完成了，再把 CPU 还回来。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如说，如果协程有个很大的循环，处理上万个元素，那么我们很可能会在循环里面插上几个&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;coroutine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;maybe_yield&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;让这个协程也能照顾一下其他人的需要，避免产生饥饿 (starve) 的情况，导致 reactor 出现 stall 告警。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;co_await&quot;&gt;co_await&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在讨论 bug 之前，还是需要和大家一起再复习一下 &lt;code&gt;co_await&lt;/code&gt; 。毕竟协程是比较高层的抽象，而 C&amp;#43;&amp;#43;20 的协程又很灵活，需要编译器和协程库，乃至用户程序的通力协作才能完成工作。
C&amp;#43;&amp;#43; 中的 &lt;code&gt;co_await&lt;/code&gt; 是个操作符，后面跟着操作数，即一个表达式：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;中的 &lt;code&gt;expr&lt;/code&gt; 需要根据具体情况转换成 awaitable，这样 &lt;code&gt;co_await&lt;/code&gt;
才能知道下一步是&lt;span class=&quot;line-through&quot;&gt;走还是留&lt;/span&gt;继续还是歇会儿再来。在这里，
&lt;code&gt;maybe_yield()&lt;/code&gt; 构造一个 &lt;code&gt;maybe_yield&lt;/code&gt; 的 awaitable 对象，它的 &lt;code&gt;co_await&lt;/code&gt;
操作符的实现的返回值是个 prvalue。所以按照
&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/coroutines#co_await&quot;&gt;cppreference&lt;/a&gt;
的说法，最终的 awaiter 是这个 prvalue
&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/implicit_conversion#Temporary_materialization&quot;&gt;materialized&lt;/a&gt; 之后的临时对象。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不管怎么样，我们找到了 awaitable 的最终所在：故事的主角 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 。这个临时对象和调用者协程定义的其他局部变量一样，存活在栈上。具体说，存活在 coroutine
frame 上，在 &lt;code&gt;maybe_yield_awaiter::await_ready()&lt;/code&gt; 告诉 coroutine runtime 它要暂停运行之后，
&lt;code&gt;maybe_yield_awaiter::await_suspend()&lt;/code&gt; 把自己直接挂到任务队列上去，要求被调度恢复执行。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 等待的结果一旦出现，它就得以恢复运行，虽然这里的结果是 &lt;code&gt;void&lt;/code&gt;，
&lt;code&gt;maybe_yield_awaiter::await_resume()&lt;/code&gt; 仍然会被调用，它负责为 &lt;code&gt;co_await&lt;/code&gt;
的调用方提供返回值，毕竟 &lt;code&gt;co_await expr&lt;/code&gt; 是允许返回值的。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;task-和-waiting_task&quot;&gt;task 和 waiting_task()&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面提到，  &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 可以用来出让 CPU。但是需要重点提出的是，
&lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 是继承自 &lt;code&gt;task&lt;/code&gt; 的。那么什么是 &lt;code&gt;task&lt;/code&gt; 呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 Seastar 中，&lt;code&gt;task&lt;/code&gt; 代表着一个可调度的最小的任务单位，如果大家看看
&lt;code&gt;future::schedule()&lt;/code&gt; 就会注意到，它其实直接 &lt;code&gt;new&lt;/code&gt; 了一个 task。如果这个
task 不能立即返回的话，它会被当成参数传给 &lt;code&gt;::seastar::schedule()&lt;/code&gt; 。而 &lt;code&gt;seastar::schedule()&lt;/code&gt; 的作用就是把 &lt;code&gt;task&lt;/code&gt; 加到任务队列上去。在调度器调度执行 &lt;code&gt;task&lt;/code&gt; 的时候，它会调用 &lt;code&gt;task&amp;#8594;run_and_dispose()&lt;/code&gt; 。请注意，这里的 &lt;code&gt;task&lt;/code&gt; 就是 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 这个对象的地址。所以可以看出来，我们有个前提，即在这个 task 调度完成之前，这个指针都是有效的。因为 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 应该保存在调用者的 coroutine frame 上，所以 &lt;code&gt;*this&lt;/code&gt; 在
&lt;code&gt;maybe_yield_awaiter::await_resume()&lt;/code&gt; 返回前都一直是有效的。自然这个前提是成立的。这里把和 &lt;code&gt;task&lt;/code&gt; 相关的函数摘录下来：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;maybe_yield_awaiter&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;coroutine_handle_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;when_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main_coroutine_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;await_suspend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;coroutine_handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when_ready&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;main_coroutine_task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;h&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// for waiting_task()&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_and_dispose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;when_ready&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;resume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// No need to delete, this is allocated on the coroutine frame&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;virtual&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;waiting_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main_coroutine_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么问题来了， &lt;code&gt;waiting_task()&lt;/code&gt; 是做什么用的呢？每个 &lt;code&gt;task&lt;/code&gt; 都会实现它，这里， &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 返回的是它调用者的地址，而且，有意思的是，虽然 &lt;code&gt;maybe_yield_awaiter::await_suspend()&lt;/code&gt; 是个模板函数，它却对 &lt;code&gt;T&lt;/code&gt;
有着很强的假设。它要求 &lt;code&gt;std::coroutine_handle&amp;lt;T&amp;gt;::promise()&lt;/code&gt; 的类型是个
&lt;code&gt;task&lt;/code&gt; ！换句话说，它认为它的调用者的 promise 肯定是个 &lt;code&gt;task&lt;/code&gt; 。我们去看看
&lt;code&gt;coroutine_traits_base::promise_type&lt;/code&gt; ，它还真的是个 &lt;code&gt;task&lt;/code&gt; 。如果每个
&lt;code&gt;task&lt;/code&gt; 都知道自己调用者的 &lt;code&gt;task&lt;/code&gt;，那么如果说协程从最外面的调用者一层一层地调用到最里面，构成了调用的链条。那么我们用 &lt;code&gt;waiting_task()&lt;/code&gt; 其实也可以从最里面一层一层地，遍历这个链条的所有环节。如果大家用过 gdb 的话，就能意识到，这其实可以实现
&lt;code&gt;backtrace&lt;/code&gt; 类似的功能，&lt;code&gt;backtrace&lt;/code&gt; 通过 &lt;code&gt;$bp&lt;/code&gt; 能找到之前的栈顶。而 Seastar
通过 &lt;code&gt;waiting_task()&lt;/code&gt; 调用栈里面更高一层，道理是类似的。用图表示：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-3f2ac577e2ce911434c66496c3d3270e.png&quot; alt=&quot;Diagram&quot; width=&quot;520&quot; height=&quot;238&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Seastar 中的 &lt;code&gt;current_tasktrace()&lt;/code&gt; 用 Python 伪代码可以这么写：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;current_tasktrace&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;stack_traces&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;local_engine&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;None&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;stack_traces&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;waiting_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stack_traces&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;folly
甚至专门有好几期 &lt;a href=&quot;https://developers.facebook.com/blog/post/2021/09/16/async-stack-traces-folly-Introduction/&quot;&gt;blog&lt;/a&gt;
介绍它家的 stack trace 是怎么实现的。协程 backtrace
对于程序员的重要性可见一斑。要在生产环境里面使用的话，
backtrace 的支持是必不可少的。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;问题分析&quot;&gt;问题分析&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在普通的程序调用中，有压栈就要有退栈。协程也是一样的，在调用子协程的时候，
&lt;code&gt;schedule(this)&lt;/code&gt; 会把自己作为 task 挂到执行队列上去，当调度器执行 task 的时候，把 &lt;code&gt;_current_task&lt;/code&gt; 设置成指向这个 &lt;code&gt;task&lt;/code&gt; 指针。结合该 task 的 &lt;code&gt;waiting_task()&lt;/code&gt;
方法，就能一层一层地回到最外层的调用者。当子协程退出的时候，它就需要把
&lt;code&gt;_current_task&lt;/code&gt; 改回来，设置成调用者的 task ，即 &lt;code&gt;main_coroutine_task&lt;/code&gt; 。因为 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 和 C&amp;#43;&amp;#43;20 之前的 Seastar 的协程不一样，它不是通过把一系列表达式串联起来形成的程序执行流程，而是借助 C&amp;#43;&amp;#43;
编译器、标准库和用户实现的 awaiter 完成的。前者在前序 future 完成之后，后面的 future 在调度时，会执行 &lt;code&gt;schedule()&lt;/code&gt; 的动作，这样可以确保 &lt;code&gt;_current_task&lt;/code&gt; 一直指向的是最新的 task。但是后者如果通过
awaiter 来实现子协程的话，而且子协程又是以 &lt;code&gt;task&lt;/code&gt; 的形式被调用的话，那么在子协程准备回到父协程的时候，就需要把当时调用自己时
&lt;code&gt;schedule(this)&lt;/code&gt; 产生的副作用消除掉，即如前所述&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;engine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_current_task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main_coroutine_task&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样，如果父协程出错的话，那么它的 backtrace 才是准确的，否则第一个 frame
就会指向一个已经被释放的地址，即 use-after-free 。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么我们是不是真的需要在 backtrace 里面包含 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt; 呢？这里引用一下 folly blog 的话&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Probably the most frequent place where developers see stack traces is when programs crash. The folly library already provides a signal handler that prints the stack trace of the thread that is causing the program to crash.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以大家平时都是发现有个地方出问题了，才会看看那个地方到底在哪里。而 &lt;code&gt;maybe_yield()&lt;/code&gt; 是一个不会出问题的地方，它做的事情就是什么都不做。自然也不会出错，或者崩溃。举例来说，在一个多线程的程序崩溃的时候，使用 GDB 的 &lt;code&gt;thread apply all backtrace&lt;/code&gt;
命令我们可以看到程序每个线程的 backtrace。对协程的程序来说，利用刚才提到的 &lt;code&gt;_current_task&lt;/code&gt; 和 &lt;code&gt;waiting_task()&lt;/code&gt; ，我们也可以手搓出来个协程版的 &lt;code&gt;coroutine apply all backtrace&lt;/code&gt;。而这些 backtrace 里面是不会包含那个做好事 yield 的协程的，因为人家做好事不留名，把运行的机会让给了别人。留名的那位是正在运行的协程。因此，在 &lt;code&gt;maybe_yield_awaiter&lt;/code&gt;
里面实现 &lt;code&gt;waiting_task()&lt;/code&gt; 并没有意义，更进一步，把它实现成
&lt;code&gt;task&lt;/code&gt; 也不再有意义了。因为它的作用就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;是否需要 yield&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;yield 的话，在挂起之前，把父协程的挂在执行队列上。说明它已经准备好了，
随时可以运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这些都不需要 &lt;code&gt;task&lt;/code&gt; 参与。所以 &lt;a href=&quot;https://github.com/michoecho&quot;&gt;Michał&lt;/a&gt; 的 &lt;a href=&quot;https://github.com/scylladb/seastar/pull/1760&quot;&gt;修正&lt;/a&gt; 也很简单明了：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接实现了前面两点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 &lt;code&gt;task&lt;/code&gt; 的继承关系去掉了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="seastar" /><summary type="html">说说 awaiter 的生命周期，和最近一位同事发现的 maybe_yield_awaiter 的 bug。</summary></entry><entry><title type="html">io_uring 和 EAGAIN</title><link href="https://blog.k3fu.xyz/2022/10/18/iouring-eagain.html" rel="alternate" type="text/html" title="io_uring 和 EAGAIN" /><published>2022-10-18T00:00:00+00:00</published><updated>2022-10-18T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2022/10/18/iouring-eagain</id><content type="html" xml:base="https://blog.k3fu.xyz/2022/10/18/iouring-eagain.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;io_uring 的 cqe 到底会不会返回 &lt;code&gt;EAGAIN&lt;/code&gt;？&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;历史上的-o_nonblock&quot;&gt;历史上的 &lt;code&gt;O_NONBLOCK&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大家都知道 io_uring 是个异步的系统调用接口，它支持广泛的 IO 相关的调用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;说到“异步”，就不得不提阻塞。我们在打开文件的时候，除了给出文件的路径之外，还可以指定一堆 flags。如果 flags 包含 &lt;code&gt;O_NONBLOCK&lt;/code&gt;，文件就会以非阻塞的模式打开。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When possible, the file is opened in nonblocking mode.  Neither the open() nor any subsequent I/O operations on the file descriptor which is returned will cause the calling process to wait.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Note that this flag has no effect for regular files and block devices; that is, I/O operations will (briefly) block when device activity is required, regardless of  whether  O_NONBLOCK  is  set.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; open(2)
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;manpage 说得清楚，普通文件和块设备不支持这个 &lt;code&gt;O_NONBLOCK&lt;/code&gt;。写了也白写。APUE
解释了背后的原因：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We also said that system calls related to disk I/O are not considered slow, even though the read or write of a disk file can block the caller temporarily.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; APUE 14.2
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大概当初设计 UNIX 的大佬们认为文件读写不会 &lt;strong&gt;太&lt;/strong&gt; 慢，所以不值得支持 &lt;code&gt;O_NONBLOCK&lt;/code&gt;。不过用排除法可以知道，&lt;code&gt;O_NONBLOCK&lt;/code&gt; 只支持&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;tty 或者 ptty&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pipe (管道)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FIFO (即有名管道)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;socket&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;tty 当初是用电话线连接的，所以可能也会很慢。所以这些东西会涉及网络，以及一些无法确定的因素，所以有 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 的用武之地。另外，因为 pipe 和 FIFO 不是用 &lt;code&gt;open()&lt;/code&gt; 调用打开的，所以需要用 &lt;code&gt;fcntl()&lt;/code&gt; 设置一下。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;no-wait-aio&quot;&gt;No Wait AIO&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Linux 4.14 为了支持异步的 direct I/O，已经提供了返回 &lt;code&gt;EAGAIN&lt;/code&gt; 的支持。见
&lt;a href=&quot;https://lwn.net/Articles/722784/&quot;&gt;No wait AIO&lt;/a&gt;。 &lt;a href=&quot;https://man7.org/linux/man-pages/man2/io_submit.2.html&quot;&gt;aio&lt;/a&gt; 通过
&lt;code&gt;iocb.aio_rw_flags&lt;/code&gt; 的 &lt;code&gt;RWF_NOWAIT&lt;/code&gt; 标志为应用提供非阻塞的文件或块设备的 IO 支持。新的 &lt;code&gt;preadv2()&lt;/code&gt; 系统调用也通过 flags 参数为非阻塞的 IO 提供支持，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;RWF_NOWAIT (since Linux 4.14)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Do  not  wait  for  data which is not immediately available.  If this
flag is specified, the &lt;code&gt;preadv2()&lt;/code&gt; system call will return instantly if
it would have to read data from the backing storage or wait for a lock.
If some data was successfully read, it will return the number of bytes
read. If no bytes were read, it will return -1 and set errno to &lt;code&gt;EAGAIN&lt;/code&gt;
(but see BUGS).  Currently,  this flag is meaningful only for &lt;code&gt;preadv2()&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; readv(2)
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;进一步解释一下。以读操作为例，&lt;code&gt;-EAGAIN&lt;/code&gt; 并不意味着这个读操作会堵塞，而是说如果不等待读操作的话，是没有数据可读的。如果读取的是普通文件，那么 &lt;code&gt;RWF_NOWAIT&lt;/code&gt; 会直接返回 page cache
里面已经有的数据，如果 page cache 里没有数据的话，就需要再发一个没有 &lt;code&gt;RWF_NOWAIT&lt;/code&gt;
标记的读请求，真正的去把数据 &lt;strong&gt;读&lt;/strong&gt; 出来。当然也可以采用预读的方式，自己实现读缓存。但是对于 io_uring 来说，这种设计就显得没什么必要了，因为如果数据在 page cache
里的话，cqe 会在 submit sqe 调用返回之前就加入 cq 了。倘若数据不在 page cache 里，
io_uring 也不会阻塞在发送请求的阶段，相反，它会在后台发起读请求，并异步地阻塞，等到数据来了，再发起重试，如果没有别人先把数据读走了的话，这次读操作就会触发
completion 事件，通知调用方。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;io_uring-什么时候返回-eagain&quot;&gt;io_uring 什么时候返回 &lt;code&gt;-EAGAIN&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以说，不管是文件还是网络，如果使用新的支持 flags 的 API 进行 IO 的话，我们都可以进行非阻塞的 IO。刚才解释了，只要我们主动要求 &lt;code&gt;RWF_NOWAIT&lt;/code&gt;，那么就有机会得到 &lt;code&gt;EAGAIN&lt;/code&gt;。那我们这里先关注 socket。如果 socket 在创建的时候，我们指定了
&lt;code&gt;O_NONBLOCK&lt;/code&gt; 那么对它的操作时候是否会返回 &lt;code&gt;-EAGAIN&lt;/code&gt; 呢？先看 &lt;a href=&quot;https://github.com/torvalds/linux/commit/355afaeb578abac907217c256a844cfafb0337b2&quot;&gt;355afaeb&lt;/a&gt;。这个 commit 希望确立的行为是：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;-EAGAIN&lt;/code&gt; 的重试处理，仅仅适用于块设备或者普通文件。如果当前操作的 fd 两个都不是，
那么就立即停止重试的流程。换言之，只有块设备或者普通文件才需要重试，
因为它们传统上是不允许返回 &lt;code&gt;-EAGAIN&lt;/code&gt; 的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果对 nonblock 文件的 IO 返回了 &lt;code&gt;-EAGAIN&lt;/code&gt;，则不需要为其设置 poll handler。
这种情况就 &lt;strong&gt;应该&lt;/strong&gt; 返回 &lt;code&gt;-EAGAIN&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;第一个行为在 io_uring 后续的修改中加入了更细致的判断，即如果块设备或者普通文件支持前述的
nowait&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 &lt;a href=&quot;https://github.com/torvalds/linux/commit/e697deed834de15d2322d0619d51893022c90ea2&quot;&gt;e697de&lt;/a&gt;
中，也贯彻了这个方针。即，“如果 fd 有 &lt;code&gt;O_NONBLOCK&lt;/code&gt;，那么任何操作没能立即返回数据，都应该返回 &lt;code&gt;-EAGAIN&lt;/code&gt;”。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="io_uring" /><summary type="html">io_uring 的 cqe 到底会不会返回 EAGAIN？</summary></entry><entry><title type="html">Exception in Seastar</title><link href="https://blog.k3fu.xyz/seastar/2022/10/08/exception-in-seastar.html" rel="alternate" type="text/html" title="Exception in Seastar" /><published>2022-10-08T00:00:00+00:00</published><updated>2022-10-08T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/seastar/2022/10/08/exception-in-seastar</id><content type="html" xml:base="https://blog.k3fu.xyz/seastar/2022/10/08/exception-in-seastar.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;时机永远很重要。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先来一段代码&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cleaning up&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;试问 &lt;code&gt;finally()&lt;/code&gt; 里面的代码会执行吗？答案是：“不会”。为什么呢？因为按照 C&amp;#43;&amp;#43;
的话说，&lt;code&gt;fail().finally(&amp;#8230;&amp;#8203;)&lt;/code&gt; 是个表达式。表达式的结构类似:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-6c6032f5a590fbd6ef42122e0ee858a4.png&quot; alt=&quot;Diagram&quot; width=&quot;590&quot; height=&quot;448&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;表达式的参数在求值之前都会准备好。但是求值的过程有点像深度优先的遍历。但是又不完全是，遍历的顺序同时需要遵循 C&amp;#43;&amp;#43; 对各类表达式中的子表达式的求值顺序的要求。比如说，在 C&amp;#43;&amp;#43;17 之后，函数调用表达式中，其左边的参数即函数本身，需要在参数之前求值完毕，诸参数的求值顺序则没有要求。当所有参数都备好之后，再对函数调用，即 &lt;code&gt;()&lt;/code&gt; 这个操作进行求值。如果在求值过程中抛出异常，那么我们就会走常规流程，比如说所有的变量都会销毁。而最顶层的函数调用因为其参数还没有准备好，所以也无法开始其求值的过程。整个表达式在一个 &lt;code&gt;exception&lt;/code&gt; 前瞬间土崩瓦解。因此上面的 &lt;code&gt;f()&lt;/code&gt; 无法 &lt;strong&gt;返回&lt;/strong&gt; &lt;code&gt;seastar::future&amp;lt;&amp;gt;&lt;/code&gt; ，而是给调用方抛出 &lt;code&gt;exception&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;再看看下面的代码：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mx&quot;&gt;1s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fail&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;cleaning up&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这段代码中的 &lt;code&gt;finally()&lt;/code&gt; 就会被调用。因为 &lt;code&gt;then()&lt;/code&gt; 后面的 lambda
表达式在求值的时抛出的异常会被我们的 continuation 实现捕捉住，放到对应的 promise 中，确保它返回的 future 的 &lt;code&gt;finally()&lt;/code&gt;
函数调用能对其做出处理。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其实这个 caveat 在 &lt;a href=&quot;https://docs.seastar.io/master/tutorial.html#exceptions-vs.-exceptional-futures&quot;&gt;Seastar 的文档&lt;/a&gt; 里面有专门的章节解释。但是我之前并没有在意。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在此引以为戒。&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="seastar" /><summary type="html">时机永远很重要。</summary></entry><entry><title type="html">io_uring + Seastar</title><link href="https://blog.k3fu.xyz/seastar/2022/10/03/iouring-seastar.html" rel="alternate" type="text/html" title="io_uring + Seastar" /><published>2022-10-03T00:00:00+00:00</published><updated>2022-10-03T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/seastar/2022/10/03/iouring-seastar</id><content type="html" xml:base="https://blog.k3fu.xyz/seastar/2022/10/03/iouring-seastar.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如何用在 Seastar 里用上 &lt;code&gt;IORING_OP_SEND_ZC&lt;/code&gt;？&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot; class=&quot;title&quot;&gt;&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#引子&quot;&gt;引子&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#seastar-的磁盘-io&quot;&gt;Seastar 的磁盘 IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#seastar-的网络-io&quot;&gt;Seastar 的网络 IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#如何让-seastar-的网络-io-用上-io_uring&quot;&gt;如何让 Seastar 的网络 IO 用上 io_uring&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#网卡和硬盘&quot;&gt;网卡和硬盘&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#乐观和悲观&quot;&gt;乐观和悲观&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#io_queue&quot;&gt;io_queue&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;引子&quot;&gt;引子&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/910087/&quot;&gt;linux 6.0&lt;/a&gt; 为我们带来了 &lt;a href=&quot;https://lwn.net/Articles/879724/&quot;&gt;zero-copy 网络传输的 io_uring 支持&lt;/a&gt;。但是 Seastar 对 iouring 的支持仍然很有限，它仅仅支持下面几种操作&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;read&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;write&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;readv&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;writev&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而迄今为止 io uring 已经支持了 &lt;a href=&quot;https://github.com/axboe/liburing/blob/cf0b010a7b862ee6a44daa7dcb3f900bd757b04f/src/include/liburing/io_uring.h#L167&quot;&gt;48 种异步操作&lt;/a&gt;，这四种操作只是冰山一角。本文希望讨论一下如何为 Seastar 加入一部分网络 IO 的 io_uring 支持。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;seastar-的磁盘-io&quot;&gt;Seastar 的磁盘 IO&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;让我们先理解 &lt;code&gt;reactor_backend_uring&lt;/code&gt; 是如何工作的。下面是 &lt;code&gt;reactor_backend_uring&lt;/code&gt;
提交 IO 请求的调用路径。可以注意到，Seastar 是成批地提交请求的。而且请求并不是在
&lt;code&gt;poll_once()&lt;/code&gt; 的时候创建的，它们往往在类似 &lt;code&gt;posix_file_impl::do_write_dma()&lt;/code&gt;
的地方创建，并加入当前访问文件所对应的 &lt;code&gt;_io_queue&lt;/code&gt; 队列。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-b7ad16af82b7c0a669869e580471a17a.png&quot; alt=&quot;Diagram&quot; width=&quot;680&quot; height=&quot;392&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么 &lt;code&gt;_io_queue&lt;/code&gt; 是什么呢？Seastar 为了解决多 shard 共享磁盘 IO，同时最大化其吞吐量的问题，设计了 &lt;a href=&quot;https://www.scylladb.com/2021/04/06/scyllas-new-io-scheduler/&quot;&gt;用户态的 IO 调度机制&lt;/a&gt;。避免在 shard 之间搞平均主义和大锅饭，导致低效和拥塞。为了在核之间统筹规划 IO，Seastar
为每个设备定义一个 &lt;code&gt;io_group&lt;/code&gt;，同时让每个 shard 都持有和需要访问的设备对应的 &lt;code&gt;shared_ptr&amp;lt;io_group&amp;gt;&lt;/code&gt;。为了安放还不能服务的 IO 请求，每个设备在每个shard 上的 &lt;code&gt;engine&lt;/code&gt; 都有自己的 &lt;code&gt;io_queue&lt;/code&gt;。因此可以看到所以如果程序部署在 32 核的机器上，同时有 16 块硬盘，那么每个核都会有 16 个 &lt;code&gt;io_queue&lt;/code&gt;，分别对应自己负责访问的硬盘。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外，也需要注意 &lt;code&gt;reactor_backend_uring::submit_io_request()&lt;/code&gt; 的实现，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;switch&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opcode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;o&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_uring_prep_read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;address&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_uring_sqe_set_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;completion&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;_has_pending_submissions&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;get_sqe()&lt;/code&gt; 是一个循环：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;io_uring_sqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_get_sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_uring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;io_uring_submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_uring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_peek_batch_cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;complete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;io_uring_cqe_seen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_uring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里有两个需要注意的地方：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;IO 请求都是从 &lt;code&gt;io_queue&lt;/code&gt; 里面取出来的。而 &lt;code&gt;io_queue&lt;/code&gt; 是用户态 IO
调度器的一部分。显然，这个 IO 调度器并不包含网络 IO。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 aio 不同，io uring 后端的 &lt;code&gt;kernel_submit_work()&lt;/code&gt; 除了执行 submit
的动作，在 sqe 不够的时候也会执行 &lt;code&gt;reap_kernel_completions()&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过笔者认为，如果 sqe 不够用，那么收割 cqe 有可能是无济于事的。除非内核的网络子系统会因为用户取走 cqe 不够快而减缓 sqe 的处理。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;既然只有存储子系统的请求会走到这里，那么 Seastar 怎么处理网络上的 IO
请求呢？&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;seastar-的网络-io&quot;&gt;Seastar 的网络 IO&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面是 Seastar 写入 &lt;code&gt;output_stream&lt;/code&gt; 流的调用路径：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-960814248f756371b9e0604c558e73c8.png&quot; alt=&quot;Diagram&quot; width=&quot;590&quot; height=&quot;448&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，&lt;code&gt;reactor::do_write_some()&lt;/code&gt; 的实现类似&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;writeable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;msghdr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mh&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_iov&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fragment_array&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg_iovlen&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;nr_frags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendmsg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mh&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以 &lt;code&gt;reactor::do_write_some()&lt;/code&gt; 会等到 fd 可以写入的时候，再进行系统调用，确保这个
&lt;code&gt;::sendmsg()&lt;/code&gt; 是不阻塞的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以看出这两类 IO 在 Seastar 里的处理方式很不一样。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;如何让-seastar-的网络-io-用上-io_uring&quot;&gt;如何让 Seastar 的网络 IO 用上 io_uring&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;网卡和硬盘&quot;&gt;网卡和硬盘&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;再看硬件设备的异同点：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一方面，网卡有和存储类似的属性，比如说，它们都有吞吐量、队列深度这些全局的硬件指标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一方面，一般来说网卡和存储相比有高得多的吞吐。毕竟 40Gbps 的万兆网卡几百块就可以买到。
3100MB/s 的企业级固态盘的价格仍然高居不下，从数千到上万不等。这样也解释了为什么 Seastar
开发者为什么对用户态 IO 调度这么重视。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后，一般服务器可能只会安装两块网卡。但是可能会有一个 36 x 3.5寸盘位的高密机箱。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么把磁盘 IO 的用户态调度器的机制套用在网络 IO 上是否可行呢？答案是否定的。一台服务器上可以有多个网络出口。网卡也可以支持虚拟化，比如 SR-IOV，或者用 bond
把多块物理网卡捆绑成一块逻辑网卡。为了后面讨论简单起见，我们把这些网络出口简称为网卡。操作系统通过路由表来决定特定网络包使用哪块网卡。而我们在读写网络 socket 的时候，分两种情况&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读：这里我们无法预判将要读到的网络包是经由那块网卡发来的。本机路由表仅仅定义我们转发包的规则，
但是它没有定义交换机把数据包发给本机的哪块网卡。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写：路由规则是系统层面的设置。就算我们在用户态可以根据路由表来判断发出的网络包会选用那块网卡，
并且根据这个信息和网卡的带宽来做 shard 间的公平调度，这也是很麻烦的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为网卡的总体吞吐能力大大超过了存储设备，同时访问特定网段的网卡只有一两块，而我们的存储子系统常常需要同时和几十块硬盘打交道。所以为网络 IO 定义用户态调度器一方面难度挺高，一方面效益也不大，并且有的场景无法覆盖。如果只有单块网卡的话，问题稍简单一些。但仍然会是个投入产出不成正比的工程。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;乐观和悲观&quot;&gt;乐观和悲观&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面得出了不需要用户态 IO 调度的结论。那么发送网络 IO 还需要 &lt;code&gt;io_queue&lt;/code&gt; 吗？如果 &lt;code&gt;io_queue&lt;/code&gt; 不用来实现 per-shard 的公平队列，那么它的意义只是在于临时保存 IO 请求，让我们可以在成批地构造和发送 IO 到 sq 里面去。新的问题来了，什么时候 &lt;strong&gt;发送&lt;/strong&gt; IO 呢？或者说，我们应该/可以立即发送 IO 吗？有两个选择：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;reactor_backend_uring::write_some()&lt;/code&gt; 里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 &lt;code&gt;reactor_backend_uring::kernel_submit_work()&lt;/code&gt; 里&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果我们退后一步看，其实也可以乐观地用 &lt;code&gt;sendmsg(&amp;#8230;&amp;#8203;, MSG_DONTWAIT)&lt;/code&gt; 先试试看，如果系统返回 &lt;code&gt;EWOULDBLOCK&lt;/code&gt;，那么再用 &lt;code&gt;reactor::do_write_some()&lt;/code&gt; 的方式来处理这个 IO。我们知道，在内核里面的读写都是有 buffer 的。所以如果写缓冲区大小为 4k，每次只写 512 字节，那么我们可以连着写 8 次都不需要检查 &lt;code&gt;POLLOUT&lt;/code&gt; 。当然，在第 9 次的时候， 就会返回
&lt;code&gt;EWOULDBLOCK&lt;/code&gt; 了。这时我们可以切换到悲观模式，一旦写请求返回了，说明内核至少消耗了一部分缓冲区，这时我们可以重新振作，回到乐观模式。乐观模式可以直接在  &lt;code&gt;reactor_backend_uring::write_some()&lt;/code&gt; 直接把请求发送给内核，而悲观模式的工作则需要在 &lt;code&gt;reactor_backend_uring::kernel_submit_work()&lt;/code&gt; 完成处理。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;只要非阻塞的操作有“惯性”，那么我们就可以使用“乐观模式”和“悲观模式”的设计。因此，它也适用于其他 reactor backend。不过对于 io_uring 需要特别的权衡。因为 &lt;code&gt;sendmsg(&amp;#8230;&amp;#8203;, MSG_DONTWAIT)&lt;/code&gt; 本身仍然是一次系统调用，如果我们希望使用 SQPOLL 模式的话，这个开销是不容忽视的。如果不采用 SQPOLL 模式，那么把一次
&lt;code&gt;sendmsg(&amp;#8230;&amp;#8203;, MSG_DONTWAIT)&lt;/code&gt; 和两次 &lt;code&gt;io_uring_submit()&lt;/code&gt; 以及相应的两次协程切换相比，哪个效率更高，延迟更低呢？笔者认为“不好说”。但是对于高性能网卡来说，很可能前者性能更好。因为它能更早地把请求交给内核。而非
SQPOLL 模式下，两次 &lt;code&gt;io_uring_submit()&lt;/code&gt; 可是两次结结实实的系统调用。虽然这两次系统调用的开销可能可以分摊到发送的多个 sqe 上，但是对单个 IO
产生的延迟却是实实在在的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果不用“乐观模式”，假设我们只在 &lt;code&gt;reactor_backend_uring::kernel_submit_work()&lt;/code&gt;
和 &lt;code&gt;reactor_backend_uring::wait_and_process_events()&lt;/code&gt; 里面调用
&lt;code&gt;io_uring_submit()&lt;/code&gt;，那么这两个选项的延迟是相同的。毕竟，内核只能看到
submit 之后的 sqe。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;io_queue&quot;&gt;io_queue&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;从设计方面考虑，每个 &lt;code&gt;reactor&lt;/code&gt; 都有自己的 &lt;code&gt;io_sink&lt;/code&gt;，&quot;sink&quot; 可以理解为汇聚地。在 &lt;a href=&quot;https://github.com/scylladb/seastar/commit/c91d9e632a3f27610a75ed3e94b1d5d2e9131243&quot;&gt;c91d9e6&lt;/a&gt; 里面，作者提到&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;io_uring has a lot more operation types, and we would like to keep them
all in the same descriptor, so they can be used by the same queue.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里的 “descriptor” 指 &lt;code&gt;io_request&lt;/code&gt;。所以 Glauber 当初希望把更多的（或者说所有的）
io_uring 操作统一成 &lt;code&gt;io_request&lt;/code&gt; 放在一个队列里面。这样的好处应该是设计更一致，如果从性能角度分析的话，大概是 CPU 的 icache locality 更好吧。而且 &lt;code&gt;_io_sink&lt;/code&gt;
并非只为 &lt;code&gt;io_queue&lt;/code&gt; 服务。&lt;code&gt;reactor::fdatasync()&lt;/code&gt; 就是个例子。它直接构造 new 出来 &lt;code&gt;io_completion&lt;/code&gt; 和 &lt;code&gt;io_request&lt;/code&gt;，把它们扔进了 &lt;code&gt;_io_sink&lt;/code&gt;。大家可能会担心因为在 IO 路径上频繁动态内存分配，是不是会造成的性能问题。那么这真的是个问题，那么这个问题早已有之。因为 Seastar 里面的 &lt;code&gt;io_request&lt;/code&gt;
其实就是 &lt;strong&gt;new&lt;/strong&gt; 出来的，可以看看 &lt;code&gt;posix_file_impl::do_read_dma()&lt;/code&gt; 的实现。在把 &lt;code&gt;io_request&lt;/code&gt; 加入 &lt;code&gt;io_queue&lt;/code&gt; 的时候，会新建一个 &lt;code&gt;queued_io_request&lt;/code&gt;。它就是动态分配的，里面的 &lt;code&gt;io_desc_read_write&lt;/code&gt; 继承自 &lt;code&gt;io_completion&lt;/code&gt;。前者告诉 reactor 读写操作完成的时候应该做什么。后者是一个虚基类。自然 &lt;code&gt;io_desc_read_write&lt;/code&gt; 也是动态分配的了。所以以存储 IO 的标准来评判，为每一个网络IO 动态分配 &lt;code&gt;io_comlpetion&lt;/code&gt; 和 &lt;code&gt;io_request&lt;/code&gt; 并不是很过分的事情。不过我们在实现 io_uring 支持的时候，可能无法重用 &lt;code&gt;io_desc_read_write&lt;/code&gt; 了。因为它是用户态 IO 调度机制的一部分，其中还包含着公平队列的实现。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面的讨论基本确定了我们倾向于用 &lt;code&gt;io_completion&lt;/code&gt; 、 &lt;code&gt;io_request&lt;/code&gt; 和 &lt;code&gt;io_sink&lt;/code&gt;
的组合来发送 uring 请求。但是读者是否还记得 &lt;code&gt;reactor::do_write_some()&lt;/code&gt; 的实现呢？它先等待 &lt;code&gt;writable(fd)&lt;/code&gt;。这事实上起到 throttle 的作用，如果内核来不及消化这许多 IO
的话，fd 是不会 writable 的。那么 io_uring 的各种操作呢？如果我们希望用 Seastar
编写一个异步的 API 网关，那么在客户端发送大量请求的时候，倘若没有内核的反馈，可能会产生海量的 &lt;code&gt;io_request&lt;/code&gt; 堆积在 &lt;code&gt;io_sink&lt;/code&gt; 里面。这对性能不仅没有帮助，反而会短时间内消耗大量内存用于保存 &lt;code&gt;io_request&lt;/code&gt; 以及 payload。笔者认为，可能更好的方式应该是在 &lt;code&gt;reactor_backend_uring::write_some()&lt;/code&gt; 中加入类似
&lt;code&gt;co_await writable(fd)&lt;/code&gt; 的环节。但是 Avi 还是建议直接把请求扔给 io_uring，这样可以获得更低的延迟。 因为使用 io_uring 提交 sendmsg 请求的几个步骤基本是不阻塞的：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_uring_get_sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;io_uring_prep_sendmsg_zc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msghdr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg_flags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;io_uring_sqe_set_data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sqe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;io_uring_submit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ring&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果使用 &lt;code&gt;IORING_SETUP_SQPOLL&lt;/code&gt;，&lt;code&gt;io_uring_submit()&lt;/code&gt; 甚至不用陷入内核态，从而有更低的延迟。毕竟应用程序自己是可以设计 back pressure 机制的。如果希望在提交请求之前等待 poll 的结果，用这种方式实现 back pressure
则会提高延迟。这个想法的出发点并没有问题，但是它加重了 io_uring 的负担。因为每个 &lt;code&gt;poll(2)&lt;/code&gt; 调用和返回值的处理，对应用程序和内核都会是个额外的开销。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以沿用之前的基于预测（speculation）的设计，用 Python 伪代码来写就是：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write_some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;speculation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;non_block_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_and_clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sendmsg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;MSG_DONTWAIT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;speculation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;non_block_tx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EAGAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit_request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prep_sendmsg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在这里采用了同步非阻塞和异步阻塞调用相结合的设计。如果上次的写操作完成了，没有 short
write，则大概率这次能够进行非阻塞的写，所以直接使用 POSIX 非阻塞的系统调用，如果运气不好的话，就把请求发给 io_uring 采用阻塞的调用。需要注意，如果我们用 &lt;code&gt;O_NONBLOCK&lt;/code&gt; 打开这个文件的话，那么 &lt;code&gt;prep_sendmsg()&lt;/code&gt; 的 sqe
可能会返回 &lt;code&gt;-EAGAIN&lt;/code&gt; 或者 &lt;code&gt;-EWOULDBLOCK&lt;/code&gt;，而 &lt;code&gt;io_completion::complete_with()&lt;/code&gt;
看到这个错误会把它当成 &lt;code&gt;std::system_error(EAGAIN, std::system_category())&lt;/code&gt;
扔出来。这个行为和其他的 reactor 后端会不兼容。所以要么我们让 &lt;code&gt;io_completion&lt;/code&gt;
能为我们网开一面，让我们有重试的机会。或者干脆用阻塞的 IO，即在打开文件的时候不指定
&lt;code&gt;O_NONBLOCK&lt;/code&gt;。后者要容易一些。对于普通文件的写操作，因为 write 不提供 &lt;code&gt;MSG_DONTWAIT&lt;/code&gt;
的 flag，我们无法使用刚才的策略。为了不阻塞 reactor 所以只能使用 &lt;code&gt;O_NONBLOCK&lt;/code&gt;
打开文件，POSIX 的 write 返回 &lt;code&gt;-EAGAIN&lt;/code&gt; 的时候，等待 writable 之后，再提交新的写操作：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;async&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;write_some&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;):&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;speculation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;non_block_tx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;test_and_clear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;msg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;speculation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;non_block&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;True&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;EAGAIN&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;raise&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit_request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prep_poll&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;POLLOUT&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;await&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;submit_request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prep_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;笔者想，io_uring 的一个优势是减少系统调用，提高总体的性能。但是这种基于预测的 IO 的执行方式在理想情况下并不能减少系统调用，虽然它能在及时消耗 buffer 的情况下减少延迟。正如 Avi 提到的&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;we can have latency of 0.5ms even though data is ready because the reactor will prefer to run tasks and gather more I/O.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以只要能 inline 地发送 IO，我们就会直接把请求直接发送出去，而不是等
reactor 的工作线程把“一天”工作都完成，在下班的时候“顺路”把当天收集到的 IO
成批地发送出去，那样的延迟会比较高。SQPOLL 的引入是不是会改变这个状况呢？因为在 SQPOLL 模式下，内核的 SQPOLL 线程会帮我们发送 sqe。这样的话，直接
inline 地发送请求就可以了，而不用把 IO 请求加入队列，统一处理。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;文中的提议已经写成了 &lt;a href=&quot;https://github.com/scylladb/seastar/pull/1235&quot;&gt;PR#1235&lt;/a&gt;，一旦这个 PR merge，那么 &lt;code&gt;IORING_OP_SEND_ZC&lt;/code&gt; 也就不远了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="seastar" /><category term="io_uring" /><category term="seastar" /><summary type="html">如何用在 Seastar 里用上 IORING_OP_SEND_ZC？</summary></entry><entry><title type="html">从 perftune.py 说起</title><link href="https://blog.k3fu.xyz/seastar/2022/09/03/seastar-perftune.html" rel="alternate" type="text/html" title="从 perftune.py 说起" /><published>2022-09-03T00:00:00+00:00</published><updated>2022-09-03T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/seastar/2022/09/03/seastar-perftune</id><content type="html" xml:base="https://blog.k3fu.xyz/seastar/2022/09/03/seastar-perftune.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;再来俩缩写，我也能承受！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;perftune.py&lt;/code&gt; 是 Seastar 用来配置系统参数的工具，目标是提高 Seastar 应用的性能。ScyllaDB 的文档有
&lt;a href=&quot;https://docs.scylladb.com/stable/operating-scylla/admin-tools/perftune.html&quot;&gt;类似 manpage 的粗略介绍&lt;/a&gt;。笔者在理解它的过程中，发现它的实现不仅仅源于 Linux 的文档，也包含了实践的经验。这些知识和经验不仅仅对 Seastar 应用有意义，也可以推广到其他多核程序的优化。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;三个模式&quot;&gt;三个模式&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;perftune.py&lt;/code&gt; 的前身是 &lt;code&gt;posix_net_conf.sh&lt;/code&gt;。这个脚本被用来设置 IRQ 的亲和性和 RPS。它做这两件事&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;把 eth0 所有的 IRQ 都绑定到 CPU0，即让 CPU0 处理来自该网卡的中断请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按照 eth0 上的 rps queue 的个数，把它分摊到机器上的所有 CPU 上。因为 CPU 的个数常常是 rps queue
的倍数。如果是 40 核 CPU，对应 8 个 queue 的网卡，那么每 5 个 CPU 核都会分到一个 rps queue。
这时，就需要配置 CPU 掩码，让每个 rps queue 上的包都能均匀分配到这个 queue 所对应的 5 个 CPU
核上。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先进的多队列网卡一般提供单独的 rx 队列配置，或者 rx 和 tx 共用的队列。后者被记为“combined”。为了简单起见，后面统称为 rx 队列。这种技术叫做 Receive Side Scaling，即 RSS。RSS
把接收到的数据包分散在多个 rx 队列里面，每个队列通过硬中断把 “有新数据来啦”
这个消息告诉负责处理这个硬中断的 CPU。请注意，这里负责处理特定中断号的 CPU 可以是多个。对于单队列网卡，只能用 RPS 队列用软件实现多队列。关于 RPS，后面 &lt;a href=&quot;#rps-和-rfs&quot;&gt;RPS 和 RFS&lt;/a&gt; 一节有简单的介绍。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ ip link show
...
6: eno2: &amp;lt;NO-CARRIER,BROADCAST,MULTICAST,UP&amp;gt; mtu 1500 qdisc mq state DOWN mode DEFAULT group default qlen 1000
    link/ether 78:ef:44:03:a8:ce brd ff:ff:ff:ff:ff:ff
    altname enp25s0f1
...
$ ethtool -l eno2
Channel parameters for eno2:
Pre-set maximums:
RX:             n/a
TX:             n/a
Other:          1
Combined:       80
Current hardware settings:
RX:             n/a
TX:             n/a
Other:          1
Combined:       80
$ nproc
80&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如上所示， 机器上有 80 个 PU。&lt;code&gt;eno2&lt;/code&gt; 也正好有 80 个 rx 队列。如果让 &lt;code&gt;perftune.py&lt;/code&gt;
自动配置这台机器上的 &lt;code&gt;eno2&lt;/code&gt; 的 rx 队列的话，它会按照 PU 的个数设置 rx 队列的个数。即&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;# ethtool --set-channels eno2 combined 80&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了优化这个数据链路，围绕硬中断的分配和 RPS 的配置， &lt;code&gt;perftune.py&lt;/code&gt;
根据 rx 队列的个数和机器上内核的数量预定义了三种模式，希望覆盖大多数场景：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;multi-queue&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;对于支持多硬件队列的网卡，我们则需要把 CPU 核按照队列的数量分组，
通过 RPS 让每一组 CPU 核分担自己的队列来的数据包。&lt;code&gt;perftune.py&lt;/code&gt; 把这种模式称为 &quot;mq&quot; 模式，
即 multi-queue 模式。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;single-queue&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;与 mq 模式对应的就是 single-queue 模式。简称 sq 模式。它把给定网卡的所有
IRQ 都安排给 CPU0，但是用 RPS 把软中断以及它引起的 NAPI 轮询分配给其他 CPU。
这里的 CPU0 是 &lt;code&gt;hwloc&lt;/code&gt; 说的 PU。如果 CPU 打开了超线程的话，那么就是一颗 HT 的核。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;sq-split&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;还有一种模式叫 sq-split。它把所有 IRQ 分给 CPU0 所在的物理核。如果架构支持
SMT (symmetric multithreading），那么一般来说，一个物理核（core）上会有两个
HT 核（PU）。如果使用 sq-split 模式，那么 &lt;code&gt;P#0&lt;/code&gt; 和 &lt;code&gt;P#1&lt;/code&gt; 就会被用来处理特定网卡的所有 IRQ，
剩下的核就借助 RPS 来平均分配工作。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;sq-split 的设计采纳了
&lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/scaling.txt&quot;&gt;kernel.org 文档&lt;/a&gt; 中，
&lt;em&gt;Suggested Configuration&lt;/em&gt; 一节的建议。这里摘录如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Per-cpu load can be observed using the mpstat utility, but note that on
processors with hyperthreading (HT), each hyperthread is represented as
a separate CPU. For interrupt handling, HT has shown no benefit in
initial tests, so limit the number of queues to the number of CPU cores
in the system.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; Suggested Configuration&lt;br&gt;
&lt;cite&gt;https://www.kernel.org/doc/Documentation/networking/scaling.txt&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以在超线程的系统里面，为两个 HT 核心分别分配不同的 rx 队列，并不能提高
pps (packet per second)。这个结论也很自然，因为 SMT 只不过是让 HT
核能共享 CPU 的流水线，填充流水线气泡，提高流水线的利用率。但是对于硬中断的处理并不适用，因为硬中断处理和 NAPI 轮询是典型的单线程程序。如果两个硬中断或者 rx 队列都安排在同一个
core 上，反而会导致这个 core 手忙脚乱穷于应付，在两个 NAPI 轮询之间来回切换，提高延迟。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么这些模式分别适用什么配置呢？我们分情况讨论。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 aws 提供的云服务器中有一些很强大的机器，它们有很多逻辑核，不过这些机器的网卡的 rx
队列也一样多。如果按照 mq 来配置，就会导致每个 CPU 核心都会分心处理 IRQ。和专人负责负责
IRQ 的模式相比，反而性能更差。同时，这些机器的处理能力很强，根据经验数据，专门给网卡分配一个物理核才能充分发挥网卡的性能。同时避免因为均匀地分配 IRQ，导致很多核总是被硬件中断打断，造成大量的上下文切换，影响性能。当然这也是个权衡，因为把一整个物理核用来处理中断可能会有些大材小用了。好像派五虎将之一的赵云去搞街道治安一样。在 &lt;a href=&quot;https://github.com/scylladb/seastar/pull/949&quot;&gt;PR#949&lt;/a&gt; 有一些讨论，
Avi 就认为这样的安排很浪费。不过如果真的整体性能下降了，我们还是可以回去使用完全对称的大锅饭 multi-queue 模式。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过现在的处理方式仍然是启发式，或者说是经验式的：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_PUs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerfTunerBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SupportedModes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mq&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerfTunerBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SupportedModes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sq&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;PerfTunerBase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;SupportedModes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sq_split&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;简单说，就是如果你家里有超过 5 个物理核，那么推荐 sq-split，让一个 &lt;strong&gt;物理核&lt;/strong&gt; 专司 IRQ 处理，因为我们能负担得起。倘若 HT 核超过 5 个，那么我们用 single-queue，让一个 &lt;strong&gt;HT 核&lt;/strong&gt;
负责为大家处理 IRQ。要是 HT 核少于 5，CPU 资源有点紧张了，就用 mq，因为我们希望充分利用 &lt;strong&gt;每一个&lt;/strong&gt; HT 核。这三个模式可以说是从皇帝版到乞丐版。皇帝版从让赵云专门负责核酸。而乞丐版让五虎将每个人除了阵前杀敌，业余时间还需要到营房门口检查场所码。如果说
sq-split 是专业分化的典型，那么 mq 就是是人尽其用的极致了。至于 &lt;a href=&quot;https://github.com/scylladb/seastar/pull/949&quot;&gt;PR#949&lt;/a&gt;
的讨论中，为什么 &lt;code&gt;IORING_SETUP_SQPOLL&lt;/code&gt; 能让 mq 的设置在这种配置的机器有更好的表现。笔者没有很好的解释，&lt;code&gt;IORING_SETUP_SQPOLL&lt;/code&gt; 让内核线程轮询 ringbuffer 里新的 sqe，避免用户态程序频繁使用 &lt;code&gt;io_uring_enter()&lt;/code&gt; 系统调用提交请求。这有点像 NAPI 的处理方式。这个设计把用户态程序从系统调用的义务中解放了出来，但是对于 IO 不是很多的应用，内核线程的轮询也仍然是一个不小的负担。当然，&lt;code&gt;sq_thread_idle&lt;/code&gt;
可以让内核在一段时间之内没有 IO 的话，就把轮询线程停下来。不管如何，这都是 TCP/IP 四层模型之上的问题，三个模式希望解决的问题是在其之前发生的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过 Seastar 最近有个 &lt;a href=&quot;https://github.com/scylladb/seastar/issues/1170&quot;&gt;新 issue&lt;/a&gt;，它认为应该停止使用 &lt;code&gt;--mode&lt;/code&gt;，而开始用 &lt;code&gt;--irq-cpu-mask&lt;/code&gt; 选项。那么什么是 &lt;code&gt;--irq-cpu-mask&lt;/code&gt; 呢？&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;irq-cpu-mask&quot;&gt;&lt;code&gt;--irq-cpu-mask&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;--irq-cpu-mask&lt;/code&gt; 是 &lt;code&gt;perftune.py&lt;/code&gt; 新设计的选项。它具有更细致的配置能力。前面按照硬件条件简单地把机器分为三档，分别套用一个配置模式。但是对于非常强的多核机器，比如说 48 核的机器，就算使用 sq-split 把一整个核用来处理 IRQ，可能也忙不过来。随着多核机器配置越来越强，前面的三种模式显得不够用了。况且它们没有把 NUMA 纳入考虑。所以除了要有比 sq-split 更&lt;s&gt;浪费&lt;/s&gt;霸气的模式，我们还需要更细粒度的配置方式。前面三种模式的核心回答的是 RSS 的配置问题，即 rx
队列的分配问题。但是在多核系统中，整个数据链路上，每个环节都可以优化。我们这里仅仅关注 IRQ、RSS 和 RPS 的配置。 把它们具体化，就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;IRQ 可以分配给哪些 PU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有哪些 IRQ 需要分配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这些IRQ 和用来处理 IRQ 的 PU 的对应关系如何&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;irq-cpu-mask-2&quot;&gt;IRQ CPU mask&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;--irq-cpu-mask&lt;/code&gt; 就是第一个问题的答案，它允许用户自己设定 IRQ 会分配给 &lt;strong&gt;哪些&lt;/strong&gt; PU。但是也和之前一样，提供了自动配置的功能。但是为了避免之前“两刀切”的粗线条解决方式，这次 &lt;code&gt;perftune.py&lt;/code&gt; 按照比例分配 IRQ。下面的算法用来分配处理 IRQ 的 CPU：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_PUs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_mask&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_hwloc_calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'--restrict'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'PU:0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;elif&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cores_per_irq_core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_hwloc_calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'--restrict'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'core:0'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 竟然核数超过了每个 IRQ 指定的核心数，肯定是个很强力的机器，
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# 这样我们就可以按照比例分配 IRQ 核心了
&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;# num_irq_cores 是按照比例平摊之后，负责 IRQ 的总核心数
&lt;/span&gt;    &lt;span class=&quot;n&quot;&gt;num_irq_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;math&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ceil&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;num_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cores_per_irq_core&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hwloc_args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;numa_cores_count&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numa_ids_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;added_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;# 在每个 NUMA 节点上均匀地征集 core，直到凑够数为止
&lt;/span&gt;    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;added_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_irq_cores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numa&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;numa_ids_list&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;hwloc_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;append&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sa&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;node:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numa&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;.core:&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numa_cores_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;added_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;numa_cores_count&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;numa&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;added_cores&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;num_irq_cores&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;break&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;run_hwloc_calc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'--restrict'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hwloc_args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;cpu_mask&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;是由用户指定可用于负责 IRQ 调优的 cpu 集合。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;cores_per_irq_core&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;每个 IRQ 安排对应的核数，如果这个数字是 6 的话，那么每六个核心，
就会分出一个核心用来负责 IRQ。这个数字有点类似抽壮丁的比例。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个算法和之前的“三个模式”算法类似，只不过为“强力机器”专门增加了按照 NUMA 平均成比例分配
IRQ core 的模式。原版的算法还要求制定的 &lt;code&gt;cpu_mask&lt;/code&gt; 在 NUMA 各节点是 core 数和 PU
数是相等的。为了突出重点，在上面的代码中没有摘录。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;“抽了壮丁”之后，怎么分配这些“壮丁”呢？下面说一下第二个问题。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;有哪些-irq-需要分配&quot;&gt;有哪些 IRQ 需要分配&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们先了解一下中断和 rx 队列之间的对应关系：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ cat /proc/interrupts
            CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7
...
  91:          5          0          0          0          0          0          0          0  IR-PCI-MSI 12584961-edge      eno2-TxRx-0
...&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上面的输出中，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;最左边一列&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;是 IRQ 的序号&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;每个 CPU 各有一列&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;能够告诉我们这个 IRQ 在对应的 CPU 上触发了多少次&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;倒数第三列&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;表示 IRQ 的类型。这里是一种叫 &lt;a href=&quot;https://docs.kernel.org/PCI/msi-howto.html&quot;&gt;Message Signaled Interrupt&lt;/a&gt; 的中断。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;倒数第二列&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;和中断控制器有关或者和中断触发的方式有关&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;倒数第一列&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;表示 IRQ 对应的设备。这里是 &lt;code&gt;eno2&lt;/code&gt; 这块网卡的第 0 个 TxRx 队列。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;要是只想知道网卡用了哪些中断，也可以用：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ ls /sys/class/net/eno2/device/msi_irqs/
90  91  92  93  94  95  96  97  98&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个信息和之前观察 &lt;code&gt;/proc/interrupts&lt;/code&gt; 获得的信息一般来说是一致的。不过实际使用中，也有网卡真正使用的 MSI-IRQ 只是驱动申请使用的一部分。有点像驱动申请了 10
门牌号，但是最后只有 9 个屋子用了这些门牌号。所以 &lt;code&gt;perftune.py&lt;/code&gt; 取了两者的交集，作为需要分配的 IRQ。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;排排坐分果果&quot;&gt;排排坐分果果&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;完整的说法是，PU 排排坐，分 IRQ 果果。把 IRQ 分给多个 PU 处理，目标还是提高 PPS，也就让并发更高，延迟更小。这些是目标，除了 PU 和 IRQ 本身，还有哪些约束条件和考量呢？关于 IRQ 和 PU 亲和性比较权威的参考资料仍然来自
&lt;a href=&quot;https://www.kernel.org/doc/Documentation/IRQ-affinity.txt&quot;&gt;kernel.org&lt;/a&gt;。前面摘录的建议仍然适用，所以我们不会用让多个 PU 分担同一个中断，而选择用一对一的映射。如果刚才得到的 CPU mask 是 &lt;code&gt;0xffffffff&lt;/code&gt;，那么我们可以用下面的命令分配 IRQ：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ hwloc-distrib 9 --single --restrict 0xffffffff
0x00000001
0x00000004
0x00000040
0x00000100
0x00001000
0x00000002
0x00000020
0x00000200
0x00002000&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，每一行的掩码制定一组 CPU。每一组 CPU 负责对应的要分配的元素。比如说，第一行中 &lt;code&gt;0x00000001&lt;/code&gt; 就用来处理第一个 IRQ，即前面列出的 IRQ 90。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;9&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;指定需要分配的元素个数&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;--single&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;每个元素对应一个 CPU。否则如果 CPU 供应充足的话，若是不指定
&lt;code&gt;--single&lt;/code&gt;，&lt;code&gt;hwloc-distrib&lt;/code&gt; 返回的掩码会含有多个 CPU。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;--restrict&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;指定分配的 CPU set。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以在给出的 32 个 PU 中，再选出了 9 个幸运儿。现在再分别给每个 IRQ
指定这些选出来的 PU：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ echo 00000001 &amp;gt; /proc/irq/90/smp_affinity&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面把网卡的所有 IRQ 都不加区别地分给了所有凑出来的壮丁 PU，如果网卡有多个 rx 队列，那么 &lt;code&gt;perftune.py&lt;/code&gt; 还有更细致的考虑。它会分两次。第一次把负责 rx 队列的 IRQ
均匀分布在壮丁 PU 中，第二次再把剩下的 IRQ 分布在同一个 PU 集合中。和大锅饭的统一分配相比，这样确保 rx 队列对应的 IRQ 能有更均匀的分布。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;rps-和-rfs&quot;&gt;RPS 和 RFS&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;RPS 是 Receive Packet Steering 的缩写。RPS 和 RSS 类似，目标都是希望让 CPU
核分担处理接受到数据包的工作，以提高性能。但是 RPS 工作在纯软件的层面。所以它更灵活，可以由软件设置它分配数据包的算法。但是它也带来了 CPU 核心之间的中断，即 IPI
(inter-processor interrupts)。缺省 RPS 是关掉的，即谁通过网卡 IRQ 收到的包，谁负责处理。但是要知道，接收数据包本身就意味着处理硬中断，处理软中断，执行 NAPI 轮询收包，以及把数据包在协议栈逐级向上传递。这还不包括用户态程序从 socket 读出数据后的处理。由于硬件队列的数量往往小于 CPU 的核心数，这样就会出现一核干活，七核加油的景象。为了让另外七个核心也能帮忙处理硬件队列发来的数据包，我们需要告诉操作系统，让它把第一个核从硬件队列收下来的包分配给那七个核心。另外，在 LWN 也有一篇
&lt;a href=&quot;https://lwn.net/Articles/370153/&quot;&gt;介绍&lt;/a&gt;，可供参考。如果需要更深入的阅读，一定要看一下 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/scaling.txt&quot;&gt;kernel.org 上的文档&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 RPS 工作在软件的层面，我们为 RPS 分配 PU 的时候顾虑就少一些。在 &lt;code&gt;perftune.py&lt;/code&gt; 里面，它把所有的 PU 分给每一个 RPS 队列：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ echo 0xffffffff &amp;gt; /sys/class/net/eno2/queues/rx-0/rps_cpus&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;kernel.org 有诗云：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For a multi-queue system, if RSS is configured so that a hardware
receive queue is mapped to each CPU, then RPS is probably redundant
and unnecessary. If there are fewer hardware queues than CPUs, then
RPS might be beneficial if the rps_cpus for each queue are the ones that
share the same memory domain as the interrupting CPU for that queue.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; Suggested Configuration&lt;br&gt;
&lt;cite&gt;https://www.kernel.org/doc/Documentation/networking/scaling.txt&lt;/cite&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;既然 RSS 都把所有的 PU 都占满了，也没有必要再上 RPS 了。但是，这个还不是问题的最终答案。因为我们还有 Receive Flow Steering，即 RFS。RPS 是按照包的地址和端口算出来的
hash 决定这个包会发往哪个队列，最后由负责这个队列的 CPU 处理。这些都是 Linux 内核的事情。但是绝大多数时候，最后处理数据包的还是用户态程序，那么怎么确保这个数据包的收件地址就是着这个数据包的用户态程序，即将被调度到的 CPU 核呢？换句话说，我们需要解决一个 hash 到 CPU 的问题。那么 CPU 怎么选呢？内核认为上次处理这个流中，上一个数据包的 CPU 是更可能被调度到处理下一个数据包的。就像一个浪漫的爱情故事里面，男主和女主在地铁上邂逅，那么男主要想再见到她，十有八九会再去同一趟地铁碰碰运气。虽然女主可能下次坐的地铁可能和上次不一样。但是这种惯性还是很可靠的。所以内核为这种重逢专门记录了一个数组，数组中的元素类似&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rps_sock_flow_entry&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cpu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flow_hash_hi&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;26&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rps_sock_flow_table&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;rps_sock_flow_entry&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当然，&lt;code&gt;cpu&lt;/code&gt; 和 &lt;code&gt;hi_flow_hash&lt;/code&gt; 合起来是个 32 位，它们分别占用多少 bit
是根据系统里面内核数来决定的。上面的代码最多就能支持 64 个核。内核里每当发现
&lt;s&gt;女主的身影&lt;/s&gt; 有读写网络的操作发生，都会更新 &lt;code&gt;rps_sock_flow_table&lt;/code&gt;，记录下最新的 hash &amp;#8594; cpu 的映射关系，以备查找。所以在 Linux 内核里：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;cm&quot;&gt;/* First check into global flow table if there is a match */&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;ident&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock_flow_table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sock_flow_table&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ident&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;^&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hash&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rps_cpu_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;goto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;try_rps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;next_cpu&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ident&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rps_cpu_mask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以，上面的代码中，&lt;code&gt;sock_flow_table&lt;/code&gt; 的下标是 hash 的低位。如果查出来的 flow table
entry 和 hash 不吻合，那么就转而使用 RPS 来决定送到哪个 CPU。否则就取出表项中 CPU
的部分，作为包的目的地。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;perftune.py&lt;/code&gt; 的设置基本按照 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/scaling.txt&quot;&gt;kernel.org 的建议设置&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在网络的数据链路上，除了 IRQ 亲和性，RSS、RPS 和 RFS 的设置，还有 aRFS 和 XPS
的设置。这里限于篇幅，就不再赘述了。建议大家仔细研读 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/scaling.txt&quot;&gt;kernel.org 上的文档&lt;/a&gt;，以及相关的内核代码。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;lstopo&quot;&gt;&lt;code&gt;lstopo&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外，为了更好的理解系统架构和多核，&lt;code&gt;hwloc&lt;/code&gt; 提供的工具是个好帮手，它能帮助我们理解系统的拓扑情况。比如在笔者的 Apple M1 Pro 上，就有一个 package，四个 core，八个超线程 PU。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ lstopo
Machine (3484MB total)
  Package L#0
    NUMANode L#0 (P#0 3484MB)
    L2 L#0 (4096KB)
      L1d L#0 (64KB) + L1i L#0 (128KB) + Core L#0 + PU L#0 (P#0)
      L1d L#1 (64KB) + L1i L#1 (128KB) + Core L#1 + PU L#1 (P#1)
    L2 L#1 (4096KB)
      L1d L#2 (64KB) + L1i L#2 (128KB) + Core L#2 + PU L#2 (P#2)
      L1d L#3 (64KB) + L1i L#3 (128KB) + Core L#3 + PU L#3 (P#3)
    L2 L#2 (4096KB)
      L1d L#4 (64KB) + L1i L#4 (128KB) + Core L#4 + PU L#4 (P#4)
      L1d L#5 (64KB) + L1i L#5 (128KB) + Core L#5 + PU L#5 (P#5)
    L2 L#3 (4096KB)
      L1d L#6 (64KB) + L1i L#6 (128KB) + Core L#6 + PU L#6 (P#6)
      L1d L#7 (64KB) + L1i L#7 (128KB) + Core L#7 + PU L#7 (P#7)
  CoProc(OpenCL) &quot;opencl0d0&quot;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;同时，也建议使用终端的读者尝试一下下面的命令，获得更炫酷的视觉体验：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ lstopo -.ascii&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
在 RockyLinux 9 上，&lt;code&gt;lstopo&lt;/code&gt; 的名字叫做 &lt;code&gt;lstopo-no-graphics&lt;/code&gt;，
因为后者不能输出图形的格式，对于软件包的维护者来说，编译时和运行时的依赖更容易解决。
如果嫌麻烦的话，也可以直接用 &lt;code&gt;hwloc-ls&lt;/code&gt;。它是 &lt;code&gt;lstopo-no-graphics&lt;/code&gt; 的软链接。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="seastar" /><summary type="html">再来俩缩写，我也能承受！</summary></entry><entry><title type="html">C++20 的 move-only iterators</title><link href="https://blog.k3fu.xyz/2022/07/16/move-only-iterators.html" rel="alternate" type="text/html" title="C++20 的 move-only iterators" /><published>2022-07-16T00:00:00+00:00</published><updated>2022-07-16T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2022/07/16/move-only-iterators</id><content type="html" xml:base="https://blog.k3fu.xyz/2022/07/16/move-only-iterators.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如无必要，勿增实体。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;曾经，&lt;code&gt;iterator&lt;/code&gt; 必须支持拷贝。但是很多情况下这个要求甚至算不上锦上添花，而会直接限制 &lt;code&gt;iterator&lt;/code&gt; 的使用场景。 &lt;a href=&quot;http://wg21.link/P0902R0&quot;&gt;p0902r0&lt;/a&gt;
把这个窘境总结了一下，提出了 &lt;strong&gt;move-only iterator&lt;/strong&gt;。本文试着以笔者自己的语言去重复这篇提议。希望这样可以更好地理解它的来龙去脉。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;一些背景&quot;&gt;一些背景&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;平时编程的时候，我们常常使用一些容器，比如 &lt;code&gt;std::vector&lt;/code&gt; 和 &lt;code&gt;std::map&lt;/code&gt; 来跟踪一组数据。尽管这两类容器的访问模式可以很不同，前者支持用下标进行随机的访问，而且用游标可以在里面前后游走，后者的也可以用游标前后移动，访问游标指向的 KV 对，但是它无法用下标访问。&lt;code&gt;std::map&lt;/code&gt; 是一种关联型 (associative) 容器，用 key
作为索引才是存取它的正确手段。但是不管它们的访问模式如何，我们发明了 iterator
作为抽象的索引机制，能兼容这两种不同的访问模式。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;它大约有下面几类功能&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;作为点查询 (point query) 的返回值，比如说 &lt;code&gt;std::map::find()&lt;/code&gt; 的返回值。
当然，iterator 也需要能表示一个无效的返回值，说明找不到符合的元素。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用来表示一个区间，对于有序的容器，两个 iterator
中间的那些元素不正好也是这个有序容器的一个部分吗？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;作为游标能在容器里面移动，访问其他容器的部分。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;老马的实时菜单&quot;&gt;老马的实时菜单&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;iterator 除了用来访问现成的容器里的数据，我们似乎也能用它来 &lt;strong&gt;存取&lt;/strong&gt; 一些即时生成的数据呢？问题来源于生活，让我们还是从生活出发。老王来到一个新开的饭馆，也许他看错了店招：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;不知所措的食客老王在面馆里面质问店里面的伙计:&lt;/div&gt;
&lt;blockquote&gt;
啊，面馆里面竟然不卖面？那你们都有什么呢？
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;大义凛然的伙计（其实是掌柜老马）:&lt;/div&gt;
&lt;blockquote&gt;
我们有，普通泡馍，优质泡馍，纯羊肉泡馍，腊牛肉夹馍，羊杂汤。
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;老马作为店主，显然对小店提供的服务烂熟于心，他结合当前的剩余物资和食客可能的消费水平，对这张实时渲染生成的菜单进行了定制化，如果食客身着“锦衣”，那肯定也能负担“玉食”。这时候，老马的答案可能就是：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;div class=&quot;title&quot;&gt;眉开眼笑的伙计（其实还是老马）:&lt;/div&gt;
&lt;blockquote&gt;
客官里面请！我们有，正黄旗金枪鱼，苏州龙虾，花毛一体盖浇饭，特优质泡馍，超纯羊肉泡馍，顶级羊杂汤。
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了更便于理解，两人的对话化为程序&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tour_in_casa_de_mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wong&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;menu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;appearance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pick_in_menu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meal&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;put_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;co_await&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;co_return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Wong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Sentinel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick_in_menu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Sentinel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;first&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;last&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;want_to_try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;first&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，&lt;code&gt;mars.menu()&lt;/code&gt; 返回的是一份神奇的可定制菜单&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CustomizedMenu&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;CustomizedMenu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;sentinel&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;public:&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reference_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pointer_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;difference_type&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;ptrdiff_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;unique_ptr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Mars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)},&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dish_with_price_higher_than&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rhs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;default&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;out_of_range&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dish_with_price_higher_than&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;friend&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sentinel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;it&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has_more&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;reference_type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;has_more&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;nl&quot;&gt;private:&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has_more&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;price&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;iterator&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;affordable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;sentinel&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里面 &lt;code&gt;Mars&lt;/code&gt; 代表老马的灵感，&lt;code&gt;CustomizedMenu&lt;/code&gt; 是由灵感激发得到的菜单。其中，
iterator 承担的功能和之前大相径庭：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;iterator 只能往前走。因为菜单是即兴发挥的成果，老王是没法插话问老马，上面一个是啥，什么盖浇饭？老马回答不出来，但是如果你直接告诉他“花毛一体盖浇饭”，他一定会在你的耐心消失之前把它做出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iterator 无法复制。老马的灵感稍纵即逝，无法要求他从“苏州龙虾”开始再重复一遍菜谱。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iterator 是只读的。虽然老王也充满了创造力，在相熟的菜馆他或许能破例要求把“苏州龙虾”改成
更亲民的“扬州炒饭”，但是在老马这里行不通。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;用 C&amp;#43;&amp;#43; 20 的话说，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它是一个 &lt;code&gt;std::input_iterator&lt;/code&gt;。即我们可以通过 dereference 它（即 &lt;code&gt;std::indirectly_readable&lt;/code&gt;，从 iterator 读取数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;但是它不是 &lt;code&gt;std::forward_iterator&lt;/code&gt;，因为这个 iterator 只能带我们走过一程，
之后就不能再用它了。如果老王的点菜算法需要多次遍历菜单，除非他自带速记功能，
否则的话很难在老马的面馆吃到东西了。所幸老王是个爽快人， &lt;code&gt;Wong::pick_in_menu()&lt;/code&gt;
只需要遍历一遍菜单就可以得出结果。我们把这类 iterator 称作 “single-pass” iterator。
这种算法也就是 “single-pass” algorithm 了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;问题在于，在 C&amp;#43;&amp;#43;20 之前，我们对这种 single-pass iterator 没有良好的定义，也缺乏支持。那时候的标准库过于粗线条，认为 iterator 必须支持拷贝。所以很可能 &lt;code&gt;Wong::pick_in_menu()&lt;/code&gt;
是没办法使用 &lt;code&gt;std::find_if()&lt;/code&gt; 来帮助老王选择他要的午饭的。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;p1207-和-c20&quot;&gt;P1207 和 C++20&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 C&amp;#43;&amp;#43;20 采纳的 &lt;a href=&quot;http://wg21.link/P1207R4&quot;&gt;p1207r4&lt;/a&gt; 里对 move-only iterator 做了深入的回顾，它同时主张：只支持 move 的 iterator 也能被划为
&lt;code&gt;InputIterator&lt;/code&gt;，而且它进一步指出，很多标准库里面使用 &lt;code&gt;InputIterator&lt;/code&gt; 的算法其实是 single-pass 的，它们的实现没有必要拷贝
iterator。很明显 &lt;code&gt;InputIterator&lt;/code&gt; 是 &lt;code&gt;Iterator&lt;/code&gt; 的特殊形式，它需要满足后者的所有要求。为了和 C&amp;#43;&amp;#43;20 的新式 &quot;Iterator&quot; 相区别，我们把之前的 &quot;Iterator&quot; 叫做 &quot;LegacyIterator&quot;。在 C&amp;#43;&amp;#43;20 之前，C&amp;#43;&amp;#43; 标准要求它&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CopyConstructible&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CopyAssignable&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Destructible&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;换成 C&amp;#43;&amp;#43;20 concept，就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;concept&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__LegacyIterator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;requires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__Referenceable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;  &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;same_as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__Referenceable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;copyable&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;I&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 &lt;a href=&quot;http://wg21.link/P1207R4&quot;&gt;p1207r4&lt;/a&gt;看来，&lt;code&gt;*i++&lt;/code&gt; 和 &lt;code&gt;std::copyable&amp;lt;I&amp;gt;&lt;/code&gt;
的要求就是束缚 iterator 发展的裹脚布。但是鉴于相当多的标准库实现是基于 &quot;LegacyIterator&quot; 实现的。它们的实现在不经意之间就使用了 iterator 的拷贝函数，更不用说大量的用户代码了，它们可能也自觉或者不自觉地依赖着 &quot;LegacyIterator&quot; 提供的“裹脚布”实现了自己的功能。所以为了确保新的标准库继续向后兼容， &lt;a href=&quot;http://wg21.link/P1207R4&quot;&gt;p1207r4&lt;/a&gt;
借 Ranges 的东风，仅仅要求新的 &lt;code&gt;ranges&lt;/code&gt; 库能加入对应的 concept，类型，以及相应的支持，而不会波及 &lt;code&gt;std&lt;/code&gt; 库。如果 &lt;code&gt;std&lt;/code&gt; 里面的 single-pass
函数能去掉对 InputIterator 的拷贝调用，那肯定会锦上添花……&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了让那些真正的 multi-pass 算法有章可循、有法可依，C&amp;#43;&amp;#43;20 为它们定义了 &lt;code&gt;std::forward_iterator&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-63f0c1aed729fe127bc40ae3fc570189.png&quot; alt=&quot;Diagram&quot; width=&quot;600&quot; height=&quot;588&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，&lt;code&gt;std::incrementable&lt;/code&gt; 是之前“裹脚布”的标准定义：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-3a8861dc7f7f50bc51b13ad101a791f6.png&quot; alt=&quot;Diagram&quot; width=&quot;610&quot; height=&quot;770&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有了这个标准的框架，特别是 &lt;code&gt;std::input_iterator&lt;/code&gt; 的标准化，我们就可以定义 &lt;code&gt;ranges::input_range&lt;/code&gt; 了。虽然 &lt;code&gt;ranges::input_range&lt;/code&gt;
只是个 concept。但是在它之上，我们可以定义一系列 views。它们都从底下的 &lt;code&gt;input_range&lt;/code&gt; 取出元素，加以处理和判断，然后再生成新的 range。这些 view 都使用 single-pass 算法，自然也只需要 &lt;code&gt;ranges::input_range&lt;/code&gt; 了：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::ranges::views::filter&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::ranges::views::take_while&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::ranges::views::drop_while&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::ranges::views::transform&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;std::ranges::views::elements&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以在 &lt;a href=&quot;http://wg21.link/P0902R0&quot;&gt;p0902r0&lt;/a&gt; 之后，LWG 收到了一系列提议，它们都基于 move-only iterator，着眼于改进 ranges 对它的支持。比如
&lt;a href=&quot;http://wg21.link/P1862R1&quot;&gt;p1862r1&lt;/a&gt; 和 &lt;a href=&quot;http://wg21.link/P1456R1&quot;&gt;p1456r1&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果程序员希望使用 C&amp;#43;&amp;#43;20 开发类似的范型算法，也可以使用
&lt;code&gt;ranges::input_range&lt;/code&gt; 或者更底层的 &lt;code&gt;std::input_iterator&lt;/code&gt;。这样程序一方面能兼容各种 &lt;code&gt;ranges::input_range&lt;/code&gt; 或者 &lt;code&gt;std::input_iterator&lt;/code&gt;，可扩展性和维护性自然也更好。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;刚才老王点菜的函数就可以重构一下，变成：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Wong&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Dishes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pick_in_menu&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dishes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dishes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;requires&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ranges&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;input_range&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dishes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
           &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;same_as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ranges&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;range_value_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Dishes&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ranges&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;find_if&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dishes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Dish&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;want_to_try&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dish&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ranges&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dishes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;和原来的版本相比，可能更啰嗦了一些。但是新版本更抽象，可读性更好一些，因为采用了 &lt;code&gt;ranges&lt;/code&gt; 的 concept 和函数能对参数的类型进行合法性的检测，所以如果参数类型不符合要求，也能给出更有意义的错误信息。同时，因为避免了手工编写循环，可以避免因为某些类型的 iterator 不支持 &lt;code&gt;i++&lt;/code&gt;
导致出错，提高了可维护性。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="c++" /><summary type="html">如无必要，勿增实体。</summary></entry><entry><title type="html">a bottle of ceph</title><link href="https://blog.k3fu.xyz/2022/05/04/homebrew-bottle.html" rel="alternate" type="text/html" title="a bottle of ceph" /><published>2022-05-04T00:00:00+00:00</published><updated>2022-05-04T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2022/05/04/homebrew-bottle</id><content type="html" xml:base="https://blog.k3fu.xyz/2022/05/04/homebrew-bottle.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;记录一下怎么更新 homebrew bottle。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为有些小坑，所以又是个 howto。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;把 homebrew formula 加入 homebrew。这里注明 formula 的地址，否则 brew 缺省使用 HTTPS，而 git 会问我们要 github 的 credentials。有点麻烦。&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ brew tap tchaikov/ceph-client git@github.com:tchaikov/homebrew-ceph-clientbrew.git&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新 formula&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;直接编辑，假设你的编辑器是全副武装的 IDE。&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ brew edit ceph-client&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者进入 tap 的 repo 慢慢来&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ cd $(brew --repository tchaikov/homebrew-ceph-clientbrew)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编译。这一步要下载编译时用的依赖，所以会很慢。&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ brew install --build-bottle tchaikov/ceph-clientbrew/ceph-client&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把编译好的软件包装瓶。&lt;code&gt;brew bottle&lt;/code&gt; 会在当前目录生成一个 bottle，文件名类似 &lt;code&gt;ceph-client&amp;#8212;&amp;#8203;17.2.0.arm64_monterey.bottle.2.tar.gz&lt;/code&gt;。这个命令还会很贴心地打印出使用这个 bottle 需要用到的 formula 代码片段加入，所以需要编译一下 formula。&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ brew bottle tchaikov/ceph-clientbrew/ceph-client
$ brew edit tchaikov/ceph-clientbrew/ceph-client&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;打 tag 并更新 github，以便接下来发布。&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ git remote -v
me	git@github.com:tchaikov/homebrew-ceph-client.git (fetch)
me	git@github.com:tchaikov/homebrew-ceph-client.git (push)
$ git tag quincy-17.2.0-1
$ git push me master
$ git push me quincy-17.2.0-1&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发布，并上传。&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;有意思的是，如果没有指定 &lt;code&gt;version&lt;/code&gt;，那么 &lt;code&gt;brew bottle&lt;/code&gt; 生成的文件名和 &lt;code&gt;brew install&lt;/code&gt; 期望的名字是不一致的。所以这里要修改一下：&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ mv ceph-client{-,}-17.2.0.arm64_monterey.bottle.1.tar.gz&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 GitHub 提供发布的功能，它也允许我们在发布页面上传一些文件。所以，&lt;/p&gt;
&lt;div class=&quot;olist lowerroman&quot;&gt;
&lt;ol class=&quot;lowerroman&quot; type=&quot;i&quot;&gt;
&lt;li&gt;
&lt;p&gt;在 github 上点击 &quot;tags&quot;，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击刚才创建的 tag&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &quot;Create release from tag&quot;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;点击 &quot;Attach binaries by dropping them here or selecting them&quot;，上传刚才改名后的 tar.gz 文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&quot;Publish release&quot;!&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;测试一下&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ brew remove ceph-client
$ brew install tchaikov/ceph-clientbrew/ceph-client&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
如果是新建 tap，那么应该直接参考 &lt;a href=&quot;https://brew.sh/2020/11/18/homebrew-tap-with-bottles-uploaded-to-github-releases/&quot; class=&quot;bare&quot;&gt;https://brew.sh/2020/11/18/homebrew-tap-with-bottles-uploaded-to-github-releases/&lt;/a&gt; 。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="homebrew" /><category term="ceph" /><summary type="html">记录一下怎么更新 homebrew bottle。</summary></entry><entry><title type="html">auto 和 BOOST_AUTO</title><link href="https://blog.k3fu.xyz/2022/04/16/boost-auto.html" rel="alternate" type="text/html" title="auto 和 BOOST_AUTO" /><published>2022-04-16T00:00:00+00:00</published><updated>2022-04-16T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2022/04/16/boost-auto</id><content type="html" xml:base="https://blog.k3fu.xyz/2022/04/16/boost-auto.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 也有不好用的时候。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;自从开始用上 C&amp;#43;&amp;#43;11，就喜欢上了 &lt;code&gt;auto&lt;/code&gt; 关键字。类型名字太长？用 &lt;code&gt;auto&lt;/code&gt;！类型不知道？用 &lt;code&gt;auto&lt;/code&gt;！嗯？只是有点犯懒？用 &lt;code&gt;auto&lt;/code&gt;！作为 &quot;placeholder
type specifier&quot;， &lt;code&gt;auto&lt;/code&gt; 似乎是高手的利器，懒人的福音。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;spirit-引起的-segfault&quot;&gt;spirit 引起的 segfault&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是笔者前两天碰到一个 segfault，而且不是总能重现。最后发觉它是滥用 &lt;code&gt;auto&lt;/code&gt; 的结果。比如说，下面的的代码片段用来匹配 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_prefix&quot;&gt;IEC 的前缀&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;iec_prefix_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string_view&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;constexpr&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iec_prefix_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iec_prefixes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;k&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;m&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;20&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;g&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;t&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;40&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;symbols&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;iec_prefixes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postfix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spirit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ascii&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no_case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;iB&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uint_&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;postfix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;power&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invalid_argument&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hmmm&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一切看起来岁月静好。但是却发现有时候 &lt;code&gt;qi::parse()&lt;/code&gt; 有时候会出现 segfault。表达式这么可爱，能出什么错呢？stackoverflow 上有个很对口的 &lt;a href=&quot;https://stackoverflow.com/questions/20763665/boost-spirit-v2-qi-bug-associated-with-optimization-level/20766909#20766909&quot;&gt;问题&lt;/a&gt;，摘录回答如下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It&amp;#8217;s a bug in your code, nothing wrong with the compiler or the optimization levels.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The cinch is with expression templates (like the ones used by Boost Proto, and hence by Boost Spirit).
They are &lt;strong&gt;only valid to the end of their enclosing full expression&lt;/strong&gt;&lt;sup&gt;[1]&lt;/sup&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The canonical workaound is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt; &lt;span class=&quot;n&quot;&gt;BOOST_SPIRIT_AUTO&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ana&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'*'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;char_&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;sc&quot;&gt;'*'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Spirit X3 promises to remove this wart. Slightly related, I think Protox11 also removes this
issue by being aware of references at all times.&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;[1] Grep the standard for lifetime extension of temporaries. The expression templates keep
references to the literals used (the rest has value semantics anyways), but the temporaries
aren&amp;#8217;t bound to (const) references. So they go out of scope.
&lt;a href=&quot;http://en.wikipedia.org/wiki/Undefined_behavior&quot;&gt;Undefined Behaviour&lt;/a&gt; results&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看来是 &lt;code&gt;postfix&lt;/code&gt; 指向的对象含有一些引用，被引用的对象的生命周期没能坚持很久，它们到 &lt;code&gt;qi::parse()&lt;/code&gt;
的时候已经香消玉损了。这里涉及两组熟悉又陌生的概念：&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;expression-template&quot;&gt;expression template&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先看看表达式模板（expression template）是什么。它是 C&amp;#43;&amp;#43; 魔法师们的创造，不属于 C&amp;#43;&amp;#43; 标准的范畴，见 &lt;a href=&quot;https://en.wikipedia.org/wiki/Expression_templates&quot;&gt;wikipedia 上的条目&lt;/a&gt;。总结下来，表达式模板有这么几个特点：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;往往使用嵌套模板的方式组织成一个树。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表达式通过 &lt;code&gt;const&lt;/code&gt; 引用保存子表达式。为了避免复制产生的开销，更不消说有的类型不支持复制，仅仅保存引用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;惰性求值。只有表达式参与真正的求值的时候，才会开始计算。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因此，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;postfix&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spirit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ascii&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;no_case&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;iB&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;qi&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;并不是普通的值语义的标量对象，它是一个嵌套的表达式模板实例。如下所示：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-55cacf693e6cfc618d2741427a20859a.png&quot; alt=&quot;Diagram&quot; width=&quot;510&quot; height=&quot;546&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每个操作符分别都产生了新的表达式，而这些表达式都通过 &lt;code&gt;const&lt;/code&gt; 引用持有保存其子表达式的引用，从里到外的每个表达式都是临时对象。即使我们通过 &lt;code&gt;postfix&lt;/code&gt; 保存了最外面的表达式，即图中的绿色方块。但是里面的所有其他表达式都在 &lt;code&gt;auto postfix&lt;/code&gt; 这个语句中等号右侧的表达式求值完毕之后就析构了。更不用说 &lt;code&gt;qi::string(&quot;iB&quot;)&lt;/code&gt; 它们了。难怪，在 &lt;code&gt;qi::parse()&lt;/code&gt; 使用 &lt;code&gt;postfix&lt;/code&gt; 的时候会碰到 segfault。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;临时对象和引用&quot;&gt;临时对象和引用&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那我们看看 C&amp;#43;&amp;#43; 标准（草案）的原文怎么说&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The lifetime of a reference begins when its initialization is complete. The lifetime of a
reference ends as if it were a scalar object requiring storage.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;attribution&quot;&gt;
&amp;#8212; ISO/IEC JTC1 SC22 WG21 N 4860
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;关键是后面一句。简单说，就是引用还在，因为它只是块儿内存，只要那块内存还没有重写，引用就活着。不过……
引用毕竟是引用，它和值是两码事。因此，会不会代码犯了和下面程序类似的错误？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;cp&quot;&gt;#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;iostream&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
#include&lt;/span&gt; &lt;span class=&quot;cpf&quot;&gt;&amp;lt;string&amp;gt;&lt;/span&gt;&lt;span class=&quot;cp&quot;&gt;
&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;GCC 碰到这种明显的错误会看不下去，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;test.cc: In function ‘std::string&amp;amp; hello()’:
test.cc:9:10: warning: reference to local variable ‘s’ returned [-Wreturn-local-addr]
    9 |   return s;
      |          ^
test.cc:8:10: note: declared here
    8 |   string s(&quot;hello&quot;);
      |          ^&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当然，有的情况下，引用可以 &lt;a href=&quot;https://en.cppreference.com/w/cpp/language/reference_initialization#Lifetime_of_a_temporary&quot;&gt;帮助临时对象续命&lt;/a&gt;。但是如果不属于上面的情况，要是被引用的对象析构了，那么就算引用还是有效的，我们一样会碰到我们的老朋友——
undefined behavior。这也是这个问题在不同环境下可能没法重现的原因。因为对象即使析构，它的内存在被重写之前，数据还是保存着它生前的样子。而内存重用是我们通常没法直接控制的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以问题的原委已经明白了。上图中绿色方块的 &lt;code&gt;lhs&lt;/code&gt; 和 &lt;code&gt;rhs&lt;/code&gt; 作为引用，在对 &lt;code&gt;postfix&lt;/code&gt;
赋值之后仍然是有效的，但是它们指向的对象就销毁了。为了能够把整个表达式树完整地保存下来，我们必须进行一次 &lt;code&gt;deep copy&lt;/code&gt;。Spirit 的维护者 &lt;a href=&quot;http://boost-spirit.com/home/articles/qi-example/zero-to-60-mph-in-2-seconds/&quot;&gt;实现的 &lt;code&gt;BOOST_SPIRIT_AUTO&lt;/code&gt; 宏&lt;/a&gt;
解决的就是这个问题。也许根据 &lt;a href=&quot;https://www.boost.org/doc/libs/1_79_0/libs/spirit/example/qi/typeof.cpp&quot;&gt;最新的例子&lt;/a&gt;，我们最好用 &lt;code&gt;boost::spirit::qi::copy()&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author></entry><entry><title type="html">redpanda 编译记录</title><link href="https://blog.k3fu.xyz/2022/04/11/redpanda-build.html" rel="alternate" type="text/html" title="redpanda 编译记录" /><published>2022-04-11T00:00:00+00:00</published><updated>2022-04-11T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2022/04/11/redpanda-build</id><content type="html" xml:base="https://blog.k3fu.xyz/2022/04/11/redpanda-build.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在恶劣的网络环境下编译 redpanda 也得折腾。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看到 redpanda 也开始用 C&amp;#43;&amp;#43;20 的协程，这引起了我的好奇心。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;bleeding-edge&quot;&gt;bleeding edge&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;git clone git@github.com:redpanda-data/redpanda.git&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;redpanda 的 &lt;a href=&quot;https://github.com/redpanda-data/redpanda#build-manually&quot;&gt;github 页面&lt;/a&gt;
上有介绍，但是既然都 &quot;live on edge&quot; 了，那么就必须用最新的 clang 啊。debian sid
打包了 clang-15，所以需要用下面的 patch：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;diff&quot;&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/install-dependencies.sh b/install-dependencies.sh
index c6370e4d3..ad328d1f9 100755
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/install-dependencies.sh
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/install-dependencies.sh
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -26,14 +26,14 @@&lt;/span&gt; fi

 deb_deps=(
   ccache
&lt;span class=&quot;gd&quot;&gt;-  clang
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  clang-15
&lt;/span&gt;   curl
   git
   libsnappy-dev
   libxxhash-dev
   libzstd-dev
&lt;span class=&quot;gd&quot;&gt;-  llvm
-  lld
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  llvm-15
+  lld-15
&lt;/span&gt;   pkg-config
   procps
   python3-jinja2&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;github&quot;&gt;GitHub&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了更快地下载 github 上的 repo，如果能找到可以用的 GitHub 镜像的话，就可以修改 &lt;code&gt;$HOME/.gitconfig&lt;/code&gt;，让 &lt;code&gt;git&lt;/code&gt; 重写 URL 里面的路径，用镜像替代 github。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;ini&quot;&gt;&lt;span class=&quot;nn&quot;&gt;[url &quot;https://a.mirror.or.proxy/&quot;]&lt;/span&gt;
  &lt;span class=&quot;py&quot;&gt;insteadOf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;https://github.com/&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果没有镜像可用，那么用自己架设的 SOCKS5 和 HTTP 代理也能抵挡一下，各家工具支持的代理设置方式不同。archlinux 甚至有 &lt;a href=&quot;https://wiki.archlinux.org/title/Proxy_server&quot;&gt;专门的文档&lt;/a&gt; 说明如何设置代理。这里只记录用到的：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;c&quot;&gt;# for curl and python (urllib3)&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;all_proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;socks5://127.0.0.1:1080
&lt;span class=&quot;c&quot;&gt;# for cipd which respects http_proxy and https_proxy&lt;/span&gt;
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;http_proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://127.0.0.1:1081
&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;https_proxy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;http://127.0.0.1:1081&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;v8&quot;&gt;V8&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 redpanda 使用 Chrome/ 的 V8 引擎来 &lt;a href=&quot;https://redpanda.com/blog/wasm-architecture/&quot;&gt;执行 WASM&lt;/a&gt;，这个依赖为墙内的开发者带来了更大的挑战。因为 www.chromium.org 也被官方认证了。而作为一个大型项目，
Chrome 使用 &lt;a href=&quot;https://www.chromium.org/developers/how-tos/install-depot-tools/&quot;&gt;depot-tools&lt;/a&gt;
来辅助其代码 checkout 流程。笔者租有一个墙外的 VPS，用它来下载必须的依赖。下面的命令是在 VPS 上执行的：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ DEPOT_TOOLS_DIR=/var/depot_tools
$ sudo DEPOT_TOOLS_DIR=${DEPOT_TOOLS_DIR} ./install-dependencies.sh&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;执行完之后，&lt;code&gt;/var/depot_tools&lt;/code&gt; 的大小大约为 734M。原样复制到本地。VPS
上的目录和本地应该可以不一样，设置好之后命令中的 &lt;code&gt;DEPOT_TOOLS_DIR&lt;/code&gt; 环境变量就行。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;没有-rtti-的-snappy&quot;&gt;没有 RTTI 的 snappy&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为新版 snappy 关掉了 RTTI，导致很多使用它的应用都出现了链接失败的问题。虽然有 &lt;a href=&quot;https://github.com/google/snappy/pull/129&quot;&gt;snappy 的 PR&lt;/a&gt;，无奈谷歌的工程师只希望对 Google Chrome 的编译负责。所以我们需要把 &lt;code&gt;CMakeLists.txt&lt;/code&gt; 里面关于 RTTI 的代码注释掉，再重新编译安装 snappy。否则会出现下面的链接错误：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;lib/libv_v_compression.a(snappy_standard_compressor.cc.o):(.data.rel.ro._ZTIN11compression17snappy_iobuf_sinkE[_ZTIN11compression17snappy_iobuf_sinkE]+0x10): undefined reference to `typeinfo for snappy::Sink'
/usr/bin/ld: lib/libv_v_compression.a(snappy_standard_compressor.cc.o):(.data.rel.ro._ZTIN11compression19snappy_iobuf_sourceE[_ZTIN11compression19snappy_iobuf_sourceE]+0x10): undefined reference to `typeinfo for snappy::Source'&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;编译&quot;&gt;编译&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在编译的时候， 需要下载 v8 的代码，不知道为何 &lt;code&gt;gclient&lt;/code&gt; 会 hang，长时间没有动静。只能直接调用 &lt;code&gt;gclient.py&lt;/code&gt;。同时，把原来的 git 地址改成 gitee 上的镜像，在国内访问它的速度很快。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;diff&quot;&gt;&lt;span class=&quot;gh&quot;&gt;diff --git a/cmake/oss.cmake.in b/cmake/oss.cmake.in
index 53856c61d..f8f6b7998 100644
&lt;/span&gt;&lt;span class=&quot;gd&quot;&gt;--- a/cmake/oss.cmake.in
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+++ b/cmake/oss.cmake.in
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;@@ -351,8 +351,8 @@&lt;/span&gt; set(v8_flags
 ExternalProject_Add(v8
 INSTALL_DIR @REDPANDA_DEPS_INSTALL_DIR@
 DOWNLOAD_COMMAND
&lt;span class=&quot;gd&quot;&gt;-  COMMAND @DEPOT_TOOLS_DIR@/gclient configure https://github.com/v8/v8.git
-  COMMAND @DEPOT_TOOLS_DIR@/gclient sync -r e04bb9be8542b166c4dda1a77bfb1c46552afdd8
&lt;/span&gt;&lt;span class=&quot;gi&quot;&gt;+  COMMAND python3 @DEPOT_TOOLS_DIR@/gclient.py configure https://gitee.com/mirrors/V8.git
+  COMMAND python3 @DEPOT_TOOLS_DIR@/gclient.py sync -v -r e04bb9be8542b166c4dda1a77bfb1c46552afdd8
&lt;/span&gt; PATCH_COMMAND &quot;&quot;
 CONFIGURE_COMMAND
   COMMAND cd &amp;lt;SOURCE_DIR&amp;gt; # Is used for run gn inside v8 dir&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后，因为如果混用新版 clang 和老版本的 GNU ld，可能会出现链接出错的情况。这时候用新版的 binutils 提供的 ld，或者干脆用 &lt;a href=&quot;https://lld.llvm.org&quot;&gt;llvm 的 LLD&lt;/a&gt;：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;$ cd redpanda
$ CC=clang-15 CXX=clang++-15 DEPOT_TOOLS_DIR=/var/depot_tools \
    -DCMAKE_BUILD_TYPE=Debug \
    -DCMAKE_EXE_LINKER_FLAGS=-fuse-ld=lld&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 gitee 把 repo 的名字改成了大写。编译 v8 的时候会找不到代码。所以得纠正这个错误：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shell&quot;&gt;&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;mv &lt;/span&gt;redpanda/build/deps_build/v8-prefix/src/&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;V8,v8&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="redpanda" /><category term="build" /><category term="debian" /><summary type="html">在恶劣的网络环境下编译 redpanda 也得折腾。</summary></entry><entry><title type="html">Seastar 和 SPDK</title><link href="https://blog.k3fu.xyz/2021/08/28/spdk-seastar.html" rel="alternate" type="text/html" title="Seastar 和 SPDK" /><published>2021-08-28T00:00:00+00:00</published><updated>2021-08-28T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2021/08/28/spdk-seastar</id><content type="html" xml:base="https://blog.k3fu.xyz/2021/08/28/spdk-seastar.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当 C++ 遇上 SPDK。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot; class=&quot;title&quot;&gt;&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#seasetar-中的-dpdk&quot;&gt;Seasetar 中的 DPDK&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#spdk&quot;&gt;SPDK&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#初始化&quot;&gt;初始化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#reactor_run&quot;&gt;reactor_run&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#seastar-框架下-spdk-的线程&quot;&gt;Seastar 框架下 SPDK 的线程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#spdk-的-then&quot;&gt;SPDK 的 &lt;code&gt;then()&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#spdk-在-seastar-中的形态&quot;&gt;SPDK 在 Seastar 中的形态&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#另外一个-reactor&quot;&gt;另外一个 reactor？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#典型的用例&quot;&gt;典型的用例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这两天在学习 SPDK。对于存储软件的开发者来说，它是很好的基础设施。但是这种把回调函数和 context
作为参数，传给异步调用的模式让我有一朝返回解放前的感觉。联想到 Rust 和 Python 语言中的 async/await
语法，再加上两年 seastar 的开发者加入的
&lt;a href=&quot;https://github.com/scylladb/seastar/commit/de56cd1dfe8eab6a2718d62b950c912574c4b27d&quot;&gt;coroutine 支持&lt;/a&gt;，作为 C&amp;#43;&amp;#43; 程序员不得不重新审视一下，我们是不是也能用新的语法，把异步的 SPDK C&amp;#43;&amp;#43; 程序写得更赏心悦目，易于维护呢？Seastar 作为 C&amp;#43;&amp;#43; 异步编程框架中不可忽视的一员，同时提供了 future/promise 和
C++20 的异步编程模型，如果加上 SPDK 肯定会如虎添翼，成为一个更好的平台。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;seasetar-中的-dpdk&quot;&gt;Seasetar 中的 DPDK&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先看看 Seastar 是怎么集成 DPDK 的吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 &lt;code&gt;smp::get_options_description()&lt;/code&gt; 里面，为 DPDK 的 &lt;code&gt;--huge-dir&lt;/code&gt; 注册了 &quot;hugepages&quot; 的命令行选项。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 &lt;code&gt;smp::configure()&lt;/code&gt; 里面，CPU 核的设置 &lt;code&gt;allocation&lt;/code&gt; 经过几次转换，还是作为命令行，传给了 &lt;code&gt;rte_eal_init()&lt;/code&gt;:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dpdk::eal::init()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rte_eal_init()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在每个 RTE 核上运行之前交给 &lt;code&gt;create_thread()&lt;/code&gt; 的 lambda。这个 lambda 暂且叫做
&lt;code&gt;reactor_run&lt;/code&gt; 吧。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，&lt;code&gt;reactor_run&lt;/code&gt; 负责初始化 reactor 线程，和执行调度到的任务：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;设置线程名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分配自己的 hugepage&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分配 io queue&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 smp message queue&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reactor::do_run()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;注册所有的 poller。请注意，poller 在各自的构造函数里面，新建一个 task。它们用 task
来把自己加到 &lt;code&gt;reactor._pollers&lt;/code&gt; 里面去。poller 可以用来定期等待消息，并处理消息。比如：&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;smp_poller&lt;/code&gt; 用来接收其他 reactor 发来的消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;aio 或者 epoll 等到的消息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reactor::signals&lt;/code&gt; 检查 POSIX signal，并调用 signal handler&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低精度的 timer&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;成批执行 task。Seastar 允许开发者把一组任务 &lt;a href=&quot;http://docs.seastar.io/master/group__execution-stages.html&quot;&gt;一起执行&lt;/a&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;轮询所有的 poller&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据是否有遗存的工作决定是否进入休眠模式&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;spdk&quot;&gt;SPDK&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;初始化&quot;&gt;初始化&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里通过分析 SPDK 的初始化过程，关注它的设置，以及调度方式，希望更好地设计 Seastar
和 SPDK 沟通的方式，比如如何初始化，如何和 SPDK 传递消息。SPDK 关心的设置是 DPDK &lt;code&gt;rte_eal_init()&lt;/code&gt;
的超集，除了 DPDK 的相关设置，它还有很多 SPDK 特有的设置 &lt;code&gt;spdk_env_opts&lt;/code&gt; ，比如&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;no_pci&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;num_pci_addr&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每个 SPDK app 都需要执行 &lt;code&gt;spdk_app_start()&lt;/code&gt;：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;app_setup_env(spdk_app_opts)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk_env_init(spdk_env_opts)&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;olist lowerroman&quot;&gt;
&lt;ol class=&quot;lowerroman&quot; type=&quot;i&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;rte_eal_init(argc, argv)&lt;/code&gt;: 参数是根据 &lt;code&gt;spdk_env_opts&lt;/code&gt; 构造的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PCI 相关的初始化&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk_reactors_init()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk_mempool_create()&lt;/code&gt;: 分配内存池&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为每个核初始化 reactor，设置下面的设施&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;event ring buffer&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;event fd&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;新建一个 &lt;code&gt;app_thread&lt;/code&gt;，并把 &lt;code&gt;bootstrap_fn&lt;/code&gt; 调度到该 thread 上执行&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bootstrap_fn()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;olist lowerroman&quot;&gt;
&lt;ol class=&quot;lowerroman&quot; type=&quot;i&quot;&gt;
&lt;li&gt;
&lt;p&gt;解析给出的 json 文件，里面包含一系列子系统的配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化 RPC 服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接 RPC 服务，挨个加载子系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk_reactors_start()&lt;/code&gt;: 在每个 reactor 上执行 &lt;code&gt;reactor_run&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;reactor_run&quot;&gt;reactor_run&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 &lt;code&gt;reactor_run&lt;/code&gt; 中：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;批量地处理 &lt;code&gt;reactor&amp;#8594;events&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用所有 spdk_thread 的 poller&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;批量处理 &lt;code&gt;thread&amp;#8594;messages&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依次调用 &lt;code&gt;thread&amp;#8594;active_pollers&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依次调用 &lt;code&gt;thread&amp;#8594;timed_pollers&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;请注意，spdk 会利用 poller 实现定时器和定期执行执行操作的功能。后者把 reactor 作为
worker thread，执行非阻塞的常规任务。比如 &lt;code&gt;vdev_worker&lt;/code&gt; 和 &lt;code&gt;vdev_mgmt_worker&lt;/code&gt;。这个用法和 Seastar 的 &lt;code&gt;reactor::io_queue_submission_pollfn&lt;/code&gt; 相似。但是 Seastar
目前没有把注册 poller 的功能作为公开的 API 提供出来。如果把这个 poll 的任务定义成
task，在退出之前再次调度它自己，那么这种实现可能会降低 Seastar 任务调度的性能。因为在这个 poller 注销之前，它重复地新建和销毁任务，并把任务加入和移出 reactor 的任务列表。这会浪费很多 CPU cycle。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;seastar-框架下-spdk-的线程&quot;&gt;Seastar 框架下 SPDK 的线程&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里结合 Seastar 框架，通过对比两者的线程模型。进一步探索一些可能的实现方式，我们可能会需要回答下面的问题，然后分别解决。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何管理多个用户层面的任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何发起一个异步调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何知道一个异步调用完成了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何传递消息&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不同 core 是直接如何通信的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同任务之间是直接如何通信的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每个 core 都有自己的 MPSC (multiple producer single consumer) 消息队列，用于接收发给自己的消息。和 Seastar smp 调用对应的逻辑对应着看，可以发现&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk_event_call()&lt;/code&gt; 等价于 &lt;code&gt;seastar::smp::submit_to()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;event_queue_run_batch()&lt;/code&gt; 等价于 &lt;code&gt;smp::poll_queues()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面解释 &lt;code&gt;reactor_run&lt;/code&gt; 的逻辑的时候提到一个概念叫做 &lt;code&gt;spdk_thread&lt;/code&gt;。它是 SPDK 中的用户线程。不同的 &lt;code&gt;spdk_thread&lt;/code&gt; 之间通过接受方线程的消息队列来互相通信。用户线程消息队列的类型和 core 的消息队列类型和大小相同。&lt;code&gt;spdk_thread_send_msg()&lt;/code&gt; 是用来往特定线程发送消息的。值得注意的是，SPDK 内部很多地方都使用了 &lt;code&gt;spdk_thread&lt;/code&gt;，比如
bdev 模块就把 &lt;code&gt;spdk_bdev_io&lt;/code&gt; 和一个 &lt;code&gt;spdk_thread&lt;/code&gt; 相对应，实现 IO 的序列化。所以我们如果要让 Seastar 能更好的支持 SPDK 的话，就必须实现这个机制。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于 SPDK 来说，&lt;code&gt;spdk_thread&lt;/code&gt; 是一个工作协程，用来承载不同的业务。很多时候被用来并序列化并执行各种操作，它属于一个特定的 core。不过它可以根据调度算法动态地迁移到另一个
core。作为运行在所有 core 上的调度器，这个服务可以在 &lt;code&gt;seastar::sharded&amp;lt;&amp;gt;&lt;/code&gt;
的框架下实现。不过这个调度器和 Seastar 的原生调度算法还有一些区别:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;seastar::sharded&amp;lt;&amp;gt;&lt;/code&gt; 既可以在单个 core 上启动，也可以同时在所有 core 上一起
启动。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk_thread&lt;/code&gt; 可以根据调度算法动态迁移。&lt;code&gt;spdk_thread&lt;/code&gt; 一般来说属于 &lt;strong&gt;一个&lt;/strong&gt;
core 的，但是根据它的 &lt;code&gt;cpumask&lt;/code&gt;，一个 &lt;code&gt;spdk_thread&lt;/code&gt; &lt;strong&gt;可以&lt;/strong&gt; 根据 CPU 的负载
迁移到 &lt;code&gt;cpumask&lt;/code&gt; 包含的的任意一个 core。这一点 Seastar 尚无支持。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 &lt;code&gt;spdk_thread&lt;/code&gt; 自己有消息队列、poller 等基础设施，我们可以把它视为一个逻辑的
reactor。这个特性在 Seastar 目前还没有与之对应的实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个 core 都维护着一组 &lt;code&gt;spdk_thread&lt;/code&gt;。SPDK 甚至用 thread local storage 跟踪
其中一个。这个很像进程中的一组线程。&lt;code&gt;spdk_get_thread()&lt;/code&gt; 返回的就是被跟踪的
那个 &lt;code&gt;spdk_thread&lt;/code&gt;。目前 Seastar 的 reactor 并没有对应的概念，但是我们可以用
一个 &lt;code&gt;seastar::sharded&amp;lt;&amp;gt;&lt;/code&gt; 服务来保存对应 core 上的所有 &lt;code&gt;spdk_thread&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;允许动态地注册和注销 poller。SPDK 中有两种 poller。一种是系统级的，负责
保证 SPDK 事件系统和 reactor 的基本运作。另一种是用户级的，它允许实现具体功能
的模块自己定期轮询业务相关的事件。这些用户级的 poller 就是注册在前面提到的
&lt;code&gt;spdk_get_thread()&lt;/code&gt; 返回的线程中的。参见 &lt;code&gt;spdk_poller_register()&lt;/code&gt; 和
&lt;code&gt;spdk_poller_unregister()&lt;/code&gt; 的实现。如果继续沿着刚才的思路往前，我们可以把
一组 &lt;code&gt;spdk_thread&lt;/code&gt; 保存在，比如说，&lt;code&gt;seastar::sharded&amp;lt;spdk::ThreadGroup&amp;gt;&lt;/code&gt; 里面，
让 &lt;code&gt;spdk::ThreadGroup&lt;/code&gt; 来为它管理的 &lt;code&gt;spdk_thread&lt;/code&gt; 服务。它会用
&lt;code&gt;reactor::poller::simple()&lt;/code&gt; 来注册自己的 &lt;code&gt;do_complete()&lt;/code&gt; 函数，后者遍历
所有的 &lt;code&gt;spdk_thread&lt;/code&gt; 的 poller。也允许应用程序在任意时刻为指定的 &lt;code&gt;spdk_thread&lt;/code&gt;
添加 poller。这个做法和 virtio 中 &lt;code&gt;vring&amp;lt;&amp;gt;&lt;/code&gt; 的实现相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同时支持中断模式和轮询模式。这是 SPDK 最近加入的一个新特性，甚至允许应用的 poller
工作在可定制的中断模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;节能、提高 CPU 的使用率和负载均衡，这些作为一个总体的设计目标，SPDK 做得相对比较深入。它根据线程的统计数据，比如说闲忙的时间比 (&lt;code&gt;spdk_thread_stats&lt;/code&gt;)，来决定如何调度，Seastar 仅在 reactor 的实现里面通过调用 &lt;code&gt;pure_check_for_work()&lt;/code&gt;
来判断 CPU 当下是否有工作要做，如果没有的话，就进入浅层的睡眠模式。笔者认为，这也许不仅仅是工程量多少的问题。也可能是因为 Seastar 对自身的定位，它提供了基础的异步编程模型，异步调用，以及基本的 IO 调度，但是它并不希望干涉用户业务在不同
shard 上的分布，而是把这个问题留给应用的开发者。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;要在 Seastar 的框架下实现 &lt;code&gt;spdk_thread&lt;/code&gt; 的这些高级特性是完全有可能的：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;根据负载动态调度工作协程：不仅仅 &lt;code&gt;spdk_thread&lt;/code&gt; 需要统计自己的关于调度的统计
信息，每个 &lt;code&gt;spdk::ThreadGroup&lt;/code&gt; 也需要统计各自的 &lt;code&gt;idle_tsc&lt;/code&gt; 和 &lt;code&gt;busy_tsc&lt;/code&gt;。
并提供接口供调度器查询，作为负载均衡的依据，然后在 shard 间调度任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和 SPDK 的 reactor 类似，&lt;code&gt;spdk::ThreadGroup&lt;/code&gt; 也要保存一个 &quot;leader&quot; thread，
后者负责常规的 poller 注册和注销工作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk::ThreadGroup&lt;/code&gt; 启动的时候需要向 reactor 注册自己的总 poller，负责调用非
定时的 poller。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在新注册 poller 的时候，需要按照 poller 是否有周期区别处理。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 poller 指定了周期，那么需要新建 &lt;code&gt;seastar::timer&lt;/code&gt;，并在 &lt;code&gt;spdk::ThreadGroup&lt;/code&gt;
中维护一个 map，方便在运行的时候根据 &lt;code&gt;spdk_poller*&lt;/code&gt; 找到 &lt;code&gt;seastar::timer&lt;/code&gt; 暂停
或者注销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是没有周期的 poller，那么直接加入当前 &lt;code&gt;spdk::ThreadGroup&lt;/code&gt; 的 leader thread。
让后者的 poller 来调用新注册的 poller。这种分层的设计也方便管理对象的生命周期和统计
运行时指标。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 SPDK 里面，要发起一个异步调用最典型的方式，类似下面的代码:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;hello_context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev_desc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;hello_context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev_io_channel&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;hello_context&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                     &lt;span class=&quot;n&quot;&gt;write_complete&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这段代码摘自 &lt;code&gt;examples/bdev/hello_world/hello_bdev.c&lt;/code&gt;。这里以 bdev 的 NVMe 后端为例：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;从 &lt;code&gt;hello_context&amp;#8594;bdev_io_channel&lt;/code&gt; 的 cache 或者 bdev 的内存池分配一个
&lt;code&gt;spdk_bdev_io&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用给定的参数设置这个 &lt;code&gt;spdk_bdev_io&lt;/code&gt;，这样这个 I/O 就知道需要写的数据位置，长度，甚至
回调函数的函数指针和参数也保存在这个 I/O 里面了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;往 &lt;code&gt;nvme_qpair&lt;/code&gt; 的提交列表的末尾添加新的 I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过修改提交队列末尾的 door bell，告诉 &lt;code&gt;nvme_qpair&lt;/code&gt;，提交列表里多了一个新的 I/O。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么我们怎么知道 NVMe 设备完成了这个写操作呢？下面的函数处理指定的 queue pair
上所有完成了的 I/O 请求。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int32_t&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spdk_nvme_qpair_process_completions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_nvme_qpair&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;qpair&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                            &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;max_completions&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个做法很像 &lt;a href=&quot;https://man7.org/linux/man-pages/man2/io_getevents.2.html&quot;&gt;io_getevents()&lt;/a&gt;，都是从完成列表收割完成了的 I/O 请求。这个过程很像播种和收割。提交请求就是播种，检查完成了的请求就像是收割。让作物成熟的魔法师就是轮询模式的驱动 (polling mode driver)。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;既然 SPDK 用 &lt;code&gt;spdk_thread&lt;/code&gt; 实现用户协程，那么协程之间要协作的话，该怎么做呢？就是前面提到的&quot;发送消息&quot;。消息保存在大小为 65535 的一个 ring buffer 里面。顺便提一下，其实 Seastar 也有类似的数据结构，称为 &lt;code&gt;seastar::circular_buffer_fixed_capacity&lt;/code&gt;。如果有必要的话，我们甚至可以把 SPDK 的 event 和 thread 子系统完全换成 Seastar 的实现。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;spdk-的-then&quot;&gt;SPDK 的 &lt;code&gt;then()&lt;/code&gt;&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;回调函数是 C 语言实现异步编程一个很简单直接的方式，但是它似乎和 Seastar 的 &lt;code&gt;future&amp;lt;&amp;gt;&lt;/code&gt;
格格不入。SPDK 和 DPDK 一脉相承，有着深层的血缘关系，我们是不是可以照着
&lt;code&gt;seastar::net::qp&amp;lt;&amp;gt;&lt;/code&gt; 实现 SPDK 支持呢？看上去这种基于成对的
submission 和 completion queue 的抽象也适用于很多 SPDK 的场景。先比较一下基于流的操作和基于块的操作有什么异同：&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3333%;&quot;&gt;
&lt;col style=&quot;width: 33.3334%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;bdev&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;net::qp&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;发送&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;读写指令&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;发给对方的包&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;接收&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;设备状态&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;对方发来的包&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;等待&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;特定写指令的完成&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;发送的进度&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;等待&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;特定读指令返回的数据&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;下一个接收的报文&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 bdev 需要跟踪特定请求的状态而不是一个 &lt;strong&gt;进度&lt;/strong&gt;，所以我们无法使用 &lt;code&gt;seastar::stream&lt;/code&gt;
定义 bdev 的读写接口。更好的榜样应该是 &lt;code&gt;seastar::file&lt;/code&gt;。每个 &lt;code&gt;posix_file_impl&lt;/code&gt;
都有一个 &lt;code&gt;_io_queue&lt;/code&gt; 的引用，同一 &lt;code&gt;devid&lt;/code&gt; 的所有 &lt;code&gt;_io_queue&lt;/code&gt; 指向 reactor
统一维护的同一个 queue。这些 queue 用 &lt;code&gt;devid&lt;/code&gt; 来索引。SPDK 作为专业的底层设施自然也有对应的设计。需要理解的是 &lt;code&gt;io_sink&lt;/code&gt;、&lt;code&gt;io_request&lt;/code&gt; 和 &lt;code&gt;io_completion&lt;/code&gt; 这些组件是如何互相协作的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;还有个问题，SPDK 是一个有丰富接口的工具集，它有多个模块。每个模块都有自己的一组回调函数。光 &lt;code&gt;bdev&lt;/code&gt; 就有 11 种回调函数：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_remove_cb_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;remove_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_event_cb_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;enum&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev_event_type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                     &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                     &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event_ctx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_io_completion_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev_io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev_io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                           &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                           &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_wait_for_examine_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_init_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_fini_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_get_device_stat_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev_io_stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_io_timeout_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev_io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev_io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_io_wait_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_histogram_status_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_histogram_data_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;status&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                            &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_histogram_data&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;histogram&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过其中常用的可能只有:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c&quot;&gt;&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_io_completion_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev_io&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev_io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                           &lt;span class=&quot;n&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;success&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                           &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spdk_bdev_get_device_stat_cb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_bdev_io_stat&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cb_arg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前者用来处理一个完成了的 I/O，后者用来获取块设备的统计信息。回到刚才提到的 &lt;code&gt;spdk_bdev_write()&lt;/code&gt;。对应的 Seastar 风格的一个 &lt;code&gt;bdev&lt;/code&gt; 定义可能像这样:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;bdev&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;explicit&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;~&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pos&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buffer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;len&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;stat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个接口和 &lt;code&gt;seastar::file&lt;/code&gt; 对应，忽略了 io channel 这些 SPDK 独有的机制。问题是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是否需要使用 SPDK 的回调函数实现异步调用呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是的话，如何实现？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是的话，又怎么处理？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于第一个问题，笔者认为，如果没有必要，还是应当尽量使用 SPDK 的方法，而不是自己开发一套机制替代它，这样的好处显而易见：因为 SPDK 的公开方法相对稳定，这样能减少跟踪上游带来的维护成本，把对 SPDK 的改动减少到最小，同时也增加了这个改动进入 SPDK 和 Seastar 上游的机会。但是新的问题出现了：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这个回调函数是什么？&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;我们可以把回调函数定义成为一个 &lt;code&gt;bdev&lt;/code&gt; 的静态成员函数，便于访问它的私有成员。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回调函数应该能调用 &lt;code&gt;_pr.set_value(res)&lt;/code&gt;。其中，&lt;code&gt;_pr&lt;/code&gt; 是和返回的 &lt;code&gt;future&amp;lt;&amp;gt;&lt;/code&gt; 对应的 &lt;code&gt;promise&amp;lt;&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;回调函数的参数呢？这个参数至少要让我们能定位到 &lt;code&gt;_pr&lt;/code&gt;。在 AIO 后端的实现里面，
当它在 poller 里面收集到完成了的事件之后，依次调用事件对应的 &lt;code&gt;completion&amp;#8594;complete_with()&lt;/code&gt;
函数。下面是从 Seastar 摘录的相关代码：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;io_pgetevents&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_polling_io&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;io_context&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_sigmask&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unsigned&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;event&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;batch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;reinterpret_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kernel_completion&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;uintptr_t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;complete_with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;event&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 &lt;code&gt;io_completion&lt;/code&gt; 则会调用 &lt;code&gt;io_completion::complete(res)&lt;/code&gt;。后者由 &lt;code&gt;io_completion&lt;/code&gt; 的子类各自实现。以 &lt;code&gt;io_desc_read_write&lt;/code&gt; 为例，它从 &lt;code&gt;io_completion&lt;/code&gt; 继承，并负责与 fair_queue 沟通，也保存了 &lt;code&gt;_pr&lt;/code&gt;。在 &lt;code&gt;io_desc_read_write::complete()&lt;/code&gt; 里，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;_pr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;res&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;delete&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果不使用回调函数的话，我们其实也需要模仿现有 Seastar 中对 aio 的支持，自己实现一个基于队列的轮询机制。我们以写文件为例，看看 Seastar 的 AIO 后端的实现吧。在
&lt;code&gt;posix_file_impl::do_write_dma()&lt;/code&gt; 中，它调用 &lt;code&gt;engine().submit_to_write()&lt;/code&gt;：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;io_queue::queue_request()&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;构造一个 &lt;code&gt;unique_ptr&amp;lt;queued_io_request&amp;gt;&lt;/code&gt; 对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 &lt;code&gt;queued_io_request::_fq_entry&lt;/code&gt; 加入 &lt;code&gt;io_queue::fair_queue&lt;/code&gt; 队列。通过这个 &lt;code&gt;_fq_entry&lt;/code&gt; 是可以找到包含它的 &lt;code&gt;queued_io_request&lt;/code&gt; 对象，并顺藤摸瓜，找到 &lt;code&gt;kernel_completion&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;返回 &lt;code&gt;queued_req&amp;#8594;get_future()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;然后开始了接力比赛，接力棒就是 I/O 请求：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot; start=&quot;1&quot;&gt;
&lt;li&gt;
&lt;p&gt;第一棒：把 I/O 请求从 io queue 取出，经由按照它们所属类型的权重分配的公平队列，
加入 &lt;code&gt;io_sink::pending_io&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-460d1ba5c270c5ae9ff19e8d1243380c.png&quot; alt=&quot;Diagram&quot; width=&quot;740&quot; height=&quot;322&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot; start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;第二棒：从 &lt;code&gt;io_sink::pending_io&lt;/code&gt; 取出 I/O 请求，把这些请求加入 AIO
的 &lt;code&gt;io_context&lt;/code&gt; 队列，换句话说，就是把请求加入 submission queue。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-67c69f3e87d29c2e406ce2e101590a16.png&quot; alt=&quot;Diagram&quot; width=&quot;590&quot; height=&quot;350&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot; start=&quot;3&quot;&gt;
&lt;li&gt;
&lt;p&gt;第三棒: 使用 &lt;code&gt;io_pgetevents()&lt;/code&gt; 系统调用，读取 completion
queue 里面的异步 I/O 事件。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-2665e81ec1e665e8d6e3bb14417ebc11.png&quot; alt=&quot;Diagram&quot; width=&quot;590&quot; height=&quot;266&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;事实上，Seastar 的 I/O 子系统用了 5 个 poller&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-8b9e6634f14d093843230d10ffd3822b.png&quot; alt=&quot;Diagram&quot; width=&quot;390&quot; height=&quot;378&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;请注意，这五个 poller 的执行顺序影响着请求的延迟。因为后面一个
poller 的输入可能就是前一个 poller 的输出。这样同时也有助于减小内存子系统的压力，因为请求在 queue 里面积压的数量和时间越长，就意味着有越多的内存不可用。而这些内存有相当部分是按照下面存储介质的块对齐的，可能会有更多的内部碎片。所以尽早地释放它们，也更有利于提高系统的性能。这里有两个 &lt;code&gt;reap_kernel_completions_pollfn&lt;/code&gt;
是希望一个 poller 能及早地释放 I/O queue 里面的 I/O 占用的内存空间；而让另一个 poller 能处理那些立即返回的 I/O 请求。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果 Seastar 使用 SPDK 作为其存储栈，可能也需要对应的 poller：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;smp_pollfn&lt;/code&gt;: 处理其他 reactor 发来的 I/O。它们可能也会访问当前
core 负责的 bdev。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reap_spdk_completions_pollfn&lt;/code&gt;: 尽早地处理完成了的 I/O 请求，
减轻内存子系统的压力，也减小延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;io_queue_submission_pollfn&lt;/code&gt;: 按照不同优先级把 I/O 入列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;spdk_submit_work_pollfn&lt;/code&gt;: 把 I/O 从队列里面取出，提交给 SPDK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;reap_spdk_completions_pollfn&lt;/code&gt;: 调用 &lt;code&gt;spdk_thread_poll()&lt;/code&gt;
收集完成了的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当然也可以从简处理&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;不用 &lt;code&gt;smp_pollfn&lt;/code&gt;。即不支持跨 shard 发送 IO 请求，每个 shard 都用自己的 io channel。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不用第一个 &lt;code&gt;reap_spdk_completions_pollfn&lt;/code&gt;。因为我们觉得这是个优化，以后慢慢加。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不用 &lt;code&gt;io_queue_submission_pollfn&lt;/code&gt;，因为 SPDK bdev 层有自己基于 token bucket 的 QoS。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不用 &lt;code&gt;spdk_submit_work_pollfn&lt;/code&gt;，既然不用 Seastar 的 fair queue，那么也不用从 io_queue
里捞 I/O 请求了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只保留 &lt;code&gt;reap_spdk_completions_pollfn&lt;/code&gt;。把一切都交给 SPDK。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;现在我们应该能回答刚才的问题了：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;回调函数的参数呢？&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;只要能把 I/O 请求包装成某种类似 &lt;code&gt;io_completion&lt;/code&gt; 的类型，让它&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;能跟踪当初调用异步操作时，返回的 &lt;code&gt;promise&amp;lt;&amp;gt;&lt;/code&gt; 以及&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;能包含在回调函数的参数 &lt;code&gt;cb_arg&lt;/code&gt; 中，以便在 I/O 完成的时候，
通知对应的 &lt;code&gt;_pr&lt;/code&gt; ，并且更新必要的统计信息。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;就可以了。这里有两个思路：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot; start=&quot;1&quot;&gt;
&lt;li&gt;
&lt;p&gt;让 &lt;code&gt;spdk_bdev_io&lt;/code&gt; 包含 SPDK 版的 &lt;code&gt;io_completion&lt;/code&gt;。在回调函数里
通过 &lt;code&gt;spdk_bdev_io&lt;/code&gt; 引用对应的 &lt;code&gt;io_completion&lt;/code&gt;。但是 &lt;code&gt;spdk_bdev_io&lt;/code&gt;
更多的是作为 SPDK 开放给模块的实现者的接口，而非给应用开发者的接口。
注意到 &lt;code&gt;bdev.h&lt;/code&gt; 中，不管是读还是写操作，I/O 的接口基本只有两类&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;void *buf&lt;/code&gt;、&lt;code&gt;uint64_t offset&lt;/code&gt; 和 &lt;code&gt;uint64_t nbytes&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;iovec iov[]&lt;/code&gt;、&lt;code&gt;uint64_t offset&lt;/code&gt; 和 &lt;code&gt;uint64_t nbytes&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;上层应用在发送请求的时候是没有机会接触到 &lt;code&gt;spdk_bdev_io&lt;/code&gt; 的，更遑论在它后面的 &lt;code&gt;driver_ctx&lt;/code&gt; 中夹带&quot;私货&quot;了。况且 &lt;code&gt;driver_ctx&lt;/code&gt;
的本意是让 bdev 的下层驱动加入自己 context，并不是提供给上层应用的。这条路走不通。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot; start=&quot;2&quot;&gt;
&lt;li&gt;
&lt;p&gt;在发送 I/O 请求的时候单独构造 SPDK 版的 &lt;code&gt;io_completion&lt;/code&gt;，把它
作为 &lt;code&gt;cb_arg&lt;/code&gt; 交给 SPDK。在回调函数里还原 &lt;code&gt;io_completion&lt;/code&gt;，
再如前所述，做相应的处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;spdk-在-seastar-中的形态&quot;&gt;SPDK 在 Seastar 中的形态&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里希望讨论 SPDK 在 Seastar 框架中的角色，以及呈现的接口是什么样子的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;另外一个-reactor&quot;&gt;另外一个 reactor？&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面关于 poller 的讨论引出了一个问题，即&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们能重用 Seastar 的这几个 poller 吗？&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个问题在一定程度上等价于：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们需要实现一个基于 SPDK 的 Seastar reactor 吗？&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在阅读 Seastar reactor 实现的时候，可能会注意到，
&lt;code&gt;reactor_backend_selector&lt;/code&gt; 就是用来根据 &lt;code&gt;--reactor-backend&lt;/code&gt;
命令行选项来选择使用的 reactor 后端的。这种类似插件的框架允许我们可以实现一个新的后端。虽然我们能够在 SPDK 的框架下&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加入 poller，并使用非阻塞的调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 aio 读写普通的文件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 &lt;code&gt;sock&lt;/code&gt; 模块&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;把上面这些功能组合起来，足以实现一个功能完备的 &lt;code&gt;reactor_backend&lt;/code&gt;。但是也可以保留 Seastar 的 reactor，像 DPDK 那样另外再注册
&lt;code&gt;spdk::ThreadGroup&lt;/code&gt; 的 poller。牵涉面小，而且工作量也少些。对于两者的集成这可能是更稳妥的第一步。也许这也是 SPDK 支持在
Seastar 中更合适的定位&amp;#8212;&amp;#8203;即提供块设备的访问，而非作为通用的基础设施提供文件系统的访问。这两者有共性，但是也有一些不一样的地方。比如说文件系统可以用 &lt;code&gt;open_directory()&lt;/code&gt;
和 &lt;code&gt;list_directory()&lt;/code&gt; 来枚举一个目录下的所有文件，更进一步，块设备的枚举方式根据块设备的类型各自不同。SPDK 提供 &lt;code&gt;spdk_nvme_probe()&lt;/code&gt;
来列举所有的 NVMe 设备，用 &lt;code&gt;spdk_bdev_first()&lt;/code&gt; 和 &lt;code&gt;spdk_bdev_next()&lt;/code&gt;
来找出所有的块设备。另外，为了提高并发，SPDK 引入了 io channel 的概念，它也很难直接映射到 Seastar 基于文件系统的 IO 体系里面。所以比较好的办法还是先把 SPDK
在 Seastar 下实现成相对独立的模块，而不是试图把它实现成为一种和 AIO 和 epoll
并列的通用异步后端。另外，在初期最大程度保留 SPDK 的基础设施，最小侵入的实现可能是比较稳妥的途径。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;典型的用例&quot;&gt;典型的用例&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们用假想中的 Seastar + SPDK 重写 &lt;code&gt;examples/bdev/hello_world&lt;/code&gt; 试试看&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bpo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;boost&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;program_options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;logger&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;spdk_logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;spdk_demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;**&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;av&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app_template&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seastar_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;seastar_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_positional_options&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bdev&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bpo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;bdev&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;spdk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seastar_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;av&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bdev_name&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seastar_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()[&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bdev&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;as&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seastar_app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;open&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;bdev_name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;uint32_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;size_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf_align&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_dma_alignment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;spdk&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;dma_zmalloc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;block_size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf_align&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0xff&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dev&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;read&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;temporary_buffer&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()};&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;memset&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memcmp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;good&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;size&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;spdk_logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;buf mismatches at {}!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;where&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;spdk_logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;buf matches!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;finally&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;buf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle_exception_type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;system_error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;spdk_logger&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;error while writing/reading {}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;what&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，&lt;code&gt;spdk::app::run()&lt;/code&gt; 会初始化 SPDK app 的运行时。比如说&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;调用 &lt;code&gt;rte_eal_init()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 SPDK 的工作协程调度器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;启动 RPC 服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加载各个子系统&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;它还会负责 SPDK 的清理工作。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;spdk::bdev&lt;/code&gt; 将会是一个 &lt;code&gt;seastar::sharded&amp;lt;&amp;gt;&lt;/code&gt; 服务。&lt;code&gt;spdk::do_with_bdev()&lt;/code&gt;
则是 &lt;code&gt;spdk&lt;/code&gt; 提供的一个 helper，它负责初始化 &lt;code&gt;bdev&lt;/code&gt; 实例，在合适的时机调用
&lt;code&gt;bdev::start()&lt;/code&gt; 和 &lt;code&gt;bdev::stop()&lt;/code&gt;，把根据第一个参数初始化完成好的 &lt;code&gt;bdev&lt;/code&gt;
实例传给自己的另外一个参数，由后者使用 &lt;code&gt;bdev&lt;/code&gt;。虽然这里以 bdev 模块为例，将来
Seastar 和 SPDK 的集成并不会局限于 bdev 模块。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="c++" /><category term="spdk" /><category term="seastar" /><summary type="html">当 C++ 遇上 SPDK。</summary></entry></feed>