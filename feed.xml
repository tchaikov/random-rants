<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://blog.k3fu.xyz/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.k3fu.xyz/" rel="alternate" type="text/html" hreflang="en" /><updated>2021-05-27T02:52:19+00:00</updated><id>https://blog.k3fu.xyz/feed.xml</id><title type="html">some random rants</title><subtitle>我的学习记录</subtitle><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><entry><title type="html">Log-strucutured Filesystem 和垃圾收集</title><link href="https://blog.k3fu.xyz/2021/05/16/gc-fs.html" rel="alternate" type="text/html" title="Log-strucutured Filesystem 和垃圾收集" /><published>2021-05-16T00:00:00+00:00</published><updated>2021-05-16T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2021/05/16/gc-fs</id><content type="html" xml:base="https://blog.k3fu.xyz/2021/05/16/gc-fs.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;此 GC 非彼 GC。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;SeaStore 是 Crimson 使用的存储引擎。它的目标是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;高性能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全异步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持 ZNS 和高性能的存储介质比如 PMEM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持异构存储&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;兼容 Ceph 现有的 object store 的语义&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以看出来，SeaStore 很像一个文件系统。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;文件名就是 object store 里面 object 的 object id&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件的内容就是 object 对应的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件的 xattr 和各种属性，就类似 object 的 omap 和 xattr&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当然文件还支持快照，这个和 object 的快照也很相似&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类似的还有 mount、umount 和 fsck 这类操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;和文件系统一样，SeaStore 也有碎片的问题，所以我们也需要 defrag&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;文件系统的设计可能有好多方面&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;它像数据库: 需要高效地执行查询和修改的操作。对不同性质的访问模式也可以有不同的优化策略。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它像 allocator: 需要有效地管理空间。比如说，分配空闲空间，跟踪使用的空间，释放不用了的区域。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它也有 cache: 需要利用不同性质的存储介质，比如说利用低延迟的存储作为缓存，而用大容量的存储保存冷数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它像调度器: 需要在服务前台请求的同时，也能兼顾后台的任务。所谓磨刀不误砍柴工。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以一篇文章很难讨论到所有的问题。我们先从垃圾收集说起。为什么？因为笔者正好有一本 &lt;a href=&quot;https://book.douban.com/subject/1157908/&quot;&gt;《垃圾收集》&lt;/a&gt;。有点拿着榔头找钉子的意思吧。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;zoned-storage-和-degragmentation&quot;&gt;Zoned Storage 和 degragmentation&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;先说说“钉子”。目前 SeaStore 主要针对的存储介质叫 &lt;a href=&quot;https://zonedstorage.io/introduction/zns/&quot;&gt;Zoned Namespaces SSD&lt;/a&gt;。ZNS flash 和 &lt;a href=&quot;https://zonedstorage.io/introduction/smr/&quot;&gt;叠瓦盘(SMR)&lt;/a&gt; 都属于 Zoned Storage。后者因为读写性能不彰，消费级市场上大家避之不及。但是如果作为冷存储，性价比还是很高的。要是能在应用层结合性能更好的存储介质一起使用，综合下来性价比可能还会更好。但是它最大的问题在于，不支持原地 (in-place) 修改的，所有的修改操作都通过 copy-on-write 实现。整个磁盘被分成好几个区域 (zone)，每个区域都只能添加数据，不能重写已经写入的数据。但要是已经写入的数据被删除了，我们就要回收它们占用的空间。要是需要修改的话，就得复制一份新的。同样，也需要在复制完毕后，回收原来数据占据的磁盘空间。回收的时候，最少必须清除整个 zone。就像用活页笔记本记笔记，每页纸都从头写到尾，如果写坏了，想改一下呢？只能把那一页撕掉，换一张纸重新誊一遍。小块儿的橡皮擦在这里是不能使用的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了帮助理解问题，还需要提一下 SSD 的访问模式。一块 SSD 板卡上一般有多块 NAND 存储芯片，这些芯片通过一定数量的 channel 连接到控制器芯片。所以 SSD 最小的并发单元就是就是单块 NAND 芯片，最大的并发数就是 NAND 芯片的数量。因为无法向一块 NAND 芯片同时发送多个请求。存储领域我们喜欢说 LUN (logical unit number)，在这里我们也把特定的 NAND 用 LUN 来表示。一个 channel 由多个 LUN 共享。而每个 NAND flash LUN 由高到低分成不同的层级&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;channel. channel 之间不共享资源，可以充分并发。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LUN. 连接到相同 channel 的不同 LUN 之间可能会有数据依赖的问题，这一定程度上影响并发。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;plane: 一个芯片有 2 个 或者 4 个 plane。对某个 page 进行写操作的时候，需要对挂在不同 plane 的相同地址的 page 同时写。换句话说，一个 4k 的 page 事实上是映射到不同 plane 的 page 的。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;block: 一般是 512 page。它是 flash 擦除操作的最小单位。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;page: 由四个 sector 构成，加上额外 (out-of-band) 的空间，用来保存映射本身的信息。sector 的大小一般是 4 KB。写操作的的时候，必须按照 page 在 block 里的顺序写。 每个 sector 由多个 cell 构成。而每个 cell 按照芯片的不同存储的比特数量也不一样。比如说 SLC 芯片是一个比特，MLC 是两个比特，TLC 三个，QLC 四个。这里需要解释一下 page pairing 的设计。根据 cell 保存比特的数量，由对应个数的 page 瓜分。换句话说，一个 QLC cell 对应着四个 paired page。只有所有的 page 都写好了，这次写操作才能算完成。所以对于一块有 4 个 plane 的 QLC 来说，每次写操作都必须同时写 4 个 plane，每个 plane 都因为 QLC cell 写操作的单位就是&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;min_bytes_per_write&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 4 planes, 1 page per plan */&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
                      &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 4 paired page for each cell */&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
                      &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 4 sectors per page */&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;
                      &lt;span class=&quot;mi&quot;&gt;4&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_KB&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* 4KB per sector */&lt;/span&gt;
                    &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;256&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_KB&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因此，flash 上的物理地址就由 channel, LUN, plane, block, page 和 sector 构成。读的单位是 sector，而写的单位则是 page。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;顺便说一下，PMEM 的组织就相对扁平，它直接由多个 sector 构成。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;早在 Zoned Storage 出现之前，因为磁盘的机械特性，大家就已经开始思考怎么把随机写转化为顺序写了，以期提高存储系统的性能。很自然的想法就是把 metadata 和 data 作为 log 顺序地写入磁盘。这也是 log-structured filesystem 中 log 的由来。虽然 LSF 解决了随机写的问题，它也带来了随机读的问题。举个例子，我们在磁盘上保存了一个很大的文件，一开始的时候，文件在磁盘上是顺序写入的，所以它的物理地址是连续的。磁盘在顺序读取整个文件的时候不需要很多次寻道，所以 IO 会很快，带宽仅仅受限于磁盘的转速和磁盘接口的传输速度。但是随着时间流逝，用户先后在文件的不同位置作了一些修改。因为这些修改一样，也是作为 log 顺序写入磁盘的，它们的位置和文件原来的位置差得很远了。所以如果要顺序读取文件的话，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;这个读请求就可能会在逻辑地址翻译成物理地址的时候被拆分成为很多小的读请求，这极大影响了顺序访问的性能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更不用说因为地址映射表大小增长带来的额外开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果寻址是按照块对齐的，那么大量的数据片也会造成内部碎片。比如说，如果有的数据只有 7k，要是磁盘的块大小是 4k，那么最后那 3k 很可能就浪费掉了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;损害了读写的局部性。让系统没有办法根据局部性进行优化。通常文件的读写都有一些局部性，文件系统可能会在应用要求读取某个文件开始的 4k 的时候，就把开始的 4M 都读进来了。它估计你很可能接下来也会读这 4M，索性我都读进来好了。反正&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;闲着也是闲着&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这 4M 的物理地址是连续的，所以干脆一起读了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;记得小时候一个乐趣就是看 MSDOS 下面 &lt;code&gt;defrag&lt;/code&gt; 程序不断移动的游标和闪动的小砖块。到现在 youtube 甚至还能找到一些怀旧的视频。它的作用差不多就是把同一文件保存在磁盘相邻的块。以减少磁头磁盘寻道的时间，同时通过把数据排列得更紧凑，把内部碎片挤掉，腾出来一些空闲空间来。可以说&lt;a href=&quot;https://en.wikipedia.org/wiki/Defragmentation&quot;&gt;碎片整理&lt;/a&gt;是一种特定的&lt;a href=&quot;https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)&quot;&gt;垃圾收集&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;f2fs&quot;&gt;F2FS&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;f2fs 的 GC 算法解决的问题就是找出一个牺牲的 segment，把里面的有效块保存下来，然后回收它。f2fs 的 GC 分为前台和后台。只有当空闲空间不够了，才会执行前台 GC。前台 GC 要求短平快，这样能最小限度地减少用户应用的卡顿。后台 GC 则更关注总体的效能，它是内核线程定期唤醒的时候执行的。请注意，f2fs 其实并不会手动迁移有效块，它在选出要回收的 segment 之后，把其中所有的有效块都读取到内存的 page cache 里面，然后把它们标记成 dirty。这样，内核在清 cache 的时候，就会顺便把这些需要保存的有效块也一并写入新的 segment 了。这样不仅能减轻对前台的压力，也可以把小的写请求合并起来。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;它的思路就是让牺牲 segment 的代价最小，同时受益最高。评价策略有下面几种。其中 greedy 和 cost-benefit 是很经典的算法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;greedy&quot;&gt;Greedy&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有效块的个数。所以有效块最少的 segment 就是牺牲品。当 GC 在前台运行时，f2fs 就使用 greedy 策略来选择回收的 segment，这样需要读写的有效块数量最小，所以对用户请求的影响也最小。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;cost-benefit&quot;&gt;Cost-Benefit&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;cost-benefit 算法最早是 &lt;a href=&quot;https://people.eecs.berkeley.edu/~brewer/cs262/LFS.pdf&quot;&gt;The Design and Implementation of a Log-Structured File System&lt;/a&gt; 一文中提出的。论文中设计的 Sprite LFS 文件系统当空闲 segment 的数量低于给定阈值(一般是几十)的时候就会开始 GC，直到空闲 segment 的总数超过另外一个阈值(一般取50到100)。理想情况下的分布应该双峰形的，两个大头分别是有效数据很少的 segment 和有效数据很多的 segment。前者是热数据，后者是冷数据。有效数据比例靠近 50% 的 segment 很少。这种分布对于 GC 来说是比较省心的。因为在回收的时候不需要迁移很多数据。但是使用 greedy 算法的模拟实验结果出乎意料，和局部性更低的测试相比，局部性高的测试产生的分布更差：大量的 segment 都聚集在中间。论文里面分析，使用 greedy 算法的话，只有在一个 segment 的有效数据比例在所有 segment 中最低的时候，它才会被选中回收。这样几轮 GC 之后，所有 segment 的有效数据比例都会降到回收阈值以下，甚至用来保存冷数据的 segment 的有效数据比例也是如此。但是冷数据 segment 使用率是比较坚挺的，它下降得比较慢。可以类比一个收藏家用来保存藏品的储藏室，除非收藏家突然改变了喜好，否则藏品是很少变化的。而冷数据本身也是有惯性的。所以，含有冷数据的 segment 即使大量保有无效数据，但是因为其稳定的使用率，不会被选中回收。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;根据这个观察，论文认为，cold segment 里面的空闲空间其实比 hot segment 里面的空闲空间更有价值。为什么呢？我们可以反过来看，因为和那些很快被修改得体无完肤的 hot segment 相比，cold segment 中的无效数据很难迅速增长。它在系统里面会保持相对较高的使用率更长的时间，我们不得已只能去不停地回收那些 hot segment。它们就像离村庄很近的耕地，因为比较近，所以大家都会更喜欢耕种它们。而埋藏在 cold segment 里面的空闲空间，就更难回收。这导致 cold segment 的使用率慢慢地降低，但是无法回收。这些顽固的 cold segment 的比例在一个访问局部性比较强的系统中可能会很高。因为在那种访问模式下，cold segment 中的冷数据的地位更难以撼动。请注意，这里说的局部性强指的是，重复修改的数据只占硬盘中所有数据的一小部分，绝大部分数据是不变的。如果局部性差的话，所有数据被修改的概率基本上是均等的。如果 GC 很积极地回收使用率低的 hot segment 的话，这样虽然当时迁移的成本很低，但是迁移之后当时被迁移的有效数据很快就被修改了，成为了新的无效数据。所以与其不断地迁移这种 hot segment，不如把它放一会儿，等养“肥”了，再 GC 不迟。这样反而效果更好，效率更高。那时候的有效数据的比例会更低。打个比方，就像一条运动裤已经有点脏了，另外一件衣服上面只有一个墨点，如果明天还要踢一场球，那么你说今天是洗裤子还是洗衣服呢？要不今天还是先洗衣服，明天就穿这条裤子踢球，等踢完球再洗裤子吧。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了能让 GC 更积极地回收这些 cold segment，我们必须在政策上倾斜，让 GC 觉得回收 cold segment 是更有利可图的。所以论文里面把 segment 里面的最新的数据的年龄也作为参数一起计算，segment 越老，那么它里面的的空闲空间至少也经历了那么长的时间。我们把它们解放出来的收益就是两者之积。用公式表达就是：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;stemblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
\[\frac{benefit}{cost} = \frac{(1-u) \times age}{1 + u}\]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;u 表示有效块在 section 中所占比例&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;age 表示 section 中所有 segment 中，最近一次修改的时间。这个数字越大，意味着这个 segment 越 &quot;cold&quot;。用这个时间来估计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 - u 表示回收该 section 获得的收益，因为通过这次回收，能得到的空闲空间是 1 - u。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1 + u 表示开销。1 表示我们需要读取整个被回收的 segment，u 表示我们需要往另外一个 segment 写入其中 u 那么多的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;论文中的模拟实验表示，这样的策略可以使 segment 在使用率上呈现双峰分布或者哑铃状分布。即低使用率的 segment 和高使用率的 segment 都比较多，中间 segement 很少。这样的分布比较适合 GC。如果再能根据冷热数据进行聚类那么 GC 就会更高效。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;cat&quot;&gt;CAT&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Cost Age Times，这个算法基于 cost-benefit，它同时关注 flash block 的 wear leveling 问题。但是 ZNS SSD controller 已经帮我们处理了，所以这里不考虑这类算法。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;atgc&quot;&gt;ATGC&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://lwn.net/Articles/828027/&quot;&gt;ATGC&lt;/a&gt; (Age Threshold based Garbage Collection) 是华为的开发者提出的算法，用来改进 f2fs 的 GC 效果 (effect) 和性能 (efficiency)。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 segment 的年龄小于预设定的阈值，那么就不再考虑把它回收。因此可以避免回收太年轻的 segement，这种 segment 往往更新更频繁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用 SSR (slack space recycling) 写日志的时候，尽量选择那些年龄相近的作为源 segment 和目标 segment。这样他们的更新频率可能更相近，有助于保持冷热数据的分离和聚类。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
f2fs 除了顺序写日志 (normal logging)之外，还能在空间不够的时候往无效的空间直接写 (threaded logging)，写进去的日志串起来一样用。这样虽然把顺序写变成了随机写，但是可以避免 GC 带来的卡顿，要是选择的 segment 有很大的空闲空间，也能顺序写一阵。这种随机写的做法就叫做 SSR。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;zonefs&quot;&gt;ZoneFS&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;btrfs&quot;&gt;Btrfs&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为我们的目标是支持 flash，而 flash 本质上是不支持原地 (in-place) 修改的，所以所有的修改操作都通过 copy-on-write 实现。这也正是 SeaStore 的设计很大程度上受到了 Btrfs 影响的原因。而且最近 Btrfs 也开始加入对 zoned 设备的&lt;a href=&quot;https://lwn.net/Articles/853308/&quot;&gt;支持&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;mark&gt;TODO&lt;/mark&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;spdk-ftl&quot;&gt;SPDK FTL&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;mark&gt;TODO&lt;/mark&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;lsm_zgc&quot;&gt;LSM_ZGC&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比较原始的 GC 算法可能仅仅关注 zone 里面有效数据的比例，如果一个 zone 里面的有效数据超过一定比例，我们可能就希望保留它，而回收那些充斥着垃圾数据的 zone。&lt;a href=&quot;https://www.usenix.org/system/files/hotstorage20_paper_choi_0.pdf&quot;&gt;LSM_ZGC 一文&lt;/a&gt; 提出的 GC 算法希望解决下面几个&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;问题&quot;&gt;问题&lt;/h3&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;冷热数据分离。因为将来在进行另一次 GC 的时候，也会根据数据的性质进行选择 zone。如果一个 zone 里面的冷数据或者热数据的比例是压倒性的多数，那么就可以更容易地决定这个 zone 的处理方式。比如说，如果是绝大多数是冷数据，那么可以放心地把数据搬到冷存储上。要是绝大多数是无效数据，那么这个 zone 就是很好的回收对象。反之，如果 zone 的使用率是 50%，那么做 GC 的时候就难以取舍了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GC 的时候，如果被选中回收的 zone 使用率很高，那么保存有效数据的开销会很大。因为典型的 zone 的大小是 256MB 或者 512MB，所以即使允许用户 IO 抢占后台的 GC 任务，GC 对总体性能产生的影响也会很明显。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大量 4k 大小读请求和相对大的读请求相比，后者的性能要比前者要好很多。我们假设后者是 8K 到 128K 的IO。原因是，连续地址的读请求可以充分利用 ZNS SSD 内部的并发能力。因为文中说，一个 zone 里面的数据会被分散到不同 channel 连接的 LUN 上，所以读取更大的读操作就能更好地利用同时使用多个 channel 带来的并发性。但是我认为，使用更大的读操作是一种利用 inter-channel 并发的简便的方式。但是这并不等于说，发送多个分散的小的读操作的并发就不好了。这样做的缺点应该是请求的个数更多了。因为处理多个请求产生的开销也因而增加。但是要得到比较好的性能也需要权衡，如果 64MB 的区间里面，有效的数据只有 4K，那么就没有必要坚持读取所有 64MB 的数据了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;方案&quot;&gt;方案&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;按照在文中的设置，一个 zone 大小为 1GB，一个 segment 为 2MB，一个 block 为 4KB。这些设定很大程度上借用了 f2fs 的磁盘布局。为了提高读操作的效率，如果一个 segment 里面有效的 block 个数小于 16，那么就仅仅读取有效数据，否则就读取整个的 segment。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我把这个思路叫做“大浪淘沙”。每个 zone 都处于下面四种状态中的一个。刚落盘的数据在 C0，以 segment 为单位统计，如果某一个 segment 的数据使用次数超过事先设定的阈值 threshold&lt;sub&gt;cold&lt;/sub&gt;，所有保存在这种 segment 中的有效数据都被收集到 C1C_zone，其他 segment 中的有效数据则悉数放到 C1H_zone 中。等到下一次 GC 的时候，无论是 C1H_zone 还是 C1C_zone 中，只要数据仍然有效，我们就把它们当作冷数据，一起放到 C2_zone。因为他们都经历了两次 GC 试炼，并且存活了下来。论文的作者期望通过这样的筛选机制，能够有效地区分不同生命周期的数据。其中，请注意，在这里，“冷数据”并不是指访问频次很低的数据，而是很少被修改或者删除的数据。它们经得起时间的考验，历久而弥坚。我们常说的 WORM (write once read many) 设备保存的就是冷数据。就是而热数据则是那种很快失效的数据，这种数据经常修改，它们生命周期很短，转瞬即逝，如同朝露一般。可以说，CPU 寄存器里面的数据就是热数据。所以我们在第一次 GC 的时候会借助保存数据的机会，先把冷热数据初步分开。这样如果要找热数据富集的牺牲品 zone 的时候，可以更容易地找到这样的 zone。但是第二次 GC 的时候就不再关注它们的使用频次了，而只是单纯地把第一代的幸存者都收集在一起。它们都被搬运过一次，而且顺利地活到了第二次 GC。所以它们完全有资格升级成“二级冷数据”。论文认为，第一代幸存者的生存周期相似，所以它们的空间局部性很可能也更好。比如说 leveldb 里面，同一个 SSTable 里面数据的访问频次可能不同，但是它们的生命周期是相同的，读写模式也一致。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-cc5ce0511ab793e146a79ac5fd9c7695.png&quot; alt=&quot;Diagram&quot; width=&quot;1050&quot; height=&quot;236&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们还可以更进一步。让经过冷热数据区分后活下来的 C2_zone 数据，升级进入 C3_zone。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-b92a6e8c5c6f5c96230e0f564b67e4f2.png&quot; alt=&quot;Diagram&quot; width=&quot;974&quot; height=&quot;59&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样通过多次淘汰，我们就可以把数据分出三六九等，有的数据经历了很多次 GC 都巍然不动，有的数据最多只能到 C1H_zone 状态就黯然退场。前者都保存在同一个 zone 里面，所以 GC 的时候就不会因为它们和其他热数据挤在一起，而在腾地方的时候被迫迁移它们，因此就减少了不必要的开销。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;seastore&quot;&gt;SeaStore&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 SeaStore 当前的目标是支持 ZNS。对它来说，每一张活页纸就是一个 segment。为了理解 SeaStore 怎么做垃圾收集，首先需要知道 SeaStore 里面的 journal 是什么。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;cache&quot;&gt;Cache&lt;/h3&gt;

&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;journal&quot;&gt;Journal&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Journal 就是日志，也就是 log-structured filesystem 里面的 log。在任意时刻，SeaStore 总是指定一个特定的 segment 作为当时写 journal 的专用 segment。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;admonitionblock note&quot;&gt;
&lt;table&gt;
&lt;tr&gt;
&lt;td class=&quot;icon&quot;&gt;
&lt;i class=&quot;fa icon-note&quot; title=&quot;Note&quot;&gt;&lt;/i&gt;
&lt;/td&gt;
&lt;td class=&quot;content&quot;&gt;
ZNS 是支持同时打开多个 zone 的。这样让我们可以按照写入数据的不同特性，选择不同的 zone，这样可以避免因为不同生命周期的数据相互交错，导致在 GC 的时候投鼠忌器，难以权衡。但是 SeaStore 现在为了简单起见，还没有利用这个特性。
&lt;/td&gt;
&lt;/tr&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;segmentcleaner&quot;&gt;SegmentCleaner&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;GC 的时机&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mount 的时候，会扫描 journal 映射的地址空间。这确定了空闲空间的大小，借这个机会，就会看看是不是应该运行 GC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;GC 的条件，只要满足下面的条件之一，就触发 GC&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空闲空间不够了。需要同时满足下面的条件，才能称为空间不够&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空闲空间的比例 &amp;lt; &lt;code&gt;available_ratio_gc_max&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可回收的空间 / 非空闲空间 &amp;gt; &lt;code&gt;reclaim_ratio_gc_threshhold&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;error: 1954 Forbidden search
absolutely fatal: operation lost in the dodecahedron of doom
Would you like to try again? y/n&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;mark&gt;TODO&lt;/mark&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">此 GC 非彼 GC。</summary></entry><entry><title type="html">ceph::common::PerfCounter 和 seastar::metrics</title><link href="https://blog.k3fu.xyz/2021/05/10/metrics.html" rel="alternate" type="text/html" title="ceph::common::PerfCounter 和 seastar::metrics" /><published>2021-05-10T00:00:00+00:00</published><updated>2021-05-10T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2021/05/10/metrics</id><content type="html" xml:base="https://blog.k3fu.xyz/2021/05/10/metrics.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;成年人还是得做选择。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;seastarmetrics&quot;&gt;seastar::metrics&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;http://docs.seastar.io/master/group__metrics.html&quot;&gt;seastar::metrics&lt;/a&gt; 是 seastar 提供的一套机制，用来监控系统的动态指标。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;label&quot;&gt;label&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 &lt;code&gt;seastar::metrics&lt;/code&gt; 里面，每个指标都有自己的标签。举个例子吧，假设 seastore 能够管理多个存储设备，每个设备都有自己的 IO 队列。而作为一个存储系统，我们可能会关心好多指数&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;total_bytes: 写入设备的数据量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;total_operations: 读写请求的总个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;queue_length: 当前的读写队列长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delay: 总的延迟&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;问题在于，每个设备我们都需要监控这同一组数据。如果按照面向对象的思路，那么就是每个对象都有一组属性，而且每个对象都有自己的名字或者索引。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外对于 seastar 应用来说，每个 shard 都是一个相对独立处理的单元，独立结算，自负盈亏。如果我们希望监控一个 sharded service，那么这个服务在每个 shard 都有一组自己的数据。Sesastar 甚至为每一个 &lt;a href=&quot;http://docs.seastar.io/master/structseastar_1_1metrics_1_1impl_1_1metric__definition__impl.html&quot;&gt;metric_definition_impl&lt;/a&gt; 都强制加上了 &lt;code&gt;shard_label&lt;/code&gt;，所以每个 metric 从一出生，它标签上的&quot;shard&quot;就是当时 reactor 的 shard id，如果当时 reactor 还没有运行，那么 shard 就是 &quot;0&quot;。但是如果要自己设置 &lt;code&gt;shard_label&lt;/code&gt; 的话，也可以用 seastar 提供的 &lt;code&gt;shard_label&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;label&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;shard_label&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;shard&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中 &lt;code&gt;label&lt;/code&gt; 是一个 functor 类，它可以用来构造 &lt;code&gt;label_instance&lt;/code&gt; 实例。后者才是真的 label。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;instance&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;operator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;label_instance&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;key&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;forward&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通过为 metrics 贴上多个标签，我们可以更方便地管理和查询这些指数。而且不用因为把数据聚合起来而丢失重要的信息。seastar 在把 metrics 导出到监控系统的时候，也把 label 一起导出了。它&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用 prometheus &lt;a href=&quot;https://prometheus.io/docs/practices/naming/#labels&quot;&gt;labels&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 label 编码成 collected 的 &lt;a href=&quot;https://collectd.org/wiki/index.php/Naming_schema#Plugin_instance_and_type_instance&quot;&gt;type instance&lt;/a&gt; 字段里面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;将来，如果我们决定使用 &lt;code&gt;seastar::metrics&lt;/code&gt; 的话，甚至可能会用不同的 label 在不同的维度来标记同一个监控的指数&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;不同 CPU shard 上的监控数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同 pg 的监控数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同存储设备的监控数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同网卡或者网络设备的监控数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不同网络连接的监控数据，比如说连接到 peer osd 的心跳或者网络延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;比如说，当我们注意到出现多个 slow request 的时候，首先会看这些请求在不同维度上的相关性，如果所有的请求都和某个 replica osd 有关，那么我们可能就能猜测 primary 和这个 osd 的连接是不是有问题。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;名字&quot;&gt;名字&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;metric 的名字由 group 和 name 构成。一组逻辑上相关的 metric 组成一个 group，比如说 seastore 的所有指数的 group 可能就是 &quot;seastore&quot;。加上一个名字空间方便管理。内存方面的监控则用 &quot;memory&quot; 作为 group 的名字。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;数据的类型&quot;&gt;数据的类型&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;seastar::metrics&lt;/code&gt; 大体是按照 &lt;a href=&quot;https://prometheus.io/docs/concepts/metric_types/&quot;&gt;Prometheus 的几种指标的类型&lt;/a&gt; 和 &lt;a href=&quot;https://collectd.org/wiki/index.php/Data_source#Data_source_types&quot;&gt;collectd 的数据类型&lt;/a&gt; 来实现的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;它定义了下面几类指标：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;counter: 单调递增的整数。要是发现某个 counter 变小了，唯一的解释就是它溢出了。比如说，从启动到现在 cache miss 的请求数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gauge: 测量值。和 &lt;code&gt;counter&lt;/code&gt; 不同，&lt;code&gt;guage&lt;/code&gt; 支持浮点，它的值允许减小。比如说&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统的音量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;某个队列的总延迟&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当前 onode 的缓存大小&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;derive: 和 &lt;code&gt;gauge&lt;/code&gt; 相比，&lt;code&gt;derive&lt;/code&gt; 更像 &lt;code&gt;counter&lt;/code&gt; 一些。它仅仅支持整型，但是它允许读数减小。它叫 &quot;derive&quot; 的原因并不是这个指标是由其他指标导出 (derive) 的，而是因为，很多时候我们关心的是这个数值的变化量 (derivative)，或者说读数对时间的导数。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当前正在处理的请求个数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;histogram: 一个指标的直方图。比如说，&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;请求的延迟的分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请求大小的分布&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了和 &lt;a href=&quot;https://collectd.org/documentation/manpages/types.db.5.shtml&quot;&gt;collectd 的类型&lt;/a&gt; 对应上，&lt;code&gt;seastar::metrics&lt;/code&gt; 还定义了一些方便的函数，用来设置基于这些类型。比如，&lt;code&gt;make_total_bytes()&lt;/code&gt;，它的功用就是在为 collectd 导出监控数据的时候，为对应的指标设置 &lt;code&gt;total_bytes&lt;/code&gt; 的数据类型。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;数据的来源&quot;&gt;数据的来源&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;make_gauge()&lt;/code&gt; 这些函数让我们提供一个变量的引用，或者给出一个函数返回要监控的数据。事实上前者也是通过包装一个 lambda 来实现的。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;cephcommonperfcounters&quot;&gt;ceph::common::PerfCounters&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;ceph::common:PerfCounters&lt;/code&gt; 使用 &lt;code&gt;PerfCounters&lt;/code&gt; 来管理一组 perf counter，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;名字-2&quot;&gt;名字&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 &lt;code&gt;ceph::common::PerfCounters&lt;/code&gt; 不是统一管理的，每个 perfcounter 在构造的时候都设定了一个字符串，作为它的名字。在导出 perfcounter 的时候，把所有的 perfcounter 被放在以 &lt;code&gt;PerfCounters::get_name()&lt;/code&gt; 为名的大对象里面。每个 perfcounter 分别打印自己的信息。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;数据的类型-2&quot;&gt;数据的类型&lt;/h3&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;col style=&quot;width: 25%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;none&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;u64&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;time&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;longrunavg&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;histogram&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;time&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;数据的来源-2&quot;&gt;数据的来源&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;每个 &lt;code&gt;PerfCounters&lt;/code&gt; 都有一个 &lt;code&gt;std::vector&amp;lt;&amp;gt;&lt;/code&gt; ，用于保存对应的 perf counter，通过预先定义好的索引来更新和访问 vector 里面对应的值。&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;ceph&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;seastar&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;PerfCountersCollection&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;metric group&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; rowspan=&quot;3&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;add_u64_counter()&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;make_counter()&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;make_derive()&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;make_gauge()&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;PerfCountersBuilder&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;metric_groups&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;PerfCounters&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;None&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;idx&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;metric_id?&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;总体上 &lt;code&gt;PerfCounters&lt;/code&gt; 和 &lt;code&gt;metrics&lt;/code&gt; 两个功能相当，而且前者内置了一些功能&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对 counter 加上优先级。优先级有点像 Python 的 logging level。它决定了不同情况下，输出 perfcounter 的详尽程度。如果是 &lt;code&gt;CRITICAL&lt;/code&gt; 的 perfcounter 的话，一般来说都会打印出来，或者发给 prometheus, influxdb 这些 mgr module。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持设置自定义的字符串作为监控指标的单位，在打印 perfcounter 的时候，可以打印自定义的单位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个 perfcounter 有 &lt;code&gt;LONGRUNAVG&lt;/code&gt; 属性，那么还会统计平均值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是 &lt;code&gt;PerfCounters&lt;/code&gt; 缺少 label 的支持，而且其实现是基于 &lt;code&gt;std::atomic&amp;lt;&amp;gt;&lt;/code&gt; 的，在读写 perfcounter 的时候对性能也有负面的影响。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">成年人还是得做选择。</summary></entry><entry><title type="html">QoS 和 dmClock</title><link href="https://blog.k3fu.xyz/2021/04/24/dmclock.html" rel="alternate" type="text/html" title="QoS 和 dmClock" /><published>2021-04-24T00:00:00+00:00</published><updated>2021-04-24T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2021/04/24/dmclock</id><content type="html" xml:base="https://blog.k3fu.xyz/2021/04/24/dmclock.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;QoS，而且是分布式的。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;qos&quot;&gt;QoS&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果一个服务有多个服务对象，那么就得分轻重缓急。但是也不能因为有些服务对象不重要，就完全不顾它们。举个例子，就算平时工作再忙，上个月的报销单也应该及时填啊。那么怎么实现 QoS 呢？还是用报销单的例子，那么我们定个规矩吧：每天至少用半小时时间填报销，要是做不完的话，那么就明天继续做。在执行之前，我们需要先引入几个概念:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任务：也就是要做的事情。每件事情都有它的优先级，还有它要花费的时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务列表：要是任何时候，手里面只有一件事情，我们可能就不用操心 QoS 了。但是现实是，很多时候别说不同优先级的，就是同一优先级的任务都可能同时有好几件。我们一般按照先到先服务的原则，把它们放到队列里面，挨个处理。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类：把要做的事情按照优先级分成几种。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计量：每个任务需要的时间都不一样，如果只是处理会议的邀请，那么可能只需要几秒钟就能做出回应。但是如果是分析一个新的编译错误，可能就得花半个小时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调度：接下来该从哪个队列里做哪个任务呢？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们还需要继续细化刚才的规定，这半个小时时间是排在什么时候呢？要不下午一点开始吧。对应到刚才的概念就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;任务：每天的工作，比如处理信件，填报表单，当然还有调试程序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务列表：每件工作按照先后顺序记到小本本上。做完一件就划掉一件。有新的工作就记在最后面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分类：工作分成两类：一类是平时的工作，另一类是低优先级的维护工作，比如说报销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;计量：对列表里的工作根据工作量一一进行评估。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调度：现在到一点了吗？还没到，那么看看“正事儿“列表里面下一项是什么？到了的话，看看另外一个列表有没有东西，没有的话，就先做正事儿。反过来也是这样，就是如果今天正好没有其他事情的话，即使没有到一点钟，那么也不妨把积攒的报销单填了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以对我们来说，每当要开始下一个任务的时候，要回答的问题就是，我应该看哪个任务列表呢？刚才的设计定义的算法是一种比基础的优先级队列 （priority queue）调度更复杂的算法。它不仅仅为不同性质的任务定义了具有两个优先级的队列，而且为了防止低优先级任务得不到执行，还为它们保留了最小的带宽。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;clock&quot;&gt;Clock&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在说 mClock 之前，我们先说说几个指标：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;weight (share) ：这个类型的任务能使用多少比例的资源。如果一个系统里面需要进行数据迁移，那么它可以占用的带宽比例就可以很高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;reservation：这个类型的任务最少能保证得到多少资源。如果系统里面需要有低延迟的应用，比如说远程桌面或者交互式的网络游戏，那么就必须保证最低的带宽。但是这种应用需要的 weight 可能就相对低一些。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;limit: 使用资源的上限。比如说刚才说的数据迁移的应用，它可能就需要设定一个上限，在资源吃紧的情况下，防止它挤占其它应用的带宽。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;刚才的算法里面只支持前两个指标。mClock 的目标是同时支持这三个参数。论文前面列举了一些算法，这些算法解决的问题分为三类：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按照应用指定的权重分配带宽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了按照比例分配带宽之外，还能照顾对于延迟比较敏感的应用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了按照比例分配带宽，照顾延迟，还能预留最低的带宽&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是 mClock 不仅仅能支持这些功能之外，还支持指定上限，并且能根据资源的容量动态地进行调整。比如说，一个系统它接入的是一个网络存储，因为分布式的存储系统和本地存储相比有着更多的变数和不确定性，那么这个系统能获得的存储的带宽可能就是动态的。根据网络系统的设置，以及存储系统提供给它的带宽而定。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;mClock 先从 tag-based 调度算法开始。 标签是指每当调度器看到一个新的请求，就会给它贴一个标签。标签上有几个之后要用到的数字。这个很像是去饭馆吃饭时，拿到的预约单号。当调度器需要决定谁是下个幸运儿的时候，它就检查每个请求上标签。每个客户端都有自己的权重 \(w_i\) 。我们用权重的倒数就可以构成一个等差数列，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;stemblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
\[1/w_i, 2/w_i, 3/w_i, .., n/w_i\]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在服务端，当请求到达的时候，就根据请求所属的客户端为请求打上标签。同一客户端发来的请求构成了这个数列。权重越大客户端对应的序列分布越密集。下图中有蓝黄和绿三个客户端，它们的权重分别为 1/2，1/3 和 1/6。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-24e6f884f67150da9bbfe1e0eaa73663.png&quot; alt=&quot;Diagram&quot; width=&quot;650&quot; height=&quot;378&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果标签小于当前时间就按照先小后大的顺序依次处理，那么在单位时间里面，客户端得到处理的请求个数所占比例也就是它分到的权重。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们还可以从完全公平调度（Complete Fairness Scheduling）算法的角度来进一步理解。CFS 的调度对象是进程。它按照 RUNNABLE 进程的虚拟时钟从小到大排序，时间靠前的进程先调度，靠后的后调度。每个进程都有自己的虚拟时钟。内核定期按照物理时钟的节拍推进所有的虚拟时钟。各进程时间流逝的速度是不一样的，优先级高的进程时钟就走得慢，低的走得快些。这样，CFS 就能直接调度排在最前面的进程。顺便说一下，Linux 中的 CFS 调度器是用红黑树来管理这些 RUNNABLE 进程的，树的键就是虚拟时钟的值。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外，由于时间早的会先调度，所以如果谁的时钟停摆很久，如果它的标签一开始就比它优先级高的其他人低好多，那么一旦开始发送请求，接下来就会因为自己的时钟读数比其他人都小而连续抢占资源，导致发生饥饿。因此 mClock 论文里面说的 global virtual time 或者 virtual time 也就是为了解决这个问题。全局时钟要求所有的客户端时钟不管客户端是不是正在发出请求，都不断地往前推进。确保不会有人中途加入，打乱其他人的步调。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;mclock&quot;&gt;mClock&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.usenix.org/legacy/event/osdi10/tech/full_papers/Gulati.pdf&quot;&gt;mClock&lt;/a&gt; 把这个想法推而广之，既然我们要支持 reservation 和 limit，为什么不能用他们来计算 tag 呢？我想这也是 mClock 的名字的由来，multiple clocks。于是在处理每个请求的时候，都会给他们设定三个 tag：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;\(\mathit{R_i}^{r}\)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;\(\mathit{L_i}^{r}\)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;\(\mathit{P_i}^{r}\)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;R 代表 reservation&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;L 代表 limit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P 则是 priority, weight 或者是 proportional&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以 \(\mathit{R_i}^{r}\) 为例，用下面的递推公式计算：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;stemblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
\[\mathit{R_i}^{r} = max \{\mathit{R_i}^{r-1}+\frac{1}{\mathit{r_i}}, \mathit{t}\}\]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中， \(\mathit{r_i}\) 就是第 i 个客户端的 reservation 值。相邻 tag 的距离就是 \(\frac{1}{r_i}\)。而 \(\mathit{t}\) 是当前的时间。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么刚才说的 global virtual time 的问题怎么解决呢？因为新客户端的上一个标签无据可查，而且枚举 &lt;strong&gt;所有&lt;/strong&gt; 的客户端，定时遍历每个人的时钟，挨个更新它们的三个 tag，对系统可能也是个负担。论文采取的办法是，把所有人的 P 和当前时间对齐。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;写成 C++ 代码，可能就是这样：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;request_arrival&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;request_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;time_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;was_idle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;// tag adjustment&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;empty&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;min_P_tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_element&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;begin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;active_vm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;P_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vm&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_P_tag&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// tag assignment&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;R_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;R_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reservation&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;L_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;L_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;limit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;P_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;max&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;P_tags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;/&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;weight&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;schedule_request&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为什么对 \(\mathit{P_i}^{r}\) 特殊处理呢？我们假设直接使用当前的时间作为新人或者刚开始 active 的客户端的  \(\mathit{P_i}^r\)。那么对其他客户端来说，它们发出第一个请求的时候，\(\mathit{P_i}^{r}\) 也是当前的系统时刻，但是当客户端持续地发出请求，随着时间推移，根据各自的权重不同，你我的时间开始差得越来越多，贫富差距慢慢显现。但是新来的客户端横空出现打破了这个均衡，它的 \(\mathit{P_i}^{r}\) 不是根据之前的 \(\mathit{P_i}^{r-1}\) 推算出来的，而是直接使用的当前时间。虽然它的优先级可能并不高，但是它在一段时间之内凭借它的暂时的“后发优势“，无缘无故地打败了很多甚至优先级比他更高的老前辈，直到它的权重慢慢地把一开始的 P 慢慢抵消，一切恢复正常。mClock 算法为了解决这个问题，转而以最新的系统时钟调整其他老革命的 P，让所有的 P 按照时间轴平移，令最小的 P 等于系统时间。这样新加入的 P 就不会干扰现有的秩序了。因为 P 标签有累计的效应，所以这里仅仅调整它。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有了三个 tag，那么到底以谁为准呢？调度器有两种决策模式，并根据当前情况在两者之间切换：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;基于约束的决策：调度器先看看有没有人的 R 小于当前时间，要是有的话，就直接调度最小 R 的请求。一旦所有的 R tag 大于当前时间，就脱离基于约束的决策模式，进入基于权值的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于权值的决策：这时候所有人的 reservation 都已满足。调度器开始按照权重来分配资源。它先把资源用量还没有超过上限的人找出来，他们的 L 比当前时间小。然后从中找出 P 最小的。调度 \(vm_{i}\) 的请求的时候，除了让它的最前面的请求出列，还需要把 \(vm_{i}\) 其他还在队列里面的请求的 R 都减去 \(1/r_{i}\)。这样可以保持相邻 R 的差仍然是 \(1/r_{i}\)。否则，我们想象一下，如果一个客户端很长一段时间它的请求都是用基于权值的决策调度的，那么它的 R tag 就会非常大。一旦系统的资源吃紧，它会立即得不到应该有的 reservation。为什么？只是因为它一直因为权重得到了很多服务，但是这笔账不应该算在 reservation 头上。所以我们每次因为权重调度请求，都需要把这个客户端的还没调度的请求的 R tag 都往前移动一格。确保这个客户端的 reservation 不会受到影响。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-06cb45f5e7e3fc832d67ce5752d92d6d.png&quot; alt=&quot;Diagram&quot; width=&quot;480&quot; height=&quot;308&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;mclock-为存储系统做的一些改进&quot;&gt;mClock 为存储系统做的一些改进&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;突发情况&quot;&gt;突发情况&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有些客户端可能会稳定地发送读写请求，但是也有那种平时不动声色，突然狮子大开口的角色。有时候请求会陡然增加，我们叫做 burst。比如说有的客户端每个晚上会为文件建立索引，但它白天却悄无声息，这时候我们希望感谢它之前高风亮节为大家节省资源，给它个行个方便，让它一开始的 \(\mathit{P_i}^{r}\) 小一些。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;stemblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
\[\mathit{P_i}^{r} = max \{\mathit{P_i}^{r-1}+\frac{1}{\mathit{r_i}}, t - \frac{\sigma_{i}}{w_i}\}\]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个 \(\sigma_{i}\) 可以每个人都不一样，我们暂且把它叫做&quot;先人后己奖励奖&quot;吧，专门用来补偿把带宽让给别人的人，让他们在有急需的时候也能感受到 QoS 的温暖。论文后面也提到，如果这个奖金太高，会因为扰乱权重分配的决策，导致细水长流式的客户的高延迟。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;读写有别&quot;&gt;读写有别&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在存储系统里面，写的延迟往往比读请求要高。但是我们没办法取巧，把同一个客户端的请求乱序执行。比如，把读请求放到写请求之前乱序执行未导致读到不一致的数据。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;大小有别&quot;&gt;大小有别&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;IO 请求有的大，有的小，不能等同视之。因为我们不追求绝对的延迟数值，比如说一个 4k 的读请求需要多少毫秒。我们希望得3到的是一个比例，即大小为 S 的 IO 请求产生的延迟相当于多少个单位大小的 IO 请求。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;stemblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
\[1 + \frac{S}{T_{m} + B_{peak}}\]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;论文大概计算了一下，其中 \(T_{m}\) 表示机械动作产生的延迟，假设每次随机读写都要求机械磁盘的悬臂产生移动到对应的磁道，磁盘都需要转动到需要读写的扇区。而 \(B_{peak}\) 是磁盘最高的读写速度。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;dmclock&quot;&gt;dmClock&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;分布式的场景下，每个服务器需要了解两件事情&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;你从所有服务器总共获得了多少服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其中，你通过 reservation 获得了多少服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了让服务器知道客户端的服务情况，客户端在发送请求的时候也会顺带着发送&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;\(\rho_{i}\) 最近请求到当前请求之间，因为基于约束的决策获得的服务数量。其实也就是因为 reservation 获得的服务数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;\(\delta_{i}\) 最近请求到当前请求之间，获得了多少服务。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;stemblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
\[\mathit{R_i}^{r} = max \{\mathit{R_i}^{r-1}+\frac{\rho_{i}}{\mathit{r_i}}, \mathit{t}\} \\
\mathit{L_i}^{r} = max \{\mathit{L_i}^{r-1}+\frac{\delta_{i}}{\mathit{l_i}}, \mathit{t}\} \\
\mathit{P_i}^{r} = max \{\mathit{P_i}^{r-1}+\frac{\delta_{i}}{\mathit{w_i}}, \mathit{t}\}\]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;下面是之前介绍的单机版递推公式：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;stemblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
\[\mathit{R_i}^{r} = max \{\mathit{R_i}^{r-1}+\frac{1}{\mathit{r_i}}, \mathit{t}\}\]
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以发现，我们把 1 换成了 \(\rho_i\)。这个思路和之前是一脉相承的。有点像一个大型的合作性的公寓，每家都有个户主负责向提供交各种费用水费、电费、煤气费。但是户主们并不是各自为政，只要交的总金额足够支付整个公寓的账单就行，当然，家里面有的时候没有流动资金，所以紧张的话，有的人可以少交有的人也可以多交。但是户主和户主之前缺少有效的沟通方式，好在自来水公司它们都有明细账，所以户主在缴费的时候可以查看之前的账目。这里户主就像分布式系统里面提供服务的节点，各项费用的账单就像不同性质的客户请求。缴费的过程就是处理客户请求。借用刚才的示意图，我们以 100 块钱为单位，如果公寓上个月加起来交了 200 块钱电费，那么电力公司这次就应该把付账的进度条往前推进 2 个单位。所以图里面的有两个请求就用虚线表示了，它们代表在其他服务器处理过的请求。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-ce864186a97ebc129f2d101826de62d3.png&quot; alt=&quot;Diagram&quot; width=&quot;480&quot; height=&quot;308&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;公式里的 \(\rho_{i}\) 和 \(\delta_{i}\) 就是这里的&quot;2&quot;。这两个系数表示因为不同原因，自从上次从这个服务器处理请求，这个客户端一共从不同服务器获得了多少服务。很明显，\(\delta_{i}\) 应该总是大于等于 \(\rho_{i}\)。如果是单机的话，两个参数就退化成 1 了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;dmclock-在-ceph-中的应用&quot;&gt;dmClock 在 Ceph 中的应用&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为 dmClock 是一个通用的算法，Ceph 并没有把直接集成在自己的 repo 里面，而是单独实现了高度模板化的 &lt;a href=&quot;https://github.com/ceph/dmclock&quot;&gt;dmClock 库&lt;/a&gt;。这样其他应用也能使用它。dmClock 库基本忠实地实现了论文中的算法。开始之前，请大家注意，目前 Ceph 正在使用的并不是 dmClock 而是 mClock。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;osd-中的-qos&quot;&gt;OSD 中的 QoS&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;OSD 需要处理多种请求，有的请求优先级比较低，比如后台的数据恢复，有的请求优先级比较高，比如说前台客户发来的读写请求。而 OSD 的处理能力有限，又希望有一定的 QoS 能力。就需要设计一个能兼顾不同优先级需求的调度器。我们把不同类型的请求看成不同的客户端，在 &lt;code&gt;OpSchedulerItem&lt;/code&gt; 就定义了下面几种请求&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;client_op&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;peering_event&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bg_snaptrim&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bg_recovery&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bg_scrub&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;bg_pg_delete&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;以 &lt;code&gt;bg&lt;/code&gt; 开头的请求都是后台的请求，它们保证系统的正常运行，但是优先级相对于前面两类请求就要低一些。而且，每个 &lt;code&gt;OpSchedulerItem&lt;/code&gt; 都有自己的 priority 和 cost。所以调度器调度的对象就是 &lt;code&gt;OpSchedulerItem&lt;/code&gt; 了。但是可能和大家猜测的不同，OSD 用来实现 QoS 的调度器却不是全局唯一的。它是 &lt;code&gt;OSDShard&lt;/code&gt; 的成员变量。而 &lt;code&gt;OSDShard&lt;/code&gt; 则是 OSD 的执行单位，它维护着一个队列。队列里面的元素就是被安排执行的请求。每个 shard 都负责一个或者多个 PG，每当有请求到达，都会用请求对应的 PG 作为 key 找到对应的 shard，让 shard 决定什么时候执行它。而这个决定就是由调度器做出的。所以有多少个 &lt;code&gt;OSDShard&lt;/code&gt; 就有多少个调度器，它们分别为各自负责的一组 PG 调度请求。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们有两个调度器&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;classedopqueuescheduler&quot;&gt;ClassedOpQueueScheduler&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个调度器很像 &lt;a href=&quot;https://en.wikipedia.org/wiki/Low-latency_queuing&quot;&gt;Low-latency queuing&lt;/a&gt;。它基于 WeightedPriorityQueue 实现，简称 WPQ。它的设计和大家熟知的 Weighted Fair Queueing 调度器很像。WPQ 维护着多个子队列，每个队列有自己的优先级。在调度的时候，队列按照优先级享有对应的权重，被选中的机会就是权重的大小。选好队列之后，再随机选择队列里面的请求。请求的 cost 越低，被选中的可能性越大。但是这个设计可能太“公平“了，但是对于低延迟的请求响应可能就不够及时。所以除了这个为普通优先级服务的加权公平队列之外，调度器还另外定义了一个单独的 WPQ，为低延迟的应用提供了严格优先级的服务。只有严格优先级队列里面的请求处理完了，它才会开始检查普通优先级的队列。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;mclockscheduler&quot;&gt;mClockScheduler&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面提到一个 OSD 有多个调度器，但是它们共享除了系统线程之外所有的资源，而且缺少有效的隔离措施。所以在设置预留值的时候是按照假设的介质提供最大带宽按照 shard 的数量平均下来计算的。和 &lt;code&gt;ClassedOpQueueScheduler&lt;/code&gt; 类似，&lt;code&gt;mClockScheduler&lt;/code&gt; 定义了一个 &quot;immediate&quot; 队列，它提供为高优先级的客户端先进先出的服务。只有这个队列没有元素的情况下，才会转用基于 mClock 的队列。为了方便测试，现在预定义了三种 QoS 模式，分别为三大类请求设置了对应的参数：&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;col style=&quot;width: 20%;&quot;&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;QoS模式&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;服务类型&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;预留&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;权重&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;上限&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; rowspan=&quot;3&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;偏重客户性能&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;client&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;50%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;inf&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;recovery&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;25%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;100%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;best effort&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;25%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;inf&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; rowspan=&quot;3&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;均衡型&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;client&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;40%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;100%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;recovery&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;40%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;150%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;best effort&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;20%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;inf&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot; rowspan=&quot;3&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;集中精力 recovery 型&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;client&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;30%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;80%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;recovery&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;60%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;2&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;200%&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;best effort&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1%&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;1&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;inf&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;mClockScheduler&lt;/code&gt; 中，很重要的一个函数是 &lt;code&gt;mClockScheduler::ClientRegistry::get_info()&lt;/code&gt;，它负责把请求按照他们的 &lt;code&gt;get_scheduler_class()&lt;/code&gt; 分门别类，套用上面配置的 &lt;code&gt;res&lt;/code&gt;, &lt;code&gt;wgt&lt;/code&gt; 和 &lt;code&gt;lim&lt;/code&gt; 参数。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MOSDOp:&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;CEPH_MSG_OSD_OP&lt;/code&gt; 或者 &lt;code&gt;CEPH_MSG_OSD_BACKOFF&lt;/code&gt;: client。这一类所有的请求都用 &lt;code&gt;default_external_client_info&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他: immediate&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PG 操作&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;pg delete: background_best_effort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pg scrub: background_best_effort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pg snaptrim: background_best_effort&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pg peering: immediate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pg recovery:&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;高优先级的就是: immediate&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;低优先级就是: background_recovery&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;客户端和服务端协作的-dmclock&quot;&gt;客户端和服务端协作的 dmClock&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;社区也曾推进 dmClock 在 Ceph 的应用。在 2018 年的 Cephalocon 上， SK 电信的工程师向我们分享了他们做的 &lt;a href=&quot;https://www.slideshare.net/ssusercee823/implementing-distributed-mclock-in-ceph#6&quot;&gt;工作&lt;/a&gt;。甚至他们的改进曾经进入了 master，但是后来被 &lt;a href=&quot;https://github.com/ceph/ceph/pull/21398&quot;&gt;revert&lt;/a&gt; 了，剩下的 &lt;a href=&quot;https://github.com/ceph/ceph/pull/19340&quot;&gt;PR&lt;/a&gt; 到现在三年多过去了，没有进展。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">QoS，而且是分布式的。</summary></entry><entry><title type="html">大批量发送增量 osdmap 对性能的影响</title><link href="https://blog.k3fu.xyz/2021/03/29/flatten-osdmaps.html" rel="alternate" type="text/html" title="大批量发送增量 osdmap 对性能的影响" /><published>2021-03-29T00:00:00+00:00</published><updated>2021-03-29T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2021/03/29/flatten-osdmaps</id><content type="html" xml:base="https://blog.k3fu.xyz/2021/03/29/flatten-osdmaps.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;补丁太多了的话，加起来大小可能会比最终的版本更大。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 Ceph 里面，osdmap 是一个很重要的数据。比如说，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集群的拓扑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集群里每个数据池的 crush 规则，甚至还有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个屏蔽列表，集群会拒绝向在列表里面的客户端提供服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是正因为 osdmap 包含了太多信息，在集群里面传递完整的 osdmap 会耗费很多带宽，而且编解码完整版本的 osdmap 也加大了对 CPU 的压力。为了缓解这个压力，我们选择仅仅发送变化的那部分。在 monitor 上，每次 osdmap 有变化，我们不仅仅保存了最新完整版本的 osdmap，也会保存它的增量部分&amp;#8201;&amp;#8212;&amp;#8201;我们用专门的对象保存这个部分，即 &lt;code&gt;OSDMap::Incremental&lt;/code&gt;，有时候干脆叫它 inc map。所以当客户端找 monitor 要 osdmap 的时候，也会告诉对方自己手里面 osdmap 的版本 &lt;code&gt;m&lt;/code&gt;，如果 monitor 的最新版 osdmap 的版本是 &lt;code&gt;n&lt;/code&gt;，那么它就会把 &lt;code&gt;m..n&lt;/code&gt; 的所有 inc map 都发给客户端。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是有时候也会适得其反，因为积少成多，要是有很多的 inc map，为了发送这些 inc map，对 monitor 甚至客户端，累加起来的开销和发送一个完整 osdmap 比起来可能会更高。而且，需要注意的是，&lt;code&gt;Monitor::ms_dispatch()&lt;/code&gt; 是在一个全局大锁里面执行的。很多其他操作也需要这个锁。所以我们应该尽量避免长时间地持有它，否则会造成很高的延迟。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;要解决这个问题，有下面几个思路：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在 monitor 一侧&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;减少 monitor 对 osdmap 的更新频次。primary osd 会根据情况要求产生 pgtemp，但是 monitor 也可以主动地批次生成 pgtemp。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分期分批地发送 inc map。这样可以缓解因为长时间占用全局锁造成的延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 osd 一侧&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;减少 osd 对 osdmap 的请求。如果 osd 发现自己落后太多，就直接找 monitor 要完整的最新版 osdmap。而不是要求获得增量版本。减轻 monitor 的负担。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是 &lt;code&gt;n&lt;/code&gt; 版的 osdmap 是不是真的能替代 &lt;code&gt;m&lt;/code&gt; 版 osdmap 加上中间的 &lt;code&gt;m..n&lt;/code&gt; 的 inc map 呢?&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">补丁太多了的话，加起来大小可能会比最终的版本更大。</summary></entry><entry><title type="html">方程式赛车和读写请求</title><link href="https://blog.k3fu.xyz/2021/03/14/lap-n-race.html" rel="alternate" type="text/html" title="方程式赛车和读写请求" /><published>2021-03-14T00:00:00+00:00</published><updated>2021-03-14T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2021/03/14/lap-n-race</id><content type="html" xml:base="https://blog.k3fu.xyz/2021/03/14/lap-n-race.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;请求 client.io-42 在第三圈超过了 client.io-17！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前阵子在思考在 Ceph 里面为什么要顺序执行读写。简单说，和 CPU 的顺序执行模型一样，这个模型更容易理解和使用。顺便跑题一下，对于&quot;人工智能是什么&quot;一直有个争论。其中有两派:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;弱人工智能，即表现上的人工智能。 &lt;a href=&quot;https://en.wikipedia.org/wiki/Chinese_room&quot;&gt;中文房间&lt;/a&gt; 中文房间和 &lt;a href=&quot;https://en.wikipedia.org/wiki/Turing_test&quot;&gt;图灵测试&lt;/a&gt; 就是两个比较有名的测试，通过它们就是一定程度上的弱人工智能。这种人工智能能解决一个特定问题领域上的问题。 现在说的机器学习就是一种弱人工智能。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强人工智能，即机理上的人工智能，或者说通用人工智能。这种人工智能需要具有知识表示，推理，规划，学习，自然语言处理等等能力，并把它们整合起来。强人工智能和弱人工智能比起来要难很多。前年看的 &lt;a href=&quot;http://bayes.cs.ucla.edu/WHY/&quot;&gt;The Book of Why: The New Science of Cause and Effect&lt;/a&gt; 说明了因果关系和推理在人工智能的重要地位。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;和人工智能一样，存储系统的顺序性也有两种&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表现出来是顺序的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;严格在执行层面上就是顺序的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;当然，限制越多，性能越不好。所以在实现 crimson 的时候，每当要求顺序执行的时候，我都会多问几次&quot;为什么&quot;。Ceph 集群里面，一个读写请求在一生中，至少有下面几个阶段&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;从客户端到 primary OSD&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从 primary OSD 分配到对应的 PG&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成事务，并写入本地磁盘。事务包含 pglog 和对应的用户数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;replica OSD 也回应了请求，确认持久化完成。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;客户端请求就像方程式赛车一样，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;必须遵守一定的规则，比如只有在持有要求的 osdmap 的时候才能开始处理它，不能依据老版本的 osdmap 行事。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要跑完一定的圈数，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;而且，对于 Ceph 来说，特定客户端发来的多个请求必须顺序完成。好像来自一个车队的选手必须按照出场顺序完赛一样。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 crimson 里面，满足前两个要求都比较简单直接。问题在于第三个。如果 object store 能保证先进先出，那么是不是只要保证发送请求到 object store 的顺序满足第三个要求就行了呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;答案是不行。在中间有的阶段需要有 write barrier，比如，为了保证 osd 在恢复时有个参考，pglog 保存了 PG 最近的一系列操作，它们保存在 pglog 里面。在构造 transaction 的时候，会和封装用户数据的 journal 一起刷到磁盘上。但是 pglog 是一个链表，链表上每个环节都是一次对 PG 的修改操作。为了逻辑上简单一些，我们需要 pglog 上的操作序列也按照按照客户请求的顺序安排。这样在副本不一致的时候，就可以按照顺序恢复了。不用担心因为乱序执行带来的数据依赖的问题。所以在生成 pglog 的时候，需要保证顺序。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;类似的，在写磁盘的时候也需要保证顺序，因为相同的读写操作以不同顺序发送到后端存储，得到的结果是不一样的。这个道理和之前《多核和顺序》一文中讨论的问题类似。所以在写磁盘的时候也需要保序。我们使用流水线的设计解决这个问题。&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">请求 client.io-42 在第三圈超过了 client.io-17！</summary></entry><entry><title type="html">永不消逝的 failure 报告</title><link href="https://blog.k3fu.xyz/2021/03/11/failure-reports.html" rel="alternate" type="text/html" title="永不消逝的 failure 报告" /><published>2021-03-11T00:00:00+00:00</published><updated>2021-03-11T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2021/03/11/failure-reports</id><content type="html" xml:base="https://blog.k3fu.xyz/2021/03/11/failure-reports.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有时候，failure 报告会化身 SLOW_OPS，并获得永生。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ceph 集群里面，OSD 和 OSD 会定时互相发送心跳。如果有人很长时间不回应，那么另外一方就会打个小报告给 monitor。告诉 monitor，对方很可能已经停摆了。当然，这只是一家之言，monitor 不会因此就断定那个不回消息的人失联了。但是如果收到多个不同来源的报告，都指向同一个 OSD，那么 monitor 就会认为该 OSD 的确是有问题的。而且，本着认真负责的精神，monitor 把所有的小报告的原件都保存了起来。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;monitor 这边&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 osdmap 已经把失联的 OSD 标记成了 &lt;code&gt;down&lt;/code&gt;，它会逐个联系打报告的 OSD，给他们发送最新版的 osdmap。告诉相关人士，&quot;众卿这下可以放心了&quot;。如果自己变成了 peon，也会把这些小报告重新处理一遍，小报告会被转发给新的 leader，让它定夺。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果打小报告的 OSD 不在 osdmap 里面了，它会直接把这个 OSD 发送的报告全部删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;报告人&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果打小报告的 OSD 准备重启，或者因为网络故障打算停止运行，它也会主动发消息，让 monitor 取消自己的报告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外，报告人一旦和失联 OSD 取得了联系，它也会取消自己的报告。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;或者它不再和失联 OSD 互发心跳了，那么它同样会把之前的报告撤销。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;失联的人&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果失联的人其实并没有脱离组织，但是它发现 monitor 已经把自己从 osdmap 除名。那么它会向 monitor 发消息澄清。monitor 收到它的请求，会把所有关于它的报告作废。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外一方面，为了跟踪集群里面的性能问题，Ceph 设计了一个机制，叫 &lt;code&gt;TrackedOp&lt;/code&gt;。我们认为每个请求都有它的生命周期。如果集群出现问题的话，可能会导致请求有很长时间的延迟。这就是我们常说&quot;hang&quot;。最极端的情况就是一个请求永远得不到相应。这里所说的请求包罗万象，从客户端发来的 IO 请求，到 &lt;code&gt;ceph&lt;/code&gt; 命令行发到 monitor 的查询，甚至刚才提到的&quot;小报告&quot;都是所谓的 &lt;code&gt;TrackedOp&lt;/code&gt;。每个对自己服务质量有要求的 daemnon 都有个注册表叫做 &lt;code&gt;OpTracker&lt;/code&gt;。每收到一个 &lt;code&gt;TrackedOp&lt;/code&gt; 请求，都会把它记录在案。在 &lt;code&gt;OpTracker&lt;/code&gt; 的析构函数里面，则会把自己从注册表里面注销掉。所以这个表里面保存着当前所有的 &lt;code&gt;TrackedOp&lt;/code&gt; 的引用，如果一个 &lt;code&gt;TrackedOp&lt;/code&gt; 收到之后很快就销毁了，那么就认为这个 op 的处理是及时的。但是如果有请求躺在注册表里很长时间，都没有把自己注销，那么很可能它就&quot;hang&quot;住了。处理这个请求的服务在定期汇报健康状况的时候，会把这个问题也一起报告给 monitor。monitor 会进一步汇总，把这类问题一起报告给管理员。这种问题叫做
&lt;code&gt;SLOW_OPS&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以，只要可能失联的 OSD 仍然在 osdmap 里面，那么 leader monitor 就会把针对它的小报告一直保留下来。直到 leader 收集到足够的证据，或者举报的人主动撤销或者自己出局。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是也有可能证据一直不够充分，那么 leader 无法做出判断。而这些报告经 &lt;code&gt;prepare_failure()&lt;/code&gt; 处理后，就一直放在 &lt;code&gt;OpTracker&lt;/code&gt; 里面，变成了 &lt;code&gt;SLOW_OPS&lt;/code&gt; 的一员。对于系统管理员来说，它们成了很碍眼的报警信息。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里其实有两个问题：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;prepare_failure()&lt;/code&gt; 处理过了小报告，是不是就可以说，monitor 完成了这个请求？从而把它从 &lt;code&gt;OpTracker&lt;/code&gt; 里面注销？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;monitor、报告人和疑似失联者三方都尽心尽力对报告负责。但是如果报告人因为异常重启没有撤销报告，那么这个它发送的报告就永远无法撤销了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;解决这个问题可能有下面几个方案，他们相对独立：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;处理完毕失联报告，就直接销毁对应的请求，让 &lt;code&gt;OpTracker&lt;/code&gt; 不再跟踪它。这样即使这个报告在短时间之内没有举报成功也不会出现在 &lt;code&gt;SLOW_OP&lt;/code&gt; 里面。但是问题在于&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果失联报告暂时没有下文，我们能说处理完毕了吗？换言之，如果一个疑似失联的人没有被及时澄清，或者没有踢出 osdmap，那么这个集群的设计很可能是有问题的。它表示这个集群很可能有严重的网络分裂问题，导致一部分 OSD 之间无法互相通信，但是另外一部分 OSD 之间的网络是联通的，导致疑似失联的 OSD 没有办法在短时间之内获得足够数量的报告。所以把这个问题以 &lt;code&gt;SLOW_OPS&lt;/code&gt; 的方式暴露出来也是一个办法，让管理员觉察到问题，虽然这个错误信息比较隐晦。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;报告人这里对报告也有周密的跟踪机制，它把还未发出去的报告保存在 &lt;code&gt;failure_queue&lt;/code&gt; 里面，已经发出去的报告则保存在 &lt;code&gt;failure_pending&lt;/code&gt; 里面。 如果发出的报告没有下文，也就是说如果它没有撤销，而新版的 osdmap 也没有把失联的 OSD 标记成 &quot;down&quot;，那么这些报告会一直保存在 OSD 里面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 monitor 这边加入衰退的机制，如果失联报告很长时间没有其他方的证据坐实这个问题，那么就取消报告。但是在大规模的集群里面，如果集群有突发情况，比如产生大规模的网络分裂，那么短时间之内 &lt;code&gt;failure_info&lt;/code&gt; 中会出现大量积压的 failure 报告，如果在持有 &lt;code&gt;Monitor::lock&lt;/code&gt; 大锁的时候遍历数据它，可能会加重 monitor 的负担，提高 monitor 处理消息的延迟。请注意，&lt;code&gt;Monitor::timer&lt;/code&gt; 是一个 &lt;code&gt;SafeTimer&lt;/code&gt;，而这个 &quot;safe&quot; 是由 &lt;code&gt;Monitor::lock&lt;/code&gt; 保障的。而 &lt;code&gt;Monitor::ms_dispatch()&lt;/code&gt; 也是在 &lt;code&gt;Monitor::lock&lt;/code&gt; 里面处理消息的。为了缓解这个问题，可以引入一个 &lt;code&gt;int&lt;/code&gt; 型的 &quot;指针&quot;，每次在 &lt;code&gt;tick()&lt;/code&gt; 里面仅仅处理一定数量的 failure，如果超过这个数量，就把工作留到下次 &lt;code&gt;tick()&lt;/code&gt; 再做。这个 &quot;指针&quot; 就用来保存下次开始的位置。如果在某次处理部分报告的时候，正好错过了某些刚加入的信息也没关系，以后就会轮到的。除非 &lt;code&gt;failure_info&lt;/code&gt; 增长的速度大大超过每次 &lt;code&gt;tick()&lt;/code&gt; 处理的速度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为 OSD 会定期发送 &lt;code&gt;osd_beacon&lt;/code&gt; 给 monitor，所以如果有疑似的失联 OSD 发送 beacon 给 monitor，那么是不是也能说明这个 OSD 并不是真正的脱离了组织呢？但是，如果因为网络的问题，这个 OSD 只是不能和举报的 OSD 联系，那么我们也需要把它踢出 osdmap。但是因为 &lt;code&gt;osd_beacon&lt;/code&gt; 的发送周期非常长，达 300 秒之久。所以经过这么长的时间，monitor 都无法做出裁决。大概率也能说明集群很难有效地在指定时间内有效地标记失联 OSD 了，至于原因可能是当初发送报告的 OSD 重启，或者干脆是严重的网络分裂问题。但是如果是 OSD 重启的话，我们不应该继续保留 &lt;code&gt;SLOW_OPS&lt;/code&gt; 了，它逗留的时间已经够久了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">有时候，failure 报告会化身 SLOW_OPS，并获得永生。</summary></entry><entry><title type="html">Crimson 里面的流水线</title><link href="https://blog.k3fu.xyz/2020/11/17/pipeline-ceph.html" rel="alternate" type="text/html" title="Crimson 里面的流水线" /><published>2020-11-17T00:00:00+00:00</published><updated>2020-11-17T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/11/17/pipeline-ceph</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/11/17/pipeline-ceph.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在处理性能问题的时候，需要知道客户请求都堵在哪儿了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;具体说，有这么两个需求&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;能够知道客户请求阻塞在什么地方了。比方说，最好能够列出当前还没有完成的请求都是什么状态。是在等 osdmap，还是在等 PG，还是在等它希望访问的 object？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供一个机制，能阻塞客户请求。我们有时候甚至希望有计划有策略地阻塞客户端请求。实现一些 QoS 的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Crimson 为了解决这些需求，引入了一组概念&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;Operation&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;代表一种操作。比如说刚才提到的客户发来的请求就是一种 &lt;code&gt;Operation&lt;/code&gt;。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;Blocker&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;代表处理操作的一个特定的阶段。像刚才提到的 “等 osdmap”，就可以作为一个 &lt;code&gt;Blocker&lt;/code&gt;。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;&lt;code&gt;Pipeline&lt;/code&gt;&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;代表系列 &lt;code&gt;Blocker&lt;/code&gt;。在做限流或者 QoS 的时候，pipeline 也是一个资源。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了集中跟踪当前的 &lt;code&gt;Operation&lt;/code&gt; ，我们定义了 &lt;code&gt;ShardServices::start_operation()&lt;/code&gt; ，用一个全局的数据结构分门别类记录各种操作。这里以简化版的 &lt;code&gt;ClientRequest::process_op()&lt;/code&gt; 为例，解释一下用法&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ClientRequest&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;PG&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection_pipeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;await_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;osd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;osdmap_gate&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_map&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;min_epoch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;connection_pipeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;osd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;spg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg_pipeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_active&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait_for_active_blocker&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle_enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg_pipeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;recover_missing&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;maybe_recover&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_oid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg_pipeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_obc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;with_locked_obc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_op_info&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;with_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handle_enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg_pipeline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;process&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;req&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;reply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;conn&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;reply&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;处理一个请求有多个步骤，它们构成一条流水线&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-f8331bd7a8dba669aefa098f93365f15.png&quot; alt=&quot;Diagram&quot; width=&quot;330&quot; height=&quot;518&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，绿色和蓝色分别代表一条小流水线。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;绿色的是 connection pipeline。每个客户端来的链接都有一条。它分两个阶段&lt;/p&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;wait until osd gets osdmap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait for PG&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;蓝色的是 PG pipeline。每个 PG 都有一条。&lt;/p&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;wait until PG gets osdmap&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait for active&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait for object recovery&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait for object context&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait for process&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一条流水线就像博物馆的一层楼。流水线分多个阶段，每个阶段就像一层楼里面的一个个展厅。第一次去一个博物馆或者艺术馆，我一般会拿着小册子，按照顺序，一个展厅一个展厅地逛。因为不会分身大法，所以也没办法同时在几个展厅参观。这个设定和 Ceph 处理客户端请求是很像的。但是即使是在疫情期间，博物馆的展厅也能同时容纳不止一个人。那么这些 pipeline 呢？在同一时刻，我们允许多个请求停留在同一阶段吗？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;答案是“不可以”。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;blocking_future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;OrderedPipelinePhase&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;enter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;OrderedPipelinePhase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fut&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;lock&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;phase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;new_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;new_phase&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_blocking_future&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fut&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中 &lt;code&gt;new_phase&lt;/code&gt; 就是即将进入的新展厅：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderedPipelinePhase&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Blocker&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;// ...&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;shared_mutex&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mutex&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;要是不熟悉 &lt;code&gt;seastar::shared_mutex&lt;/code&gt;，可以把它理解成和 &lt;code&gt;std::shared_mutex&lt;/code&gt; 有类似语义的共享锁。但是这里调用的是霸气的 &lt;code&gt;lock()&lt;/code&gt; 而不是 &lt;code&gt;lock_shared()&lt;/code&gt; 。所以在别人离开展厅之前，你是没法进去的。同样，要是你在里面，别人只能止步。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个气氛好像很不和谐。就像好多人希望去一个很大的展厅，他们想看的展品其实都不一样，但是因为里面已经有
&lt;strong&gt;一个人&lt;/strong&gt; 了，所以大家只能依次在门外排队，等出来一个人，才能进去一个人。这个情形倒很像是高峰时段的厕所。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果有多个不同的请求正好访问同一 PG，即使它们对应的是不同的 object，也不得不互相保持二十米的距离，挨个等待 &lt;code&gt;PG.client_request_pg_pipeline.process&lt;/code&gt; 。前面一个人不完事儿，后面的人必须等着。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这不又是 PG 大锁嘛。我在例会上提出来这个问题。Sam 提醒我。可以从另外一个角度看这个问题。每个 OSD
都有上百个 PG，而一个集群有成百上千个 OSD。如果 PG 的分布很均匀，那么每个 PG 同时需要处理的请求其实是不多的。而且，我一直有个误解，就是觉得 PG 大锁是现有 OSD 性能不彰的原因之一。但是 Sam 告诉我，问题不在于 lock contention，而在于 CPU 的使用率居高不下。这才想起来，官方的文档建议一个 OSD 一般需要配备两个核。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过还是有点放不下心，最好我们能在各个“展厅”前面设置一个计时器，看看大家都在门外面等了多久。这也是流水线机制设立的一个初衷。&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">在处理性能问题的时候，需要知道客户请求都堵在哪儿了。</summary></entry><entry><title type="html">seastar::future 中的 ownership</title><link href="https://blog.k3fu.xyz/2020/10/16/ownership-in-seastar.html" rel="alternate" type="text/html" title="seastar::future 中的 ownership" /><published>2020-10-16T00:00:00+00:00</published><updated>2020-10-16T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/10/16/ownership-in-seastar</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/10/16/ownership-in-seastar.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;seastar::future&lt;/code&gt; 在 &lt;code&gt;get()&lt;/code&gt; 之后就像被掏空了一样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最近有同事说，在测试 Release build 的时候发现 &lt;code&gt;crimson::do_until()&lt;/code&gt; 会产生 segfault。重现的代码很简单：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;  &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;test&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;crimson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_until&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;++&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ertr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_ready_future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ertr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;make_ready_future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看了下，的确如此。祭出 &lt;code&gt;seastar-addr2line&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;?? ??:0
seastar::internal::future_base::detach_promise() at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1169
 (inlined by) seastar::internal::future_base::schedule(seastar::task*, seastar::future_state_base*) at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1175
 (inlined by) seastar::future&amp;lt;bool&amp;gt;::schedule(seastar::continuation_base&amp;lt;bool&amp;gt;*) at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1372
 (inlined by) void seastar::future&amp;lt;bool&amp;gt;::schedule&amp;lt;seastar::internal::promise_base_with_type&amp;lt;&amp;gt;, crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}, seastar::future&amp;lt;bool&amp;gt;::then_impl_nrvo&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;, crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; &amp;gt;(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)::{lambda(seastar::internal::promise_base_with_type&amp;lt;&amp;gt;&amp;amp;&amp;amp;, a_basic_test_t::test()::{lambda()#1}&amp;amp;, seastar::future_state&amp;lt;bool&amp;gt;&amp;amp;&amp;amp;)#1}&amp;gt;(seastar::internal::promise_base_with_type&amp;lt;&amp;gt;, crimson::errorated_future_marker&amp;lt;&amp;gt;&amp;amp;&amp;amp;, seastar::future&amp;lt;bool&amp;gt;::then_impl_nrvo&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;, crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; &amp;gt;(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)::{lambda(seastar::internal::promise_base_with_type&amp;lt;&amp;gt;&amp;amp;&amp;amp;, a_basic_test_t::test()::{lambda()#1}&amp;amp;, seastar::future_state&amp;lt;bool&amp;gt;&amp;amp;&amp;amp;)#1}&amp;amp;&amp;amp;) at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1391
 (inlined by) crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; seastar::future&amp;lt;bool&amp;gt;::then_impl_nrvo&amp;lt;crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}, crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; &amp;gt;(crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}) at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1571
 (inlined by) crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; seastar::future&amp;lt;bool&amp;gt;::then_impl&amp;lt;crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}, crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; &amp;gt;(crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}) at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1605
 (inlined by) seastar::internal::future_result&amp;lt;a_basic_test_t::test()::{lambda()#1}, bool&amp;gt;::future_type seastar::internal::call_then_impl&amp;lt;seastar::future&amp;lt;bool&amp;gt; &amp;gt;::run&amp;lt;crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}&amp;gt;(seastar::future&amp;lt;bool&amp;gt;&amp;amp;, crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}) at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1234
 (inlined by) crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; seastar::future&amp;lt;bool&amp;gt;::then&amp;lt;crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}, crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;&amp;gt; &amp;gt; &amp;gt;(crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}) at /var/ssd/ceph/build-release/../src/seastar/include/seastar/core/future.hh:1520
 (inlined by) auto crimson::errorator&amp;lt;crimson::unthrowable_wrapper&amp;lt;std::error_code const&amp;amp;, crimson::ec&amp;lt;(std::errc)22&amp;gt; &amp;gt; &amp;gt;::_future&amp;lt;crimson::errorated_future_marker&amp;lt;bool&amp;gt; &amp;gt;::_then&amp;lt;crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}&amp;gt;(crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1})::{lambda(a_basic_test_t::test()::{lambda()#1}&amp;amp;&amp;amp;)#1}) at /var/ssd/ceph/build-release/../src/crimson/common/errorator.h:676
 (inlined by) auto crimson::do_until&amp;lt;a_basic_test_t::test()::{lambda()#1}&amp;gt;(a_basic_test_t::test()::{lambda()#1}) at /var/ssd/ceph/build-release/../src/crimson/common/errorator.h:68
seastar::noncopyable_function&amp;lt;void ()&amp;gt;::direct_vtable_for&amp;lt;seastar::async&amp;lt;a_basic_test_t_0_basic_Test::TestBody()::{lambda()#1}&amp;gt;(seastar::thread_attributes, std::decay&amp;amp;&amp;amp;, (std::decay&amp;lt;a_basic_test_t_0_basic_Test::TestBody()::{lambda()#1}&amp;gt;::type&amp;amp;&amp;amp;)...)::{lambda()#1}&amp;gt;::call(seastar::noncopyable_function&amp;lt;void ()&amp;gt; const*) at /var/ssd/ceph/build-release/../src/test/crimson/test_errorator.cc:22
seastar::noncopyable_function&amp;lt;void ()&amp;gt;::operator()() const at /var/ssd/ceph/build-release/../src/seastar/include/seastar/util/noncopyable_function.hh:201
 (inlined by) seastar::thread_context::main() at /var/ssd/ceph/build-release/../src/seastar/src/core/thread.cc:297&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个问题的特点是 Release 版本才有。注意到 Seastar 中 &lt;code&gt;future::schedule()&lt;/code&gt; 的实现 (文中把过长的行折成多行，方便阅读)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Pr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pr&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;pr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Func&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wrapper&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// If this new throws a std::bad_alloc there is nothing that&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// can be done about it. The corresponding future is not ready&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// and we cannot break the chain. Since this function is&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// noexcept, it will call std::terminate if new throws.&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;memory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;disable_failure_guard&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;dfg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tws&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;continuation&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Pr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;SEASTAR_ELLIPSIS&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;pr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                                                           &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;
                                                                           &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wrapper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// In a debug build we schedule ready futures, but not in&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// other build modes.&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#ifdef SEASTAR_DEBUG
&lt;/span&gt;        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;tws&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
            &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tws&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;cp&quot;&gt;#endif
&lt;/span&gt;        &lt;span class=&quot;n&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;tws&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future_state_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invalid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中对 Debug 版本有特殊的处理，如果 &lt;code&gt;future::_state&lt;/code&gt; 当时就有，那么调用 &lt;code&gt;continuation_base::set_state()&lt;/code&gt; 把 &lt;code&gt;_state&lt;/code&gt; 搬到新建的 &lt;code&gt;tws&lt;/code&gt; 里面。
&lt;code&gt;future_state::move_it()&lt;/code&gt; 是 &lt;code&gt;future_state(future_state&amp;amp;&amp;amp;)&lt;/code&gt; 的具体实现。它比较直接，把值 move 或者 &lt;code&gt;memmove&lt;/code&gt; 到自己手里面。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是 Release 版则会调用 &lt;code&gt;future_base::schedule(tws, &amp;amp;tws&amp;#8594;_state)&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;linenotable&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;linenos gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;    &lt;span class=&quot;n&quot;&gt;promise_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;detach_promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_promise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_promise&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_future&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exchange&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;nullptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;schedule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;task&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tws&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;future_state_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;promise_base&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;detach_promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_state&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_task&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;tws&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;err&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;segfault 发生在第 2 行，所以说 &lt;code&gt;_promise&lt;/code&gt; 在那个时候已经是个空指针。这是谁干的呢？我们回过头看看 &lt;code&gt;do_until()&lt;/code&gt; 的实现&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;table class=&quot;linenotable&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;linenos gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AsyncAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;inline&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;do_until&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsyncAction&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futurator&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; \
    &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;futurize&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result_of_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AsyncAction&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futurator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;need_preempt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futurator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorator_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_ready_future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;need_preempt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;action&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mutable&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futurator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorator_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_ready_future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;();&lt;/span&gt;
          &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;crimson&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_until&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;failed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;futurator&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;errorator_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;make_exception_future2&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
      &lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;思路很简单，就是递归调用，直到 &lt;code&gt;f&lt;/code&gt; 返回真。因为递归是通过 post message 风格的调用实现的，所以不需要担心栈的大小问题。其中最可疑的地方就是 &lt;code&gt;._then()&lt;/code&gt; 了，它其实就是 &lt;code&gt;future::then()&lt;/code&gt;。后者分情况讨论，如果 future 的 state 是立等可取的，那么就直接 &lt;code&gt;futurator::invoke()&lt;/code&gt; 了，否则调用 &lt;code&gt;then_impl_nrvo()&lt;/code&gt;。接下来则是 &lt;code&gt;future::schedule()&lt;/code&gt;。&lt;code&gt;schedule()&lt;/code&gt; 会把 &lt;code&gt;future&lt;/code&gt;
的 &lt;code&gt;_promise&lt;/code&gt; 取走，留下一个空指针。这下子就和前面的 backtrace 对上了。但是稍等，为什么要调用
&lt;code&gt;schedule()&lt;/code&gt; 呢？&lt;code&gt;test()&lt;/code&gt; 里面都返回的 future 的 state 都是 &lt;code&gt;available&lt;/code&gt; 的啊。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们再看看 &lt;code&gt;future::get()&lt;/code&gt; 吧&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gnu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;always_inline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;value_type&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;wait&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_available_state_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个 &lt;code&gt;take()&lt;/code&gt; 很奇怪。&lt;code&gt;get()&lt;/code&gt; 和 &lt;code&gt;take()&lt;/code&gt; 的语义是不一样的。一个是返回拷贝或者引用，一个则是从所有者手中 &lt;strong&gt;夺走&lt;/strong&gt;，然后返回抢到的东西。果不其然：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;take&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;assert&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;exception_min&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rethrow_exception&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;_u&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;result_unavailable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static_cast&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&amp;gt;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;uninitialized_get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以 &lt;code&gt;take()&lt;/code&gt; 之后，&lt;code&gt;future&lt;/code&gt; 里面原来的 state 成了 unavailable 的状态。难怪 &lt;code&gt;do_until()&lt;/code&gt;
回过头再看 &lt;code&gt;f&lt;/code&gt; 的时候，它已经变成了 unavailable，所以就傻乎乎地去调用 &lt;code&gt;_then()&lt;/code&gt; 了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;再看看 &lt;code&gt;get_available_state_ref()&lt;/code&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;    &lt;span class=&quot;p&quot;&gt;[[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gnu&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;always_inline&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]]&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;future_state&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_available_state_ref&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;noexcept&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;detach_promise&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;_state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;原来 &lt;code&gt;_promise&lt;/code&gt; 是在这里被拿走的，罪魁祸首并非 &lt;code&gt;schedule()&lt;/code&gt;。人家只是受害者。调整一下顺序，最后再 &lt;code&gt;get()&lt;/code&gt;，问题就解决了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这两天学 Rust。现炒现卖一下，用 Rust 来写这个有 bug 的 &lt;code&gt;do_until&lt;/code&gt;，就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;rust&quot;&gt;&lt;table class=&quot;linenotable&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;linenos gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;state&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;State&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;impl&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Future&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// takes the ownership of self&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;_&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;self&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c&quot;&gt;// also takes the ownership of self&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;loop&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;mut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;futurator&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;invoke&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;action&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;nn&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;need_preempt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;now&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;.available&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;need_preempt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;._then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;cm&quot;&gt;/* */&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;编译的时候 rustc 就会出错：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;error[E0382]: use of moved value: `f`
 --&amp;gt; src/main.rs:19:9
   |
16 |     if (!seastar::need_preempt() &amp;amp;&amp;amp; f.available() &amp;amp;&amp;amp; f.get()) {
   |                                                      -- value moved here
17 |       return now();
18 |     }
19 |     if (!f.available() || seastar::need_preempt()) {
   |          ^^ value used here after move
   |
  = note: move occurs because `f` has type `Future`, which does not implement
  the `Copy` trait&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;顿时有弃暗投明的冲动。&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="c++" /><category term="seastar" /><summary type="html">seastar::future 在 get() 之后就像被掏空了一样。</summary></entry><entry><title type="html">求值的顺序</title><link href="https://blog.k3fu.xyz/2020/10/12/order-of-evaluation.html" rel="alternate" type="text/html" title="求值的顺序" /><published>2020-10-12T00:00:00+00:00</published><updated>2020-10-12T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/10/12/order-of-evaluation</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/10/12/order-of-evaluation.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;用 Seastar 的时候，常常需要推迟一个对象的析构。于是问题来了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;平时，我们这样写程序：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是用 Seastar 的话，因为 &lt;code&gt;get_root()&lt;/code&gt; 可能会阻塞，我们可能可以把代码写成下面这样：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么既然 &lt;code&gt;get_root()&lt;/code&gt; 是异步的，那么等到调用 &lt;code&gt;then()&lt;/code&gt; 的时候，&lt;code&gt;f&lt;/code&gt; 会不会已经析构了呢？我们是不是应该这么写？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;future&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;seastar&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;do_with&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;move&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;get_root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;then&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Node&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
      &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;root&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;scan&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里就是例子：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;foo_t&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;foo_t&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;func(&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;)&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cout&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gen(&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;)&quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;endl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;foo_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;的输出是:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;func(1)
gen(2)
func(2)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;由此可知，&lt;code&gt;gen(2)&lt;/code&gt; 是在 &lt;code&gt;func(1)&lt;/code&gt; 返回之后才调用的。 而 &lt;code&gt;get_root()&lt;/code&gt; 里面的代码如果是异步调用的话，可能在 &lt;code&gt;scan()&lt;/code&gt; 返回的时候也还没有“完成”。因为异步调用返回的是一个 &lt;code&gt;future&lt;/code&gt; ，如果 future state 当时还没有准备好，那么 &lt;code&gt;.then(func)&lt;/code&gt; 则会把 &lt;code&gt;func&lt;/code&gt; 包装成一个 task 等待调度。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是从 C&amp;#43;&amp;#43; 的角度来说呢？简化版本的代码中，有这么个表达式&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;foo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;它用来模拟 Seastar 里面 &lt;code&gt;.then()&lt;/code&gt; 的调用，方便理解求值的先后顺序。很明显，这里的 AST 的树根是个函数调用。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-9285d44a0dc2f44729db42b65a8b841d.png&quot; alt=&quot;Diagram&quot; width=&quot;630&quot; height=&quot;210&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;n4659 中， &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf&quot;&gt;expr.call&lt;/a&gt; 一节说道&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A function call is a postfix expression followed by parentheses containing a possibly empty, comma-separated list of &lt;em&gt;initializer-clauses&lt;/em&gt; which constitute the arguments to the function.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;接着标准规定了函数参数的求值顺序&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;em&gt;postfix-expression&lt;/em&gt; is sequenced before each &lt;em&gt;expression&lt;/em&gt; in the &lt;em&gt;expression-list&lt;/em&gt; and any default argument. The initialization of a parameter, including every associated value computation and side effect, is indeterminately sequenced with respect to that of any other parameter.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;用&lt;a href=&quot;https://en.cppreference.com/w/cpp/language/eval_order&quot;&gt;通俗易懂的话&lt;/a&gt;，就是：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When calling a function (whether or not the function is inline, and whether or not explicit function call syntax is used), every value computation and side effect associated with any argument expression, or with the postfix expression designating the called function, is sequenced before execution of every expression or statement in the body of the called function.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以，我们这个例子里面 &lt;code&gt;.then()&lt;/code&gt; 有两个参数，在真正调用 &lt;code&gt;.then()&lt;/code&gt; 之前，我们必须先对这两个参数求值。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个是 &lt;code&gt;this&lt;/code&gt;，它的值由 &lt;code&gt;get_root()&lt;/code&gt; 返回，为了得到这个参数必须对 &lt;code&gt;get_root()&lt;/code&gt; 求值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一个是一个 lambda 表达式，它的值由 capture list 和后面的函数体决定。但是请注意，要对这个表达式求值并不需要执行这个 lambda 表达式。它的值就是一个 lambda 表达式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以在调用 &lt;code&gt;.then()&lt;/code&gt; 之前，&lt;code&gt;f&lt;/code&gt; 的值就被稳妥地保存在第二个参数里面了，并且因为我们是 capture by move，所以第二个参数析构的时候，&lt;code&gt;f&lt;/code&gt; 也会随之而去。我们并不需要为它专门做一个 &lt;code&gt;seastar::do_with()&lt;/code&gt; 用智能指针保存它的值，延长其生命周期。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;回到一开始的 &lt;code&gt;foo_t&lt;/code&gt; 的那个例子，其实它有些许误导。我们按照结合律，可以把这个表达式拆成这么几个&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-372ff6cf49d5dafdd439f671752671ca.png&quot; alt=&quot;Diagram&quot; width=&quot;550&quot; height=&quot;196&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以对第二个 &lt;code&gt;.func()&lt;/code&gt; 求值，我们必须先对 &lt;code&gt;foo.func(1)&lt;/code&gt; 和 &lt;code&gt;gen(2)&lt;/code&gt; 求值，当然它们的顺序不一定。然后再调用 &lt;code&gt;foo.func(2)&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是和前文 &lt;code&gt;scan()&lt;/code&gt; 的例子不一样，&lt;code&gt;scan()&lt;/code&gt; 的第二个参数是个 lambda 表达式，为了对它求值，我们必须初始化 lambda 表达式中的 capture 列表。所以看上去好像有“写在后面的代码反而在之前执行了”的错觉。但是如果把语法关系理清楚，这个问题就迎刃而解了。&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="c++" /><category term="seastar" /><summary type="html">用 Seastar 的时候，常常需要推迟一个对象的析构。于是问题来了。</summary></entry><entry><title type="html">Read the Docs 之路</title><link href="https://blog.k3fu.xyz/2020/10/02/road-to-rtd.html" rel="alternate" type="text/html" title="Read the Docs 之路" /><published>2020-10-02T00:00:00+00:00</published><updated>2020-10-02T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/10/02/road-to-rtd</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/10/02/road-to-rtd.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最近为了支持多单词的准确搜索，把 Ceph 的文档编译和 host 转移到了 &lt;a href=&quot;https://readthedocs.org&quot;&gt;Read the Docs&lt;/a&gt; 上。但是还有一些问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div id=&quot;toc&quot; class=&quot;toc&quot;&gt;
&lt;div id=&quot;toctitle&quot; class=&quot;title&quot;&gt;&lt;/div&gt;
&lt;ul class=&quot;sectlevel1&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#ceph-里的-api-文档&quot;&gt;Ceph 里的 API 文档&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#sphinx-的搜索&quot;&gt;Sphinx 的搜索&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#假的-librados&quot;&gt;假的 librados&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#方案&quot;&gt;方案&lt;/a&gt;
&lt;ul class=&quot;sectlevel2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#sphinx-能看见的预处理结果&quot;&gt;Sphinx 能看见的预处理结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#加入-stub-函数&quot;&gt;加入 stub 函数&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#浏览器能看到的&quot;&gt;浏览器能看到的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#后记&quot;&gt;后记&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;ceph-里的-api-文档&quot;&gt;Ceph 里的 API 文档&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ceph 用 &lt;a href=&quot;https://www.sphinx-doc.org/&quot;&gt;Sphinx&lt;/a&gt; 编译文档。它作为一个平台提供 librados，让大家可以用它写程序。librados 有各种语言的绑定，其中一些有对应的文档：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C: 用 &lt;a href=&quot;https://breathe.readthedocs.io/&quot;&gt;Breathe&lt;/a&gt; 的 &lt;a href=&quot;https://breathe.readthedocs.io/en/latest/directives.html#autodoxygenfile&quot;&gt;autodoxygenfile&lt;/a&gt; directive&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;C&amp;#43;&amp;#43;: 还没有加上去。不过我觉得用 Breathe 和 Doxygen 的组合应该就够了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python: Sphinx 有内置的支持，即 &lt;a href=&quot;https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html&quot;&gt;sphinx.ext.autodoc&lt;/a&gt; 扩展。我们主要用它的 &lt;code&gt;automethod&lt;/code&gt; directive&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenAPI: 用 &lt;a href=&quot;https://github.com/sphinx-contrib/openapi&quot;&gt;sphinxcontrib.openapi&lt;/a&gt; 提供的 &lt;code&gt;openapi&lt;/code&gt; directive&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;sphinx-的搜索&quot;&gt;Sphinx 的搜索&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sphinx 内置有搜索功能，它也支持多词搜索，但是通常我们希望搜索 source code 的话，Sphinx 会返回所有包含 source code 的文档，即使文档里面出现的是 &quot;code source&quot; 或者 &quot;source of code&quot;。换言之，它不是我们习惯上的多词搜索。这个问题其他开发者也碰到了，在 Sphinx 上有相关的 &lt;a href=&quot;https://github.com/sphinx-doc/sphinx/issues/3301&quot;&gt;issue&lt;/a&gt;。我研究了一下，这个问题在于 Sphinx 搜索的实现比较直接。它分这么几步&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;分词。每种语言的分词都不一样。值得一提的是，中文分词用的是&lt;a href=&quot;https://github.com/fxsjy/jieba&quot;&gt;“结巴”分词&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;逐词预处理，用对应语言的 stemming 规则把词归一化。英语的实现可以参考&lt;a href=&quot;https://github.com/sphinx-doc/sphinx/blob/master/sphinx/search/en.py&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;去掉后缀。比如说 apples 这个词就会变成 apple。civilize 则会变成 civil。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;去掉常见的介词、连词和代词。比如说 at、and 和 they 就会被去掉。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把索引关系加入倒排表。组织成一个大数据结构，保存在磁盘上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在搜索的时候，javascript 会直接从这个表里面找。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以可以想见，如果我们搜索 &quot;fuse support&quot; 想看看 Ceph 对 FUSE 的支持，它会返回 mount.fuse.ceph 的 &lt;a href=&quot;https://docs.ceph.com/en/latest/man/8/mount.fuse.ceph/&quot;&gt;manpage&lt;/a&gt;。这虽然也不算离谱，但是里面出现的 support 是这么一句话&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The old format /etc/fstab entries are also supported:&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;通篇没有出现 &quot;fuse support&quot; 这个序列。搜索返回了 32 篇文章，后 31 篇 文章被检索到的关键字就是 unsupported。这个很可能不是我们想要的。而 RTD 的多词搜索的&lt;a href=&quot;https://docs.ceph.com/en/latest/search/?q=fuse+support&quot;&gt;结果&lt;/a&gt;要好很多。对于不挑剔的读者基本上够用了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那为什么要纠结多词搜索呢？因为我们很多命令是多个单词构成的。比如说&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shell&quot;&gt;ceph &lt;span class=&quot;nb&quot;&gt;df&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;要是用户想搜索 &quot;ceph df&quot;，多词搜索要是能精确匹配，问题不就能解决了吗？那有没有其他办法呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;google 的站内搜索。但是 google 是一个商业公司。有的人可能会浑身不自在，如果他用一个广告公司的搜索。虽然在这个世界上，我们和商业公司有千丝万缕的联系，但是，哎。让我们留一点理想主义的念想吧。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接用 Read the Docs 的一揽子方案。它和 &lt;a href=&quot;https://travis-ci.org&quot;&gt;travis&lt;/a&gt; 这些服务很像，不仅内置了 CI 的功能，也能帮着 host 这些静态页面。对我们很合适。但是它的 build 流程是很死的。看看它的&lt;a href=&quot;https://docs.readthedocs.io/en/stable/config-file/v2.html&quot;&gt;配置文件&lt;/a&gt;就知道了。这是为一个纯 Python 项目度身定制的。我们后文分析这个限制的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他 sphinx search plugin。找了一圈，没有不收费的。功能比较好的也需要自己搭建 &lt;a href=&quot;https://www.elastic.co/products/elasticsearch&quot;&gt;Elasticsearch&lt;/a&gt;。RTD 开源了他们的&lt;a href=&quot;https://github.com/readthedocs/readthedocs-sphinx-search&quot;&gt;方案&lt;/a&gt;。但是一想到要挠我们实验室小哥的门，我就知趣地把爪子收起来了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;假的-librados&quot;&gt;假的 librados&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Read the Docs 的搜索不错，但是它的限制也很明显。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只能通过 &lt;code&gt;requirements.txt&lt;/code&gt; 安装第三方依赖。那么 &lt;code&gt;requirements.txt&lt;/code&gt; 到底是啥呢？它是 pip 用来给 &lt;code&gt;pip install&lt;/code&gt; 传参数的。 &lt;a href=&quot;https://pip.pypa.io/en/stable/reference/pip_install/#requirements-file-format&quot;&gt;文档&lt;/a&gt;说得明白。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也可以用 setuptools 或者 pip 安装源码里面的 Python 项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;没有预处理阶段。&lt;code&gt;pip&lt;/code&gt; 装好了，直接就是 &lt;code&gt;sphinx-build&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们回到各种语言的绑定：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;C: &lt;a href=&quot;https://breathe.readthedocs.io/&quot;&gt;Breathe&lt;/a&gt; 其实本身并不能解析 C 代码里面的注释，也不能理解头文件。它事实上担当的角色是 Doxygen 产生的 XML 文件到 Sphinx 中间的桥梁。但是如果这些 XML 不存在，巧妇难为无米之炊。所以它会调用用 Doxygen 预处理一下指定的文件。但是问题来了，doxygen 怎么安装呢？它是一个 C++ 的项目。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python: &lt;code&gt;automethod&lt;/code&gt; 读取制定方法的 docstring，产生 Sphinx 的文档。最近一部分代码用上了 &lt;a href=&quot;https://www.python.org/dev/peps/pep-0484/&quot;&gt;PEP484&lt;/a&gt; 风格的标注，所以我们也用 &lt;a href=&quot;https://github.com/agronholm/sphinx-autodoc-typehints&quot;&gt;sphinx_autodoc_typehints&lt;/a&gt; 来把这些标注变成 Sphinx 文档。这两种办法都要求 Sphinx 的 Python 环境能访问被处理的 Python 扩展 (模块)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OpenAPI: &lt;code&gt;openapi&lt;/code&gt; 读取的是一个 yaml 文件。我们目前解决这个问题的办法是直接把这个文件放到了 repo 里面。但是大家都知道这个 yaml 文件其实是从代码产生的。把预处理的结果放到 repo 里面显然不是一个最好的方案，在现阶段这是一个折中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是对于 Python API 来说，以 python-rados 为例，它是用 &lt;a href=&quot;https://cython.org&quot;&gt;Cython&lt;/a&gt; 编写的 Python 扩展，它的底层则是 librados C API。我们编译文档的时候其实并不需要一个功能上完备的 librados，我们只需要让 sphinx 能导入 python-rados 就行了。sphinx 并不会真正运行 python-rados 的函数，它只会读取代码里面的元数据。所以 Ceph 里面用了一个比较取巧的&lt;a href=&quot;https://github.com/ceph/ceph/blob/master/admin/build-doc&quot;&gt;方法&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;为 &lt;code&gt;lib/librados.so&lt;/code&gt; 建立一个空链接，指向 &lt;code&gt;lib/librados.so.1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 GCC 编译一个空的 &lt;code&gt;lib/librados.so.1&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;pip&lt;/code&gt; 安装 python-rados，pip 会自动执行 &lt;code&gt;setup.py&lt;/code&gt; 脚本，后者会&lt;/p&gt;
&lt;div class=&quot;olist loweralpha&quot;&gt;
&lt;ol class=&quot;loweralpha&quot; type=&quot;a&quot;&gt;
&lt;li&gt;
&lt;p&gt;调用 Cython 编译对应的 rados.pyx，生成 C 代码，然后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GCC 继续用指定源代码里的头文件目录，刚才生成的空动态链接库，生成 rados 的 Python 扩展。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;至此，rados 的 python 扩展编译好了。但是它链接的 &lt;code&gt;librados.so&lt;/code&gt; 只是个空壳子。如果有人希望 &lt;code&gt;import rados&lt;/code&gt; ，一定会出错。因为那些符号都不存在呢。所以我们用 &lt;code&gt;nm&lt;/code&gt; 分析这个 Python extension，找出它引用的所有符号，看看它有没有 librados  API 的前缀。把这些符号，其实也是函数，统一写成 &lt;code&gt;void func(void) {}&lt;/code&gt; 的样子，用管道交给 GCC 生成新的 &lt;code&gt;lib/librados.so.1&lt;/code&gt; 。虽然它是假的，但是至少 &lt;code&gt;import&lt;/code&gt; 的时候就不会出错了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-575fae6deb6a6d2a191da4c460feaf0f.png&quot; alt=&quot;Diagram&quot; width=&quot;1010&quot; height=&quot;336&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;OpenAPI 文档的 yaml 文件的产生过程要简单很多，但是也需要使用我们自己编写的 python 脚本。但是 RTD 的 &lt;code&gt;requirements.txt&lt;/code&gt; 没法实现这么复杂的预处理逻辑。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;方案&quot;&gt;方案&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;sphinx-能看见的预处理结果&quot;&gt;Sphinx 能看见的预处理结果&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了能有一个 librados，我们可以在 &lt;a href=&quot;https://pypi.org&quot;&gt;PyPI&lt;/a&gt; 注册一个项目，让 Ceph 发布新版本的时候也更新它。同时，我们的文档编译流程也能直接从 PyPI 安装 python-rados。openapi.yaml 其实也可以放在这里面。具体说就是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;注册 python-rados 项目。其他 Python 绑定也同理，比如 cephfs、rgw、rbd。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一旦修改任何 Python 绑定的 pyx，就需要发布一个新版。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让 &lt;code&gt;ceph/admin/doc-read-the-docs.txt&lt;/code&gt; 安装 python-rados， python-cephfs 等。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;加入-stub-函数&quot;&gt;加入 stub 函数&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在编译文档的时候，在 &lt;code&gt;rados.pyx&lt;/code&gt; 中实现所有使用到的 C 函数。不过需要注意，这些函数也应该暴露出来给 python-cephfs 它们用。当然，只有在编译文档的时候才这么做。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;浏览器能看到的&quot;&gt;浏览器能看到的&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外一个办法就是保留我们的 CI 流程，让它编译 API 相关的文档，然后让 RTD 的文档引用我们自己编译的文档。这需要&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;新建一个域名，专门用来保存 API 文档。题外话，它也可以用来保存 CI 产生的文档。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改文档里面所有引用 API 文档的超链接，加入条件：&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是 RTD 编译的话，就链接到刚才的域名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其他情况，就使用相对路径&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;最后采用的是 stub 函数的方案。毕竟用 Cython 写个假的实现相对比较容易。同时，因为我们有很多 tell 命令，它们中有的是 C 实现的，有的是 Python 实现的。前者有固定格式的头文件来描述命令的参数，后者是用 type annotation 来标记参数类型。之前为了产生对应的文档，我们有专门的 Python 脚本。但是因为 Read the Docs 不支持这样的流程。所以为了能从 C 代码和 Python 代码生成文档，专门写了一个 sphinx 扩展。好在 sphinx 允许在扩展里面直接插入 reStructuredText 风格的 markup，这样搭配 Jinja 就方便多了。有点 PHP 的感觉，吼吼。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><category term="ci" /><summary type="html">最近为了支持多单词的准确搜索，把 Ceph 的文档编译和 host 转移到了 Read the Docs 上。但是还有一些问题。</summary></entry></feed>