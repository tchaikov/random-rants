<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.1.1">Jekyll</generator><link href="https://blog.k3fu.xyz/feed.xml" rel="self" type="application/atom+xml" /><link href="https://blog.k3fu.xyz/" rel="alternate" type="text/html" hreflang="en" /><updated>2020-09-29T09:00:40+00:00</updated><id>https://blog.k3fu.xyz/feed.xml</id><title type="html">some random rants</title><subtitle>我的学习记录</subtitle><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><entry><title type="html">RADOS 里的顺序</title><link href="https://blog.k3fu.xyz/2020/09/20/out-of-order-in-ceph.html" rel="alternate" type="text/html" title="RADOS 里的顺序" /><published>2020-09-20T00:00:00+00:00</published><updated>2020-09-20T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/09/20/out-of-order-in-ceph</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/09/20/out-of-order-in-ceph.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;RADOS 是 Ceph 的基础。而它在不同的上下文中有不同的含义&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;集群。比如说数据保存在 RADOS 集群里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;API。比如说，大家提到 librados，可能就是说用来访问 RADOS 集群的 C API。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RADOS 协议。librados 客户端要和集群通信，就基于这个协议。它包含着身份验证，鉴权，控制面的操作，以及 I/O，等等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个叫做 &lt;code&gt;rados&lt;/code&gt; 命令行工具。它可以说是 Ceph 的瑞士军刀。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这次我们从协议出发，讨论一下 OSD 对读写顺序的处理。它和前面的 &lt;a href=&quot;https://blog.k3fu.xyz/arch/2020/08/10/memory-ordering.html&quot;&gt;多核和顺序&lt;/a&gt; 提到的乱序访问内存的问题非常相似。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;客户端如果要访问集群中的数据，就需要向相关的 OSD 发送 &lt;code&gt;MOSDOp&lt;/code&gt; 请求，OSD 则会用 &lt;code&gt;MOSDOpReply&lt;/code&gt; 进行回应。它们两个是 RADOS 协议用来传输数据的很重要的消息类型。每个 &lt;code&gt;MOSDOp&lt;/code&gt; 都包含&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;指定要访问的 &lt;code&gt;hobject_t&lt;/code&gt;。它包含 pool ，对象的名字，对象的 snapid。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一系列 &lt;code&gt;OSDOp&lt;/code&gt;，这些 op 就像是一系列指令，不过它们的操作的对象是同一个。要是有写操作，那么写入的数据也放在这个 &lt;code&gt;MOSDOp&lt;/code&gt; 里面，按照先后顺序，放在同一个 payload 里面，解码的时候分给各自的 op。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;librados 为客户端提供了两种调用方式&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步调用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，同步调用很好理解。客户端在发送完请求之后，就开始等待，直到收到 OSD 的回应。但是如果客户端选择使用异步调用的话，它就可以同时发送多个 &lt;code&gt;MOSDOp&lt;/code&gt;，而不用等待之前的请求返回。从 OSD 的角度来看，它有机会在同一时刻看到同一客户端先后发来的多个请求。不管如何，OSD 都有义务顺序执行这些请求，让客户端收到 &lt;code&gt;MOSDOpReply&lt;/code&gt; 的顺序和它当初发送对应 &lt;code&gt;MOSDOp&lt;/code&gt; 的顺序一致。Ceph 有个专门的测试，叫做 &lt;code&gt;ceph_test_rados&lt;/code&gt;。这个测试会检查客户端收到的回应的顺序是不是对应请求发出的顺序。换言之，如果某个客户端的请求序列是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;req(write(offset=601750, len=535546, payload))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;req(write(offset=1929910, len=271840, payload))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;req(setxattr(&quot;header&quot;, payload), truncate(size))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;req(read(offset=0, len=1))&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么，OSD 的返回序列也应该是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ack(write)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ack(write)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ack([setxattr,truncate])&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;ack(read)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;虽然 Ceph 也可以不坚持顺序。我的理解是，sequential consistency 是便于客户端编程的一个模型，所以 Ceph 选择顺序返回是很自然的事情。后来想了一下，对于 RBD 来说，如果系统先发了一个写请求，然后再发一个读请求，那么我们一定要先完成写请求吗？答案是&amp;#8230;&amp;#8203;&amp;#8230;&amp;#8203;哪有那么巧啊！&quot;`我们`&quot;在这里其实是某个特定的 OSD，这两个时间上相邻的请求，如果不是访问同一个对象，那么怎么会这么巧，这两个对象都被分配到同一个 OSD，而且先后被访问到。就好像你和大学室友在市郊的加油站排队的时候遇见了。如果是同一个对象，那么问题来了。RBD 的使用者为什么会有这种需求呢？先写一块数据，然后不等写完，开始读同一块数据，而且不关心这个读到的数据是不是之前写下去的。RBD 使用者一般来说 Linux 的本地文件系统，它们对一致性还是有要求的，所以一般不会忍受这种脏数据。所以，按照 RBD 的需求分析，这种 load-store 的乱序执行是没有意义的，而且是错误的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 OSD 的这一边，它可能会看到多个 &lt;code&gt;MOSDOp&lt;/code&gt; 同时访问一个对象。这些请求可能来自同一客户端，也可能来自不同的客户端。在保证原子性的前提下，为了提高并发度，我们要区别对待这些 &lt;code&gt;MOSDOp&lt;/code&gt; 对应的事务。事务可以分为三种：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只读。很明显这些事务不会改变对象本身，所以它们可以同时进行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只写。提到并发写，有人可能会有点犹豫。不过请不用担心，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读然后写或者写然后读。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果好几个连续的 &lt;code&gt;MOSDOp&lt;/code&gt; 都只进行读操作，那么我们是可以同时处理它们的。只需要按照顺序把它们依次发送给 object store 就可以了。 我们把这叫做 pipelined read:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-a99224d4dd4db9222fdf1fa7b08d2433.png&quot; alt=&quot;Diagram&quot; width=&quot;270&quot; height=&quot;196&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们甚至可以把这些读请求一起发给下面的 object store，让它酌情同步处理。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;和 pipelined write:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-9f3a67ce734c30d7fc8ce845c11c280f.png&quot; alt=&quot;Diagram&quot; width=&quot;270&quot; height=&quot;196&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;object store 自然会把它们序列化，依次处理。因为在 object store 里面也需要多个步骤才能完成一个写操作，所以把它当成一个流水线，提交多个操作更有利于提高并发。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是如果某个请求里面既有写，又有读呢？感受一下：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-0f01e1970eed4de70052781f9416b6bb.png&quot; alt=&quot;Diagram&quot; width=&quot;270&quot; height=&quot;196&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;第二个事务中所有的请求都是读操作。在客户端发送消息的顺序上，这个只读事务排在第一个只写的事务之后。 TCP 保证了 OSD 也是按照发送的顺序收到这两个消息的，但是在 OSD 这边，如果不加以限制的话，或者允许乱序执行的话，就会出现 store-load 重排的情况。因为在 Ceph 里面，读操作一般来说比写操作要快，因为读操作运气好的话，直接在缓存里面就能找到想要的数据，直接返回了。最不济，通过本机读几次磁盘，也能找到想要的数据。但是写操作不仅仅需要读本机磁盘，获得对象的元数据，还需要写本地磁盘，提交分布式事务，让其他副本也持久化，所以它的延迟比读请求是相对高一些的。如果我们放任自流，让两者的延迟决定谁先返回，不仅仅返回的顺序不对，返回的数据也可能是不正确的。如果我们希望实现一个严格的 sequential consistency 的系统，那么 &lt;code&gt;read.2&lt;/code&gt; 就有义务体现 &lt;code&gt;write.1&lt;/code&gt; 的结果。最简单的办法就是加上一个 sfence，保证 &lt;code&gt;read.2&lt;/code&gt; 之前的写操作的事务提交完成。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-5a3da3419ca32928b421e58a0b48950c.png&quot; alt=&quot;Diagram&quot; width=&quot;350&quot; height=&quot;154&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;解决了 store-load 重排，那么 load-store 呢？我们允许在 &lt;code&gt;read.2&lt;/code&gt; 仍然进行的时候，开始执行 &lt;code&gt;write.3&lt;/code&gt; 吗？这取决于下面 object store 的处理顺序。我们假设这里使用的是 seastore。根据现在 seastore 的设计，要读取某个对象的指定 extent，需要&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;先根据索引 onode block 的 b+ 树，找到这个对象 onode 所在的 block&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个对象自己又有一个 b+ 树管理各自的 extent，如果运气好的话，b+ 树所有的叶子节点就内置在 onode 的 block 里面，但是如果这个对象比较大，或者 extent 的 b+ 树还没有来得及压缩，那么它就会有一些 extent 是需要再查询几个中间节点才能知道具体的逻辑地址的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其实上层根据逻辑地址访问下面的物理介质，都需要先把逻辑地址翻译成物理地址，这个过程也需要查索引，也就是要用 LBA 树来查找。而 LBA 树的节点也是不一定都在内存里面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 &lt;code&gt;write.3&lt;/code&gt; 所对应的 extent 相关的索引信息说不定就在内存里面，可以很快的找到，从而开始写日志。同时呢，&lt;code&gt;read.2&lt;/code&gt; 虽然身为读操作，有可能就没那么好运，需要读多次磁盘，才能找到对应的物理地址。所以我们无法保证读操作肯定是比写操作先完成的，即使读操作比写操作先开始。而且，这里的 &lt;code&gt;read.2&lt;/code&gt; 和 &lt;code&gt;write.3&lt;/code&gt; 都各自包含了多个操作，任何一个操作都会成为瓶颈。所以在某种极端情况下可能会是这样&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-2046fc170102da8f2c2fadf620658ede.png&quot; alt=&quot;Diagram&quot; width=&quot;570&quot; height=&quot;266&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在这个捏造的例子里面，&lt;code&gt;read.2.1&lt;/code&gt; 拖慢了整个事务的后腿，&lt;code&gt;read.2&lt;/code&gt; 是在 &lt;code&gt;write.3&lt;/code&gt; 之前开始的，但却在 &lt;code&gt;write.3&lt;/code&gt; 之后完成。这对于期望 sequential consistency 客户端显然无法接受。同时，我们还能想象一个更复杂的场景，因为每个读请求都会指定一个区间，告诉 OSD 自己希望读的偏移量和长度。但是这个区间可能会映射到对象的多个 extent，而每个 extent 的读延迟可能会不一样。倘若 &lt;code&gt;read.2.1&lt;/code&gt; 指定的区间正好映射到某个 extent，而这个 extent 又正好和 &lt;code&gt;write.3.1&lt;/code&gt; 所写的 extent 有重合呢？而且，请注意，例子里面 &lt;code&gt;write.3&lt;/code&gt; 先结束，它的事务提交的时候，刷新了 OSD 内存里面所有相关的 extent 对应 block 的 cache。所以 &lt;code&gt;read.2.1&lt;/code&gt; 有可能读到的是 &lt;code&gt;write.3&lt;/code&gt; 所写的内容。更可怕的是，因为 &lt;code&gt;read.2&lt;/code&gt; 读的是多个 extent，返回的 extent 中有的可能是新的，有的则是则是老的。所以这里还有一致性的问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-c1e464af72f04d738cd8212925568050.png&quot; alt=&quot;Diagram&quot; width=&quot;290&quot; height=&quot;280&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;简单粗暴的办法就是在 &lt;code&gt;read.2&lt;/code&gt; 之后直接加一个 lfence，确保所有的读请求都完成，防止乱序的发送，也避免读到不一致的数据。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-c0e129fb86a39d2812f1a7d014909b72.png&quot; alt=&quot;Diagram&quot; width=&quot;440&quot; height=&quot;154&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于 erasure coded pool 这个问题更复杂一些。如果对象保存在 erasure coded pool 里面，Ceph 在往里面写数据的时候，会&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;把数据拆开成 &lt;code&gt;k&lt;/code&gt; 等份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再根据选择的算法计算出 &lt;code&gt;m&lt;/code&gt; 个校验块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再把这些数据发往 m + k 个 OSD&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;倘若写操作的偏移量不是 m x chunk size 对齐的，那么这个写操作就会升级成 rmw (read modifiy write) 操作，因为它需要把自己少的那部分先读出来，解码，然后再和自己的没对齐的部分拼起来再重新拆分编码。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-4e96006f417439ae3035af811f4d00f9.png&quot; alt=&quot;Diagram&quot; width=&quot;610&quot; height=&quot;196&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在上图中，在编码的时候产生了 6 块数据，其中 4 块是原始数据，2 块是校验数据。为了修改这个对象，而修改的位置正好落在了 3 里面，我们必须把整个数据都读进来，然后再把写请求的数据嫁接到 3 的对应位置，重新编码。得到被修改过的 3 和全新 4，以及融合了老数据和新数据的 5 和 6。正因为 erasure coded 的写操作事实上包含了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;相邻区域的读操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指定区域的写操作&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以它无法和其他的写操作在对象层面上同时进行。除非我们实现了更细粒度的访问隔离控制，确保事务的独立性。当然我们目前没有这么做并不意味着不可能，而是因为这样会比较复杂。因为每个写的事务都会涉及多个 extent。extent 可能会含有多个 stripe。两个写事务之间没有读写依赖的话，那么完全可以一起执行。也就是说，如果事务 A 不会写到事务 B 读取的数据，反之亦然，那么我们就可以认为两者是独立的。然是这需要在往下发送写请求之前，先把这些关系先分析清楚才能决定。这个可能太复杂了。而且得不偿失，以 RBD 为例，允许并发写一个 block 的请求的可能并不大。所以我们还是选择直接加 lfence。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 crimson 里面使用了一个 &lt;code&gt;shared_mutex&lt;/code&gt; 的变形 &lt;code&gt;tri_mutex&lt;/code&gt; 来解决这个问题。常规的 &lt;code&gt;shared_mutex&lt;/code&gt; 是一个读写锁，允许多个读者，或者单个写者。&lt;code&gt;tri_mutex&lt;/code&gt; 借用了 mutex 的名字，其实它实现的是自动添加 sfence 和 lfence 的功能。它维护着一个等待者的队列，如果有新的请求进来，&lt;code&gt;tri_mutex&lt;/code&gt; 就看看这个请求和当前的请求是不是能一起执行，如果不能的话，就进入队列，等到现在所有正在执行的请求结束之后才能开始；如果可以的话，就直接放行。从前面的讨论，可以知道我们有下面这个规则：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读操作可以和读操作并行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写操作可以和写操作并行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RMW 不能和任何操作并行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="ceph" /><summary type="html">RADOS 是 Ceph 的基础。而它在不同的上下文中有不同的含义</summary></entry><entry><title type="html">博客维护指南</title><link href="https://blog.k3fu.xyz/2020/09/05/my-blog.html" rel="alternate" type="text/html" title="博客维护指南" /><published>2020-09-05T00:00:00+00:00</published><updated>2020-09-05T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/09/05/my-blog</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/09/05/my-blog.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我对 web 开发和 ruby 不熟悉，磕磕碰碰用下面的技术和工具把博客搭起来了：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;AsciiDoc&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;标准化的 markup 语言。和各家 markdown 不一样，它有标准化的工具链。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;AsciiDoctor&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;AsciiDoc 的参考实现。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;jekyll-asciidoc&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;jekyll 的 AsciiDoc 插件。通过它就能用 AsciiDoc 写网站了。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;jekyll-text-theme&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;一开始用的 minima 主题虽然开箱即用，但是这个主题的红色主题一下子让人有些亲近感。忍不住还是套用上了。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外做了一些修改：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;jekyll-asciidoc &lt;a href=&quot;https://github.com/asciidoctor/jekyll-asciidoc/issues/230&quot;&gt;没法支持一些插件&lt;/a&gt;。
至少用 &lt;a href=&quot;https://github.com/asciidoctor/jekyll-asciidoc/issues/230&quot;&gt;这个补丁&lt;/a&gt; 是修好了。
测试的时候如果用自己本地的 jekyll-asciidoc 的话，需要参考 &lt;a href=&quot;https://bundler.io/guides/git.html#local&quot;&gt;bundler 的文档&lt;/a&gt;，
让 bundler 用本地 repo，而不是 RubyGems 上的版本。这也是为什么我用 Gemfile 管理 jekyll
插件的原因。感觉这样更接近 Ruby 一些，方便理解 bundler 是如何找到插件的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rouge-ruby/rouge&quot;&gt;rouge&lt;/a&gt; 的语法高亮在 &lt;a href=&quot;https://github.com/kitian616/jekyll-TeXt-theme&quot;&gt;jekyll-text-theme&lt;/a&gt; 中无法生效，因为后者没有定义一些 rouge 要的 CSS 规则。
所以从 minima 拷贝了一份 &lt;code&gt;_syntax-highlighting.scss&lt;/code&gt; 然后按照个人喜好改了一下，放到了 &lt;code&gt;_sass/custom.scss&lt;/code&gt;。网上也能找到好些好看的 rouge 语法高亮的主题。因为 rouge 高亮的 HTML 输出和 pygments 是兼容的，所以那些 pygments 的主题也可以拿来用。&lt;/p&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;其实之前并不知道应该用这个名字，只是觉得 text-theme 缺了这些定义，应该补上，是后来分析了它的 `assets/css/main.scss`，看着 `custom.scss` 的名字，找到它，发现这是个空的文件。才猜测这是给用户自定义的一个 stub。&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外，如果以后要加个插件或者其他 ruby 包，先修改 &lt;code&gt;Gemfile&lt;/code&gt;，然后&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shell&quot;&gt;bundle &lt;span class=&quot;nb&quot;&gt;install&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;就行了。&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="jekyll" /><summary type="html">我对 web 开发和 ruby 不熟悉，磕磕碰碰用下面的技术和工具把博客搭起来了：</summary></entry><entry><title type="html">TCP 长连接的最大个数</title><link href="https://blog.k3fu.xyz/2020/08/23/tcp-connections.html" rel="alternate" type="text/html" title="TCP 长连接的最大个数" /><published>2020-08-23T00:00:00+00:00</published><updated>2020-08-23T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/08/23/tcp-connections</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/08/23/tcp-connections.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;提个问题，单机单网卡最大对某个特定服务器 TCP 长连接的最大个数是多少？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;和平时一样，我们假设客户端是 Linux。这可能不是一个生造出来的问题，想一想，如果我们希望设计一个支持长连接的代理服务器呢？如果有海量的客户端希望连接被代理的服务器呢？或者说我们希望为用户提供实时的消息服务呢？这是一种 c1000k 问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们从 TCP 协议开始，慢慢往外推，到操作系统直到硬件。看看一路上都有哪些限制。我们可以假设服务器是个怪物，它在 TCP 的框架下面可以有无穷的计算能力和带宽，各种资源取之不尽用之不竭。那么问题到了 TCP。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;tcp&quot;&gt;TCP&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;数据库问题&quot;&gt;数据库问题&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有人说，这是个数据库问题。因为 TCP 实现为了区别 TCP 连接，用了个四元组标记每个 TCP 报文&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;source ip: 32 bit for IPv4&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;source port: 16 bit&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;destination ip: 16 bit (fixed)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;destination port: 32 bit for IPv4 (fixed)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以这四个数字合起来，就是数据库的复合主键。其中，目标服务的 IP 和端口都是固定的，所以我们只能从客户端这边发掘潜力：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;source-ip&quot;&gt;source ip&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;用 &lt;code&gt;iproute2&lt;/code&gt; 可以为同一块网卡添加多个 IP 地址。理论上说，这就是 2&lt;sup&gt;32&lt;/sup&gt; 个地址。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shell&quot;&gt;ip addr add &amp;lt;ip&amp;gt;/&amp;lt;network&amp;gt; dev &amp;lt;interface&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是要细究的话，IPv4 有很多特殊的地址段是不能使用或者使用上有限制的。如果服务器是对公网开放的，那么我们作为客户端就不能使用外部地址，只能用那些本地的地址，比如 &lt;code&gt;192.168.x.x&lt;/code&gt; 或者 &lt;code&gt;127.x.x.x&lt;/code&gt; 这些。如果使用 NAT/PAT 这类技术在内部实现 IP 复用，那么就需要把 NAT 设备的限制考虑进去了。不管怎么样，数量级差不多是这个。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;source-port&quot;&gt;source port&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于特定目标地址，本地端口可以选择的区间是由 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt&quot;&gt;net.ipv4.ip_local_port_range&lt;/a&gt; 决定的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ cat /proc/sys/net/ipv4/ip_local_port_range
32768	60999&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对于给定的目标地址，以及给定的本地 IP，可以发出的连接数量就是本地端口区间的大小。所以单个本地 IP 最多可以产生 65535 个 TCP 连接。为了打破这个限制，我们必须为网卡添加多个虚拟 IP。满打满算，这就是 2&lt;sup&gt;32+16&lt;/sup&gt; 个链接，约为 281万亿。打个比方，我想开个公司，先从员工的工号的编码方式开始计划！嗯，就用 IPv4 的地址和 16 位的端口号来吧，所以，我的公司最多支持 281万亿个员工。这个思路扩展性很好，很强大！但是每个人都得发工资啊，我陷入了沉思&amp;#8230;&amp;#8203;&amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;tcp-的运行时开销&quot;&gt;TCP 的运行时开销&lt;/h3&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;什么是-tcp-连接&quot;&gt;什么是 TCP 连接&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们熟知的三次握手就能建立一个 TCP 连接&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;SYN&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;等待对方回应 SYN/ACK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后回答 ACK&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一旦双方完成这个规定的礼仪，就可以说这个连接建立了。一旦两边接上头，剩下的事情就是运行时的开销。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;系统-tcp-协议栈&quot;&gt;系统 TCP 协议栈&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果服务使用系统的 TCP 协议栈，那么每个连接都需要占用一个文件描述符。回忆一下 &lt;code&gt;send()&lt;/code&gt; 和 &lt;code&gt;recv()&lt;/code&gt;，它们的第一个参数是 &lt;code&gt;socket&lt;/code&gt;，而&lt;code&gt;socket&lt;/code&gt; 可不就是个 &lt;code&gt;fd&lt;/code&gt; 嘛。所以操作系统文件描述符的最大值，这个全局的 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/sysctl/fs.txt&quot;&gt;设置&lt;/a&gt; 是 &lt;code&gt;fs.file-max&lt;/code&gt;。在我的 RHEL8 上，它的值是 &lt;code&gt;19603816&lt;/code&gt;，接近两千万了。如果我们希望用单进程实现这个服务，还需要改 &lt;code&gt;ulimit -n&lt;/code&gt; 的限制。当然，如果内存够大，多操作系统或者用容器化的实现，以及用多进程的实现都可以越过这些限制。代价就是更多的额外开销。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外，还需要关注协议栈用到的缓冲区，看看 &lt;code&gt;net.ipv4.tcp_wmem&lt;/code&gt; 和 &lt;code&gt;net.ipv4.tcp_rmem&lt;/code&gt;，在 RHEL8 上，它们的缺省大小分别是 85K 和 16K。设置都有三组数字，分别是下限、缺省值和上限。以及 &lt;code&gt;net.ipv4.tcp_mem&lt;/code&gt;，它控制着整个系统中所有 TCP 缓冲区的总大小的上限。这个设置表示的是内存页的数量，有三组数字，分别是下限、警戒值和上限。如果 TCP 缓冲空间总使用量达到上限之前，TCP 就会开始减少每个 TCP 连接缓冲区的分配。一旦达到上限，TCP 实现就开始丢包，希望减轻对内存系统的压力。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;shellsession&quot;&gt;$ grep . /proc/sys/net/ipv4/tcp*mem
/proc/sys/net/ipv4/tcp_mem:2295903	3061204	4591806
/proc/sys/net/ipv4/tcp_rmem:4096	87380	6291456
/proc/sys/net/ipv4/tcp_wmem:4096	16384	4194304&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以缺省设置下，最多使用 17G 内存，可以同时支持二百万以上的长连接。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Linux 下新的防火墙是使用 netfilter 实现的，如果开启了防火墙那么还需要关注&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.ip_conntrack_max&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.netfilter.ip_conntrack_max&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;netfilter 维护着一张哈希表用来跟踪所有的 TCP 连接，所以如果这张表放不下新的 TCP 连接，TCP 就会开始丢包。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;用户态-tcp-协议栈&quot;&gt;用户态 TCP 协议栈&lt;/h4&gt;

&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;带宽&quot;&gt;带宽&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;需要估计所有连接中活跃的比例，并且需要了解活跃连接需要的带宽是多少。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect3&quot;&gt;
&lt;h4 id=&quot;内存&quot;&gt;内存&lt;/h4&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面如果使用系统的 TCP/IP 栈，就需要为每个连接保证 &lt;code&gt;tcp_rmem.min&lt;/code&gt; + &lt;code&gt;tcp_wmem.min&lt;/code&gt; 的空间。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="networking" /><summary type="html">提个问题，单机单网卡最大对某个特定服务器 TCP 长连接的最大个数是多少？</summary></entry><entry><title type="html">多核和顺序</title><link href="https://blog.k3fu.xyz/2020/08/10/memory-ordering.html" rel="alternate" type="text/html" title="多核和顺序" /><published>2020-08-10T00:00:00+00:00</published><updated>2020-08-10T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/08/10/memory-ordering</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/08/10/memory-ordering.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;有浴缸的话，晚上到住处，有人可能会先放水，休息一下，简单吃点东西，然后呢，看看水温，差不多了洗个澡。用文艺的说法，这是生活的智慧。用体系结构的话说，这是乱序执行，使用了简单的调度算法。对单身汉来说，打乱计划，用不一样的顺序安排生活可以获得更高的效率。但是对多核程序来说，这其实不一定是好事。Jim Keller 打了个 &lt;a href=&quot;https://www.youtube.com/watch?v=Nb2tebYAaOA&quot;&gt;比方&lt;/a&gt;，他说计算机是在顺序的手法说一个故事，书里面有很多段落，段落是由句子构成的。读者可以画一个示意图，看看哪些段落和句子读的时候可以打乱顺序，而不改变表达的意思。比如&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;He is tall and smart and &amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以改成&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;He is smart and tall and &amp;#8230;&amp;#8203;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是这个句子如果打乱顺序的话，&quot;red&quot; 修饰的对象可能就不对了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Tall man who is wearing a red shirt&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;句子里面的元素之间有依赖关系。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;mutex-的问题&quot;&gt;mutex 的问题&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在多核环境下，要实现无锁编程或者尽量减少锁的使用，就不能用 mutex。其实，为了最大程度上优化，内核里的 mutex 在加锁的时候为了避免不必要的开销甚至分了 &lt;a href=&quot;https://www.kernel.org/doc/html/latest/locking/mutex-design.html&quot;&gt;三种情况&lt;/a&gt;：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;用 &lt;code&gt;lock cmpxchg()&lt;/code&gt; 指令，检查 mutex 的 owner 是否为空。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 mutex 的所有者正在运行，那么用 spin lock 等待它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把希望得到锁的线程阻塞，挂到等待队列。等到锁释放的时候，再调度自己。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这个机制叫做 &lt;code&gt;futex&lt;/code&gt;。在 Linux、NetBSD、FreeBSD、Windows 以及 &lt;a href=&quot;https://fuchsia.dev/fuchsia-src/concepts/kernel/concepts#futexes&quot;&gt;Zicron&lt;/a&gt; 中都实现了它。在 FreeBSD 中甚至有明确的 spin/sleep mutex 和 spin mutex 的 &lt;a href=&quot;https://www.freebsd.org/cgi/man.cgi?query=mutex&amp;amp;sektion=9&quot;&gt;概念&lt;/a&gt;。而在 Linux 中，futex 则是一个 &lt;a href=&quot;https://www.man7.org/linux/man-pages/man2/futex.2.html&quot;&gt;系统调用&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过，这些原语有两个问题&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;系统调用是个原罪。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;鉴权。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切换栈。即使 x86 使用 syscall 来实现系统调用，因为内核的地址空间和用户态程序不同，进入内核要求修改段寄存器，相应的带来 TLB 的刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存的刷新。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap04.html#tag_04_11&quot;&gt;POSIX.1&lt;/a&gt; 要求 mutex 同步内存。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前者大家做了很多实验，说明不管如何系统调用都比 &lt;code&gt;longjmp&lt;/code&gt; 的开销都要大很多。而今天我想把后者展开说一下。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;内存一致性&quot;&gt;内存一致性&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;首先，什么叫同步内存？在多核系统里面，每个核都有自己的一个小天地，为了加快对内存的访问，CPU 核在内存中间有多层的 cache。这个设计有点像现在大家说的朋友圈。根据一些权衡，这个朋友圈中的 cache 根据亲疏远近又分了三六九等，即 L1、L2 和 L3 缓存。通常每个核都有自己的 L1 cache，L1 其中又分数据 cache 和指令 cache。L2 不分这么细。L3 缓存由多个核共享。CPU 的片内总线设计很大程度就是各个核和片内缓存的关系网的拓扑。 和硬盘一样，cache 对内存的映射也是有最小单位的，硬盘的单位是 block，而 cache 的单位叫做 cache line。所以，从硬盘往内存读数据是以页为单位，通常大小是 4K。从内存往缓存读数据以 cache line 为单位，大小一般是 64 字节。另外，还有一种特殊的缓存叫 TLB，它是用来缓存线性地址到物理地址映射的页表。每个进程都有自己的地址空间，所以每个进程的 TLB 表项也各自不同。这里涉及内存的寻址、分配和管理，我们可以另外说。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;既然是缓存，就会有缓存的一系列问题&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;替换策略。比如大家耳熟能详的 LRU。再啰嗦一句，替换的最小单位也是 cache line。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写策略。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;write through 写数据的时候，数据不仅写进 cache，而且也同时刷新内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;write back 写数据的时候，数据仅仅写到 cache 里面，把相应的 cache line 标记成 dirty。在真正需要刷内存的时候再把数据&quot;`写回`&quot;去，一旦内存和缓存同步，这个 cache line 又是 clean 得了。因为 write back 性能比较好，缓存通常用它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性。既然每个核读写都是通过自己的 cache，而不是直接访问内存，那么怎么保证各个核看到的数据是一致的？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;mesi&quot;&gt;MESI&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里主要就写策略和一致性展开来说一下。为了解决一致性的问题，CPU 的设计者会用 &lt;a href=&quot;https://en.wikipedia.org/wiki/MESI_protocol&quot;&gt;MESI&lt;/a&gt; 的某种改进版来保证缓存之间的同步问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Modified 我的这份数据是被修改过的最新版。这个数据所在的 cache line 被标记成 dirty。这个状态要求其他人的状态是 &lt;code&gt;I&lt;/code&gt;。别人想要读这个数据，必须等我把它写回内存。一旦写回去，状态成为 &lt;code&gt;S&lt;/code&gt; 了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Exclusive 我的这个 cache line 别人都没有缓存，所以如果修改它的话，不会产生不一致。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Shared 我的版本和别人的版本是一样的，我们的版本都是最新的。不过，我们都是&quot;`读`&quot;者，如果要写的话，得先获得排他锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Invalid 我的版本比较老了。对于一个缓存来说，一个 cache line 如果是 &lt;code&gt;I&lt;/code&gt; 的状态，那就相当于它不存在。要是内核希望读它的话，会得到一个 cache miss。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;假设 &lt;code&gt;core#0&lt;/code&gt; 想写 &lt;code&gt;0x1347&lt;/code&gt; 地址，它写的不仅仅这个地址对应的内存空间，它写的是这个地址映射到的整个 cache line。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;core#0&lt;/code&gt; 告诉内存说，请把 &lt;code&gt;0x1347&lt;/code&gt; 所在的 cache line 交给我。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存说，好的，这里是 &lt;code&gt;0x1347&lt;/code&gt; 所在 cache line 的 64 字节数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;core#0&lt;/code&gt; 告诉其它核，你们的 cache 里要是有这个 cache line，立即把它作废掉。因为它的值就快过时了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;其它核听到这个消息纷纷回应&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;好的，我把那个 cache line 给作废了。或者干脆清除，或者把它标记成 &lt;code&gt;I&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;好的。虽然我这里没有那个 cache line。不过你可以放心了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;core#0&lt;/code&gt; 找到 cache line 中对应 &lt;code&gt;0x1347&lt;/code&gt; 的字节，改成自己想要的值，把那个 cache line 标记成 &lt;code&gt;M&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;core#1&lt;/code&gt; 想读 &lt;code&gt;0x1347&lt;/code&gt;，但是它对应的 cache line 是 &lt;code&gt;I&lt;/code&gt; 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;core#1&lt;/code&gt; 问内存，请把 &lt;code&gt;0x1347&lt;/code&gt; 所在的 cache line 交给我。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;core#0&lt;/code&gt; 不得已，把那个 cache line 写回内存。&lt;code&gt;core#1&lt;/code&gt; 立即读到了最新的 cache line，这时他们缓存对应 cache line 的状态都改成了 &lt;code&gt;S&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;硬件重排序&quot;&gt;硬件重排序&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这带来了另外一个问题，MESI 协议里面有两种操作会比较慢。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，写一个 cache line 需要好几步。如果 cache line 不在本地缓存，或者是 &lt;code&gt;I&lt;/code&gt; 状态。这就是个 cache miss。那么这种情况下，还需要读内存。然后为了获得 cache line 的排他锁，还需要得到其它核的确认。要是 &lt;code&gt;core#1&lt;/code&gt; 的缓存在收到 invalidate 消息的时候正在忙其它事情呢？这会 &lt;code&gt;core#0&lt;/code&gt; 的写操作。更何况现代处理器的核那么多，&lt;code&gt;core#0&lt;/code&gt; 的写操作的瓶颈之一是最慢的一个核对 invalidate 请求的回应。所以 &lt;code&gt;core#0&lt;/code&gt; 的 invalidate 最好能立即返回。所以我们在每个核的缓存前面放一个 invalidation queue，让这个操作成为异步的。&lt;code&gt;core#0&lt;/code&gt; 只要把消息放在队列里面，就可以继续执行下一条指令。等 &lt;code&gt;core#1&lt;/code&gt; 的缓存忙完了手里的事情，就会检查它的队列更新对应 cache line 的状态。CPU 的设计者没有就此止步，因为只是读内存，往每家的队列里面投递消息也很耗时，&lt;code&gt;core#0&lt;/code&gt; 的流水线还有余力做其他工作，它不希望因为这个 cache miss 就干等着。最好能并行地多做几件事情。所以我们在本地的核边上也加了一个队列，叫做 store buffer 或者 write buffer。把写操作扔到 store buffer 里面，就可以立即返回。而本地缓存一旦做完那些准备工作，它就会从 store buffer 里面拿到要修改的数据，更新自己的 cache line。反之，要是等待本地缓存和其他各方把所有这些步骤完成再循规蹈矩往下执行下一条指令，就太慢了！&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;/images/diag-f656b46c5f6fef642ec8488e59504c86.png&quot; alt=&quot;Diagram&quot; width=&quot;550&quot; height=&quot;434&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而读一个 cache line 也不容易。类似的，要是 cache miss 的话，那么当前核就会要求另外一个核把它的数据先刷到内存。这将引起一个内存事务。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是这样引入了一个问题--------内存读写操作的乱序执行。这不仅让单核的顺序执行成为一个有前提的表象，更让多核的环境下的内存一致性和顺序执行更加错综复杂。对于特定的内核来说，可能会在一个写操作完成之前，就开始执行下一条指令。而对于其他内核来说，读指令可能会得到一个事实上过时 (invalid) 的数据。因为即使是写操作的发出者也还没有真正完成这个写操作，它只是把这个操作提交给了 store buffer。不过和其他内核相比，它是可以读到最新的数据的，在它执行读指令的时候，可以先检查 store buffer，如果 store buffer 里面没有对应的数据，再检查缓存。这个叫做 store buffer forwarding。因为它在当前核通过 buffer 把数据&quot;转交&quot;给将来要执行的读指令。这个设计保证了数据依赖和控制依赖，也就是单核上下一个操作的结果如果依赖上个操作的副作用，那么下个操作必须能看到上个操作的副作用。换句话说，如果从单核的角度出发，看不出这种&quot;`依赖`&quot;问题，那么 CPU 就认为它可以把读写操作重新排列，以此获得更高的并发度。另外，store buffer 的存在也催生了另外一些优化，如果有两个写操作修改的是连续的内存地址，在刷内存的时候，这两个写操作就可以合并成一个大的写操作，从而减轻内存总线的负担。这个技术叫做 write combining。 &lt;a href=&quot;https://www.amd.com/system/files/TechDocs/24593.pdf#page=224&quot;&gt;write combining buffer&lt;/a&gt; 就是处在 store buffer 和系统总线中间的地方。如果有往同一地址的写操作，那么时间顺序上后面操作就会覆盖前面的操作，这个技术叫 write collapsing。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这种读写指令的乱序执行破坏了严格意义上的顺序一致性。对很多人来说，如果你要的是咖啡加奶，那么做法应该是先加咖啡再加奶，但是对一个追求效率的人来说，可能就会应该先做咖啡，在咖啡机哼哧的时候，把奶加进去，等咖啡机好了，再把咖啡倒进去。不过要是有原教旨主义者看到这个顺序可能会很不高兴，他说顺序和比例一样重要！简单说，顺序对自己可能不那么重要，但是旁人可能会很在意。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是甚至在不对齐写的情况下也会造成不一致的结果。说到 store buffer forwarding，之前 Linus 举了一个 &lt;a href=&quot;https://yarchive.net/comp/linux/store_buffer.html&quot;&gt;例子&lt;/a&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;假设有个系统有三个核，开始的时候 &lt;code&gt;dword [mem]&lt;/code&gt; 的内容是 &lt;code&gt;0&lt;/code&gt;。执行下面的程序&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;asm&quot;&gt;xor %eax, %eax
cmpxchl $0x01010101, (mem)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;asm&quot;&gt;movl $0x01010101, %eax
cmpxchl $0x02020202, (mem)&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;asm&quot;&gt;movb $0x03, (mem),
movl (mem), reg&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;程序结束的时候，&lt;code&gt;dword [mem]&lt;/code&gt; 可能是 &lt;code&gt;0x02020203&lt;/code&gt; ，但是有趣的是，这时第三个核上 &lt;code&gt;reg&lt;/code&gt; 里面则会是 &lt;code&gt;0x01010103&lt;/code&gt;。因为 MESI 协议保证了 cache coherency，&lt;code&gt;dword [mem]&lt;/code&gt; 的值先后是 &lt;code&gt;0&lt;/code&gt; -&amp;gt; &lt;code&gt;0x01010101&lt;/code&gt; -&amp;gt; &lt;code&gt;0x02020202&lt;/code&gt; -&amp;gt; &lt;code&gt;0x02020203&lt;/code&gt;。因为最后一次第三个核的 &lt;code&gt;mov&lt;/code&gt; 也获得了排他锁，然后把整个 cache line 刷到了内存里面。但是第三个核的寄存器为什么读到了一个奇怪的值。这个值甚至在 cache line 里面没有缓存过。原因是第三个核会这样解释：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;asm&quot;&gt;movb $0x03, store_buffer[mem] ; 把 [mem] &amp;lt;- 0x03 的操作放到，store buffer，写操作比较慢。先继续执行读操作
movl (mem), reg              ; 把 [mem] 的内容读出来
movb store_buffer[mem], reg  ; 读操作也会查看一下 store_buffer，看看手里面最新的数据&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以第三个核寄存器中看到是一个脏数据。这个数据从来没有在内存中出现过。它有两个来源：高 24 位是第一个核写进去的，低 8 位是自己写的。而按照 &lt;code&gt;cmpxch&lt;/code&gt; 的原子操作的语义，这个过程中是不可能有这样的不一致出现的。这也是为什么 amd64 不能保证非对齐写操作的原子性的原因。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;话说回来，不仅仅是写数据上的核可能看到脏数据，也因为 store buffer 的存在，使得各个核看到的内存并不一样 (coherent)。如果某个核的对某个 cache line 的修改存在 store buffer 里面，那么这个 cache line 在其它核眼中则是旧的数据。另外，就算本地缓存检查了 store buffer，发送了 invalidate 消息给其他核。但是在其它核在检查 invalidation queue 之前，仍然会认为那个 cache line 是有效的。有人可能会说，其他内核可以在读缓存之前看看 invalidation queue 啊，可能是因为 invalidation queue 只是个 queue，内核在读缓存之前不会去检查 invalidation queue。所以如果多个内核共享一块内存，那么某个核上读写顺序重新排列会导致程序有不同的执行的结果。有的时候我们不在乎，但是有的时候这种不一致的结果是致命的。再举个例子，在餐馆吃饭。有的餐馆在顾客点菜之后会给一个电子闹钟，等闹钟响了，就可以去自助取餐。以此为背景，我们想象有两个核分别代表等餐的顾客老王 (wong) 和面馆老马 (mars)：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;meal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;128&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;claim&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;cook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;meal&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;要是平时写这个程序，大家可能会很自然地用 &lt;code&gt;atomic&amp;lt;bool&amp;gt;&lt;/code&gt; 来定义 &lt;code&gt;placed_order&lt;/code&gt; 和 &lt;code&gt;beep&lt;/code&gt;。但是既然 amd64 保证了 &lt;a href=&quot;https://www.amd.com/system/files/TechDocs/24593.pdf#page=234&quot;&gt;单字节数据访问的原子性&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Cacheable, naturally-aligned single loads or stores of up to a quadword are atomic on any processor model, as are misaligned loads or stores of less than a quadword that are contained entirely within a naturally-aligned quadword.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以 &lt;code&gt;placed_order&lt;/code&gt; 的读写都是原子的。那么我们为什么还要用 &lt;code&gt;atomic&amp;lt;bool&amp;gt;&lt;/code&gt; 呢？所以上面的代码就直接用 &lt;code&gt;bool&lt;/code&gt; 了。接下来，我们在老王和兰州拉面的互动中加入 store buffer，看看会发生什么：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;老王来到面馆，大碗牛肉面！于是更新 &lt;code&gt;placed_order&lt;/code&gt;。但是 &lt;code&gt;placed_order&lt;/code&gt; 是在内存里面，写内存太慢了。先更新自己桌上的的 store buffer 吧。等会儿结账的时候再一起更新 &lt;code&gt;placed_order&lt;/code&gt; 好了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老王看着桌上的闹钟，焦急地等待。&lt;code&gt;beep&lt;/code&gt; 啊，你怎么还是 &lt;code&gt;false&lt;/code&gt; 呢？都十秒钟过去了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面馆的马老板看着老王，这个人没有下单，眼神呆滞，从一坐下来就盯着桌上的闹钟不动。怕是昨晚加班到三点，还没缓过劲？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;又过了十秒钟&amp;#8230;&amp;#8203;&amp;#8230;&amp;#8203;两个人都隐约觉得有点不对，但是不知道出了什么问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;对老王和老马来说，这都是个僵局。而这个僵局是 store-load 重排造成的。所以即使从单核的角度看，数据依赖和控制依赖是能够保证的，多核环境下也无法确保程序的&quot;`顺序`&quot;执行。换言之，cache conherence 不等于 sequential consistency。后者的语义需要引入更强约束。但是因为后者的约束太强了，我们在实际工作中往往会采用一些折中。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;另外，如果文献中提到 load buffer 或者 load queue，它是用来保存读请求的。比如说，如果处理器预测某个写请求之后会读取地址 X，它会把这个请求放到 load buffer 里面。一个读请求的地址计算出来之后，这个请求也会保存在 load cache 里面。对于那个写请求，它在写内存之前则会检查 load buffer，如果发现命中的话，就会让读取 X 的请求返回写请求要写入的值。load buffer 可以让内存读取批次化，使得 cache miss 的处理更有效率。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;一致性模型&quot;&gt;一致性模型&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不同体系结构在 consistency 这个问题上有着不同的答案，这些答案就是不同的一致性模型：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sequential consistency: 顺序一致，简称 SC。这是最死板的一致性模型。即使看上去没有危险，每个核也会以完全忠实原著的方式执行，除了缓存，不加入任何可能产生乱序的设计。所以 store buffer 和 invalidation queue 这种东西是禁止的。这种简单粗暴的限制对 CPU 的自尊心和性能是一种强烈的伤害。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;weak consistency: 弱一致。在一定程度上允许重排序，受到 &lt;a href=&quot;https://www.kernel.org/doc/Documentation/memory-barriers.txt&quot;&gt;memory barrier&lt;/a&gt; 的约束。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;relaxed consistency: 处理器完全可以&lt;span class=&quot;line-through&quot;&gt;乱来&lt;/span&gt;乱序。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;大家对性能都有自己的坚持，没有一个有追求的处理器是顺序一致的。或者说，做到高性能的严格的顺序一致会非常困难。不过 amd64 是最接近的。它只会把代码里面的 store-load 顺序打乱，变成 load-store。像刚才老王吃面的例子里面，本来老王先点面，再看闹钟，被处理器一乱序，优化成了先看闹钟，再点面。完全乱了套。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;除此之外，还有下面几种排列。对于它们，amd64 就完全按照脚本执行了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;store / store&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;load / store&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;load / load&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在各种架构里面，amd64 是比较保守的。其他架构就比较放飞自我，比如对于 aarch64 中的 ARMv8-A 架构， &lt;a href=&quot;https://developer.arm.com/documentation/den0024/a/memory-ordering&quot;&gt;它的文档&lt;/a&gt;提到&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The ARMv8 architecture employs a &lt;em&gt;weakly-ordered&lt;/em&gt; model of memory. In general terms, this means that the order of memory accesses is not required to be the same as the program order for load and store operations. The processor is able to re-order memory read operations with respect to each other.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而 Alpha 处理器则是另外一个极端。有这么一个 &lt;a href=&quot;http://www.cs.umd.edu/~pugh/java/memoryModel/AlphaReordering.html&quot;&gt;例子&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;mb&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在处理器两个核分头运行完这个程序，&lt;code&gt;i&lt;/code&gt; 竟然可能是 &lt;code&gt;0&lt;/code&gt;！ 可以这样解释&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p2&lt;/code&gt; 开始前就缓存了 &lt;code&gt;y&lt;/code&gt;，它知道 &lt;code&gt;y&lt;/code&gt; 的地址保存的值是 &lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p1&lt;/code&gt; 执行 &lt;code&gt;y = 1&lt;/code&gt; ，发了一个 invalidate 消息给 &lt;code&gt;p2&lt;/code&gt;，然后立即返回了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p2&lt;/code&gt; 收到了 &lt;code&gt;y&lt;/code&gt; 的 invalidate 消息，但是它并不急着处理，人家前面又没有 &lt;code&gt;mb()&lt;/code&gt; 催着，于是这个消息在 invalidation queue 里躺着。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p1&lt;/code&gt; 这边因为 invalidate 消息立即返回，满足了 &lt;code&gt;mb()&lt;/code&gt; 的要求，所以程序得以继续往下执行 &lt;code&gt;p = &amp;amp;y&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p2&lt;/code&gt; 为了得到 &lt;code&gt;*p&lt;/code&gt; 的值，先读取 &lt;code&gt;p&lt;/code&gt;。读 &lt;code&gt;p&lt;/code&gt; 并不要求刷 invalidation queue，所以它得到了 &lt;code&gt;y&lt;/code&gt; 的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p2&lt;/code&gt; 根据这个地址，索引到了自己的缓存。缓存里面有，为什么不用呢？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p2&lt;/code&gt; 把原来缓存的 &lt;code&gt;y&lt;/code&gt; 的值 &lt;code&gt;0&lt;/code&gt; 赋给了 &lt;code&gt;i&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里，Alpha 没有根据数据依赖来刷 invalidation queue，因为为了得到 &lt;code&gt;*p&lt;/code&gt; 读了两次内存。分别是&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mov p, %reg&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;mov (%reg), reg&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里有一个数据依赖的关系，因为第二次的输入是第一次的输出。本来很明显，最后 &lt;code&gt;reg&lt;/code&gt; 的值至少应该是一致的。也就是说，不会出现历史上 &lt;code&gt;*p&lt;/code&gt; 从来没有过的值。就像这个夏天你一直喝啤酒，从没喝过汽水。但是年前和一个朋友吃饭的时候，他说你们七月份在日本玩儿的时候，一起还喝过可乐。这一定是个错觉。你会觉得他记错了，把你记成另外一个人了。并不是说你从没喝过汽水，你小时候还挺喜欢喝。而是你和这个朋友才认识一年，你这一年的确没喝过汽水啊。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过这些选择并没有高下之分。如果只允许重排一两种读写序列，好处是程序员可以按照直觉编写多核程序，而不用太关心读写重排的问题。问题在于处理器的设计会有一些限制。要是需要同时有高并发，和严格顺序，那么处理器就必须把这些读写序列组织成一个个内存事务，如果处理器发觉因为乱序执行破坏了事务，那么就必须把乱序执行的操作取消掉。这使得高性能的并行处理器的设计变得更复杂了。如果处理器遵循的内存模型允许处理器做很多类型的重排序，那么处理器的设计会有很高的自由度，能无所顾虑地应用一些提高并发性的技术，来提高访问内存的效率，比如&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;out-of-order issue&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;speculative read&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;write-combining&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;write-collasping&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;如果处理器不需要保证访存的顺序，在相同性能指标下，功耗也低一些。在保证数据依赖和控制依赖的前提下，处理器有最大的自由度重新排序读写指令的顺序。但是对程序员的要求就更高了。他们需要再需要顺序的地方安插一些指令，手动加入 memory barrier，让处理器在那些地方收敛一下。这些 memory barrier 要求当前的内核把自己的 invalidation queue 里所有的 invalidate 消息都处理完毕，再处理读写请求。而程序员也可以帮助处理器做一些猜测，比如说 &lt;code&gt;prefetch&lt;/code&gt; 和 &lt;code&gt;clflush&lt;/code&gt; 具体影响处理器的 cache 行为。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;memory-barrier-和-lock&quot;&gt;memory barrier 和 lock&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;lfence&lt;/code&gt;, &lt;code&gt;sfence&lt;/code&gt;, &lt;code&gt;mfence&lt;/code&gt; 是 SSE1/SSE2 指令集提供的指令：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://www.amd.com/system/files/TechDocs/24593.pdf#page=228&quot;&gt;AMD64 Architecture Programmer&amp;#8217;s Manual 卷 2，7.13&lt;/a&gt; ：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The LFENCE, SFENCE, and MFENCE instructions are provided as dedicated read, write, and read/write barrier instructions (respectively). Serializing instructions, I/O instructions, and locked instructions (including the implicitly locked XCHG instruction) can also be used as read/write barriers.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;lfence&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Load Fence: 即 read barrier。以 &lt;code&gt;lfence&lt;/code&gt; 调用的地方为界，定义了读操作的偏序集合。保证系统在执行到它的时候，把之前的所有 load 指令全部完成，同时，在其之后的所有 load 指令必须在其之后完成，不能调度到它的前面。换句话说，它要求刷 invalidation queue，这样当前核所有的 invalidate 的 cache line 都会被标记成 &lt;code&gt;I&lt;/code&gt;，因此，接下来对它们的读操作就会 cache miss，从而乖乖地从内存读取最新数据。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;sfence&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;Store Fence: 即 write barrier。以 &lt;code&gt;mfence&lt;/code&gt; 调用的地方为界，定义了写操作的偏序集合。保证系统在执行到它的时候，把之前的所有 store 指令全部完成，同时，在其之后的所有 store 指令必须在其之后完成，不能调度到它的前面。它要求刷 store buffer，这样当前核所有积攒的写操作都会发送到缓存，缓存刷新的时候会发送 invalidate 消息到其他核的缓存。sfence 是 SSE1 提供的指令。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;mfence&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;memory Fence: 即 read/write barrier。以 &lt;code&gt;mfence&lt;/code&gt; 调用为界，定义了读和写操作的偏序集合。确保系统在执行到它的时候，把之前的所有 store 和 load 指令悉数完成，同事，在其之后的所有 store 和 load 指令必须在其之后完成，不能调度到它的签名。也就是说，它会清空 store buffer 和 invalidation queue。&lt;/p&gt;
&lt;/dd&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;lock&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;&lt;code&gt;lock&lt;/code&gt; 前缀：它本身不是指令。但是我们用它来修饰一些 read-modify-write 指令，确保它们是原子的。带有 &lt;code&gt;lock&lt;/code&gt; 前缀的指令的效果和 &lt;code&gt;mfence&lt;/code&gt; 相同。另外，文档告诉我们，&lt;code&gt;xchg&lt;/code&gt; 缺省带有 &lt;code&gt;lock&lt;/code&gt; 属性，所以也可以作为 read/write barrier。所以在 &lt;a href=&quot;https://lore.kernel.org/patchwork/cover/639819/&quot;&gt;内核&lt;/a&gt;里面有时会看到类似 &lt;code&gt;lock; addl $0, 0(%%esp)&lt;/code&gt; 的代码，这里就是在加 memory barrier，同时检查 &lt;code&gt;0(%%esp)&lt;/code&gt; 是否为零。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其实 x86 还有一些指令也有 memory barrier 的作用，但是它们本身有很强的副作用，比如 &lt;code&gt;IRET&lt;/code&gt; 会改变处理器的控制流，所以一般来说，要控制内存访问的顺序还是用专门的 memory barrier 和 &lt;code&gt;lock&lt;/code&gt; 指令比较容易驾驭。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以有了 &lt;code&gt;lfence&lt;/code&gt; 我们可以这么改&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;local_p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;lfence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;local_p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;禁止处理器重排这两个 &lt;code&gt;load&lt;/code&gt; 指令。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;c-的一致性模型&quot;&gt;C&amp;#43;&amp;#43; 的一致性模型&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;C&amp;#43;&amp;#43; 程序员一般不会直接使用这些 memory barrier，它们太接近硬件，可移植性也很差。比如说 aarch64 上的 memory barrier 就叫别的 &lt;a href=&quot;https://developer.arm.com/documentation/den0024/a/the-a64-instruction-set/memory-access-instructions/memory-barrier-and-fence-instructions&quot;&gt;名字&lt;/a&gt;，功能也有些许的不同。所以 C&amp;#43;&amp;#43;11 以及之后的标准规定了几种内存一致性模型，用更抽象的工具来解决这些问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在解释这些一致性模型之前，我们先回到刚才的面馆。假设老王顺利地下了单，老马也看到了老王的 &lt;code&gt;placed_order&lt;/code&gt; ，开始做面条。但是问题来了，处理器不知道 &lt;code&gt;beep&lt;/code&gt; 和 &lt;code&gt;noodle&lt;/code&gt; 是有先后关系的，所以负责老马的那个核就自作主张，先刷新了 &lt;code&gt;beep&lt;/code&gt;，而把 &lt;code&gt;noodle&lt;/code&gt; 的写操作放在 store buffer 里面了。这是一种 store-store 重排，在 amd64 上不会发生，但是在其它架构是有可能的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里有两种数据&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;被保护的数据 &lt;code&gt;noodle&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用来表示 &lt;code&gt;noodle&lt;/code&gt; 状态的标志&amp;#8201;&amp;#8212;&amp;#8201;&lt;code&gt;beep&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这有点像使用 mutex 的情况。mutex 一般用来保护共享的数据，它自己则是有明确的状态的，即 mutex 当前的所有者。在这里也是如此，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;dlist&quot;&gt;
&lt;dl&gt;
&lt;dt class=&quot;hdlist1&quot;&gt;老王&lt;/dt&gt;
&lt;dd&gt;
&lt;p&gt;通过读取 &lt;code&gt;beep&lt;/code&gt; 的状态，获取锁，一旦 &lt;code&gt;beep&lt;/code&gt; 告诉他，&amp;#8220;可以通过&amp;#8221;，那么他就可以放心访问被保护的 &lt;code&gt;noodle&lt;/code&gt;。这个过程叫做 acquire。
老马 开始的时候，老马其实已经是锁的所有者了。正是因为这样，他才得以放心地煮面，修改 &lt;code&gt;noodle&lt;/code&gt; 。一旦完成了修改，他就可以通过修改 &lt;code&gt;beep&lt;/code&gt; 的值来放弃锁。告诉别人，你们看到 &lt;code&gt;beep&lt;/code&gt; 没有，它现在是响着的，可以来访问这个 &lt;code&gt;noodle&lt;/code&gt; 了！这个过程叫做 release。&lt;/p&gt;
&lt;/dd&gt;
&lt;/dl&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以，为了避免 store-store 重排，我们用 release-acquire 语义改进了实现：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里除了避免 store-store 重排，其实还确保 load-load 的顺序：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beep.store(true, std::memory_order_release)&lt;/code&gt; 确保 &lt;code&gt;noodle = cook()&lt;/code&gt; 产生的读写操作不会被放到 &lt;code&gt;beep.store()&lt;/code&gt; 后面去。你想想，&lt;code&gt;beep&lt;/code&gt; 一响，就像泼出去的水，如果这时候告诉顾客，我还在擀面，那不是很让人恼火？所以我们一定要保证 &lt;code&gt;beep.store()&lt;/code&gt; 之前事情不会拖到后面去。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;beep.load(std::memory_order_acquire)&lt;/code&gt; 确保 &lt;code&gt;consume(noodle)&lt;/code&gt; 产生的读写操作不会放到 &lt;code&gt;beep.load()&lt;/code&gt; 之前。否则就会出现老王在 &lt;code&gt;beep&lt;/code&gt; 响之前，就直接去拿面的情况。让正在擀面的老马措手不及。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们再回到 load-store 的问题。这个问题其实很难用 release-acquire 的模型描述，因为 &lt;code&gt;placed_order&lt;/code&gt; 不是用来保护一个共享的数据的，或者说它本身就是一个共享的标记。在老王下单之前，他没有加老马家拉面的微信号，也没有填写老马搞的调查问卷。不过这个问题可以这么思考，&lt;code&gt;placed_order&lt;/code&gt; 应该在老马看到它之后重新设置成 &lt;code&gt;false&lt;/code&gt;，这样老马再次看到它的时候就不会以为老王又要了一碗面了。老王这边其实也有类似的问题，和他一起去吃面的老李也会改 &lt;code&gt;placed_order&lt;/code&gt;，要是两个人都把 &lt;code&gt;placed_order&lt;/code&gt; 改成了 &lt;code&gt;true&lt;/code&gt;，那么老马做的下一碗面到底归谁呢？所以程序应该这么改：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样还是有问题，因为老李搞不好会中途插一脚&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;老王看到没人下单了，正准备把 &lt;code&gt;placed_order&lt;/code&gt; 改成 &lt;code&gt;true&lt;/code&gt;。他还没开始 &lt;code&gt;placed_order = true&lt;/code&gt; 就开小差了，看着门外突如其来的暴雨，又陷入了沉思。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老李也注意到了，他立即把 &lt;code&gt;placed_order&lt;/code&gt; 改成了 &lt;code&gt;true&lt;/code&gt;。开始看着 &lt;code&gt;beep&lt;/code&gt; 焦急地等待自己的大碗牛肉面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;老王回过神来，也把 &lt;code&gt;placed_order&lt;/code&gt; 改成了 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个人一起焦急地等待那碗面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以我们应该用原子操作来修改 &lt;code&gt;placed_order&lt;/code&gt;，让 read-modify-write 一气呵成，用 compare-and-exchange 正合适：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;uint64_t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;wong&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_acquire&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;mars&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;noodle&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cook&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 amd64 上&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;  &lt;span class=&quot;kt&quot;&gt;bool&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compare_exchange_weak&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expected&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                             &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_relaxed&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;会被 GCC 翻译成&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;nasm&quot;&gt;  &lt;span class=&quot;nf&quot;&gt;movb&lt;/span&gt;   &lt;span class=&quot;kc&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; expected = false&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;kc&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;edx&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;; desired = true&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;retry:&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;movzbl&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;; expected =&amp;gt; %al&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;   &lt;span class=&quot;nv&quot;&gt;cmpxchg&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;dl&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2ee2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;je&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;while_beep_load&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;mov&lt;/span&gt;    &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;al&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;; %al =&amp;gt; expected&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;jmp&lt;/span&gt;    &lt;span class=&quot;nv&quot;&gt;retry&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;因为我们只需要原子操作， 所以这里只用了 &lt;code&gt;std::memory_order_relaxed&lt;/code&gt;，它对内存的访问顺序没有限制。但是前面提到，&lt;code&gt;xchg&lt;/code&gt; 缺省带有 &lt;code&gt;lock&lt;/code&gt; 属性，而 &lt;code&gt;lock&lt;/code&gt; 前缀的效果和 &lt;code&gt;mfence&lt;/code&gt; 相同。所以用不着专门加入 &lt;code&gt;mfence&lt;/code&gt;，我们也能要求处理器顺序访问内存了。否则的话，我们需要这么写&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;  &lt;span class=&quot;n&quot;&gt;placed_order&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_thread_fence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_seq_cst&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;!&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;beep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样 GCC 会产生&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;nasm&quot;&gt;  &lt;span class=&quot;nf&quot;&gt;movb&lt;/span&gt;   &lt;span class=&quot;kc&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x2ef2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;lock&lt;/span&gt;   &lt;span class=&quot;nv&quot;&gt;orq&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rsp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;nopl&lt;/span&gt;   &lt;span class=&quot;mh&quot;&gt;0x0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;rax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nl&quot;&gt;retry:&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;movzbl&lt;/span&gt; &lt;span class=&quot;mh&quot;&gt;0x2ed9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;rip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;eax&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;test&lt;/span&gt;   &lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;al&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;al&lt;/span&gt;
  &lt;span class=&quot;nf&quot;&gt;je&lt;/span&gt;     &lt;span class=&quot;nv&quot;&gt;retry&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;clang 则会用 &lt;code&gt;mfence&lt;/code&gt; 代替 &lt;code&gt;lock orq&lt;/code&gt; 指令。效果是一样的。根据查到的文献，两者的性能不分伯仲。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;load&lt;/code&gt; 和 &lt;code&gt;store&lt;/code&gt; 一般成对使用：&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;load&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;store&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_seq_cst&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_seq_cst&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_acquire&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_release&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_consume&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_release&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_relaxed&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;memory_order_relaxed&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在 x86 下：&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;C&amp;#43;&amp;#43;&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;汇编&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;load(relaxed)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov (mem), reg&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;load(consume)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov (mem), reg&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;load(acquire)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov (mem), reg&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;load(seq_cst)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov (mem), reg&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;store(relaxed)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov reg, (mem)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;store(release)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov reg, (mem)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;store(seq_cst)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;xchg reg, (mem)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;store(relaxed)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov reg (mem)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;store(relaxed)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov reg (mem)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;其中，&lt;code&gt;load(seq_cst)&lt;/code&gt; 和 &lt;code&gt;store(seq_cst)&lt;/code&gt; 也可以这么实现&lt;/p&gt;
&lt;/div&gt;
&lt;table class=&quot;tableblock frame-all grid-all stretch&quot;&gt;
&lt;colgroup&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;col style=&quot;width: 50%;&quot;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;C&amp;#43;&amp;#43;&lt;/th&gt;
&lt;th class=&quot;tableblock halign-left valign-top&quot;&gt;汇编&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;load(seq_cst)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;xchg (mem), reg&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;store(seq_cst)&lt;/p&gt;&lt;/td&gt;
&lt;td class=&quot;tableblock halign-left valign-top&quot;&gt;&lt;p class=&quot;tableblock&quot;&gt;&lt;code&gt;mov reg, (mem)&lt;/code&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;刚才我们用了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;memory_order_relaxed&lt;/code&gt; / &lt;code&gt;memory_order_relaxed&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;memory_order_acquire&lt;/code&gt; / &lt;code&gt;memory_order_release&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;帮老王和老马摆脱了困境。如果要解决 Alpha 处理器的问题的话，可以&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;atomic&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;store&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memory_order_release&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;p2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;p&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memory_order_consume&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;好在只有 Alpha 处理器这么粗犷，敢于无视数据依赖，用刚从内存里面读出来的数据作为地址，来索引缓存里面的老数据，得到指针指向的数值。其他体系架构都会重视数据依赖问题，在这个数据依赖链条上顺序执行。因为 amd64 不会重新排列 load-load，所以它天生对这个问题免疫。另外，C&amp;#43;&amp;#43;17 说&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;memory_order_consume&lt;/code&gt;: a load operation performs a consume operation on the affected memory location. [ &lt;em&gt;Note&lt;/em&gt;: Prefer &lt;code&gt;memory_order_acquire&lt;/code&gt;, which provides stronger guarantees than &lt;code&gt;memory order_consume&lt;/code&gt;. Implementations have found it infeasible to provide performance better than that of &lt;code&gt;memory_order_acquire&lt;/code&gt;. Specification revisions are under consideration.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;看起来要实现依赖链条的分析很麻烦，几家 C&amp;#43;&amp;#43; 编译器都懒得矫情，干脆杀鸡用牛刀，所以性能没提高。标准也向现实低头，那么我们如果一定要把依赖关系写得明明白白，做好跨平台的工作，还是用 &lt;code&gt;memory_order_acquire&lt;/code&gt; 吧。图个省事儿，图个放心。等到真的有要求再手写汇编。这背离了设计 &lt;code&gt;memory_order_consume&lt;/code&gt; 的 &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2008/n2664.htm&quot;&gt;初衷&lt;/a&gt;，但是也是现阶段比较实际的办法。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;前面为了让程序更好懂，这些 memory barrier 都和一个 &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; 变量放在了一起了。毕竟活生生的变量对于描述程序的逻辑才是有意义的。memory barrier 只是用来保证执行的顺序而已。它就像 &lt;code&gt;xchg&lt;/code&gt; 的前缀一样。但是我们也可以直接加入 memory barrier：&lt;code&gt;atomic_thread_fence&lt;/code&gt;。前面如果不能用 CAS 的话，我们可能就只能用这一招了。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;atomic_thread_fence&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;order&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这样直接的 memory barrier，能和 &lt;code&gt;atomic&amp;lt;&amp;gt;&lt;/code&gt; ，也能和其他 &lt;code&gt;atomic_thread_fence&amp;lt;&amp;gt;&lt;/code&gt; 一起使用。效果是相同的。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;后记&quot;&gt;后记&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ceph 是个分布式的存储系统。它里面客户端访问的数据被叫做 object。我们用 PG 来对 object 分组，把属于同一个 PG 的 object 安排在集群里的一组磁盘上。每个磁盘上都有一个服务，叫 OSD，来管理这个磁盘，同时与集群还有客户端联系。所以客户端在访问自己读写的数据时，就会直接和负责存储的服务用 TCP 进行通讯。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;一个客户端对 OSD 的读写是原子的，这个是底线。那么我们是不是也可以乱序执行客户端发过来的读写指令呢？如果客户端发过来三个消息&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;write(obj1, data), write_xattr(obj1, xattr), read(obj1), read(obj1)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;read(obj2)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;write(obj3), write_omap(obj3, omap)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这里还有一些背景，客户端和 OSD 之间是通过 Ceph 自定义的 RADOS 协议联系的。RADOS 协议中一来一回的叫做 message，而用来访问 object 的 message 叫做 &lt;code&gt;MOSDOp&lt;/code&gt;。它可以包含一系列的读写访问，但是同一个 &lt;code&gt;MOSDOp&lt;/code&gt; 中操作的对象只能是同一个。这很大程度上限制了一个 message 里请求的可能性。因为在执行绝大多数访问 object 的操作之前，OSD 都需要读取这个 object 的 OI，即 object info，获取它的一些元数据，比如这个 object 的大小，版本， 快照信息。有的时候因为操作的 offset 越界，这类操作就被作为无效请求，给客户端返回个错误，或者干脆忽略这个无效的请求。但是不管如何，写请求一般来说仍然是比读请求慢的，对于多副本的数据池，我们要求这些副本是一致的。这里的一致性问题和内存一致性类似，其实也可以展开说我们留着以后聊。对于 erasure coded 的数据池，我们也要求 k+m 都落地了才能返回，这些都很花时间。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;之前在 crimson 例会上，曾经和同事讨论过 Ceph 是不是能乱序访问，Sam 说 RBD 的访问模式基本不可能有这种情况。因为 librbd 客户端的一个 message 里不会同时出现对同一个 object 的读操作和写操作。是的。块设备的访问模式和内存是完全不一样的。就算使用 RBD 的操作系统或者应用程序把一块内存 mmap 到这个设备，也会把读写尽量 cache 在缓存或者内存里面，除非不得已，比如说上层一定要 &lt;code&gt;fsync&lt;/code&gt;。但是即使这样，&lt;code&gt;fsync&lt;/code&gt; 所对应的 &lt;code&gt;MOSDOp&lt;/code&gt; 也不会包含对所涉及的 object 的读操作。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么我们换个问题，有没有可能，或者说应不应该把对 &lt;code&gt;obj1&lt;/code&gt;、&lt;code&gt;obj2&lt;/code&gt; 和 &lt;code&gt;obj3&lt;/code&gt; 的访问乱序执行呢？先假设这几个 object 都同属于一个 PG，毕竟两个连续的操作的 object 同属于一个 PG 的可能性很小。就像是学校里面上公共选修课，随机点名的时候，你和室友都被抽中一样。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们从有没有可能开始吧。librados 提供了两种操作，一种是同步的，另一种是异步的。同步的操作执行完毕才能返回，也就是说如果这个函数返回了，那么就可以认为集群已经把请求里面的写操作作为一个事务写到磁盘上了。异步的函数调用直接返回，不等待执行的操作落地。另外调用方需要给异步调用一个回调函数，这样 librados 就知道这个操作完成的时候该怎么处理了。前者相当于天然的 sequential consistency。后者就给 OSD 以可乘之机，在保证操作原子性的前提下，有一定的自由度可以调度队列里面的操作。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在这个框架下，还有个很强的限制。Ceph 有个测试叫做 &lt;code&gt;ceph_test_rados&lt;/code&gt;，它根据配置向集群发送一系列异步的读写操作，每组操作都有个单调递增的编号。异步操作完成的时候，根据这个操作的编号我们能知道它的返回是不是顺序的。如果不是顺序的，这个测试会失败。换句话说，这个测试要求 sequential consistency。如果这个测试是合理的，或者即使不合理也是无法变动的，比如说更高层的客户端，比如说 qemu 的 RBD 插件把这个作为一个协定，并且依赖这个行为，那么我们就必须比 amd64 更自律才行。当然，我们也可以异步返回，然后再在 librados 这一层再让新的调用阻塞在老的调用上，使得它们的返回看上去像是顺序的。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了满足 sequential consistency 的要求，我们有两个选择。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;执行上的 sequential consistency。这很明显是最稳妥的办法。把罪恶扼杀在摇篮之中，通讯层甚至可以等 MOSDOp 完成之后再读取下一个 message，但是这和&lt;span class=&quot;line-through&quot;&gt;咸鱼&lt;/span&gt;完全同步有什么区别呢？客户端之所以选择异步操作就是希望更高的并发啊。当然，即便如此，异步的操作仍然是有意义的。异步往 OSD 发射指令，而在 OSD 上顺序执行可以避免网络上的延迟。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表现上的 sequential consistency。这个说法并不严谨，其实表现上的顺序一致也需要执行层面的支持。我们权且把第一个的选择作为最直接了当的、完全阻塞的实现吧。这个选择的执行需要更小心一些。因为执行层面上可能的乱序，我们可能需要考虑下面几种读写序列的乱序&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;store-store&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;写同一 object。倘若 object 没有支持快照，只要最终的结果和顺序执行的结果一样，即可以认为这两次操作是顺序的。况且要是能在 object store 层面上实现 write collapsing 或者 write combining，岂不是一桩美事？&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写不同 object。回到老问题，这两个写操作是不是带有 acquire-release 语义？会不会有老马和老王的问题？&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;store-load&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;读写同一 object。和前文中讨论的 CPU 的读写指令不同，RADOS 里面 store 和 load 指令的操作数都是立即数。所以不存在读写数据本身的数据依赖的问题。但是如果读的 extent 和之前写的 extent 有重叠，那么我们就必须小心了，至少需要先把写指令下发到 object store，然后由 object store 把 cache 修改了，并标记成 dirty 才能算是这个操作提交完成。这样等到执行 load 指令的时候才能读到最新的数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;load-store&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;load-load&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;十年前，用 &lt;code&gt;mutex&lt;/code&gt; 和 &lt;code&gt;condition_variable&lt;/code&gt; 就能解决很多多线程的问题。在今天，这些同步原语仍然很重要。但是如果我们对高并发有更高的追求，就需要更深入了解多核系统中的无锁编程，在体系结构上多理解一些 CPU 和内存的交互，这样对工作会更有帮助。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="arch" /><summary type="html">有浴缸的话，晚上到住处，有人可能会先放水，休息一下，简单吃点东西，然后呢，看看水温，差不多了洗个澡。用文艺的说法，这是生活的智慧。用体系结构的话说，这是乱序执行，使用了简单的调度算法。对单身汉来说，打乱计划，用不一样的顺序安排生活可以获得更高的效率。但是对多核程序来说，这其实不一定是好事。Jim Keller 打了个 比方，他说计算机是在顺序的手法说一个故事，书里面有很多段落，段落是由句子构成的。读者可以画一个示意图，看看哪些段落和句子读的时候可以打乱顺序，而不改变表达的意思。比如</summary></entry><entry><title type="html">longjmp 和 setcontext</title><link href="https://blog.k3fu.xyz/2020/08/09/setjmp-setcontext.html" rel="alternate" type="text/html" title="longjmp 和 setcontext" /><published>2020-08-09T00:00:00+00:00</published><updated>2020-08-09T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/2020/08/09/setjmp-setcontext</id><content type="html" xml:base="https://blog.k3fu.xyz/2020/08/09/setjmp-setcontext.html">&lt;div id=&quot;preamble&quot;&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这篇文章起源于 seastar-devel 上的一个https://groups.google.com/g/seastar-dev/c/ncjU57iz7uk/m/7zye5ujiDAAJ[讨论]。在开始之前，我们先说一下协程的背景。
因为讨论涉及特定的操作系统、处理器系统架构以及调用约定，如果没有特殊说明的话，下面都以 sysv, amd64 和现代的 Linux 为例。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;协程的由来&quot;&gt;协程的由来&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;coroutine 或者 cooperative threads，中文常常叫协程。在 Linux 里面，常规的调度单位是 LWP (light weight process)。 NPTL 实现下，LWP 和用户线程在数量上是一对一的对应关系。所以，以 Linux 为例，有这么几个问题:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缺省 8MB 的栈空间。虽然 8M 只是虚拟地址的空间，但是内核里面在分配栈空间的时候必须立即分配对应的页表，这个开销是无法避免的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;线程调度的时候必须借助内核。换言之，上下文切换也会引起一些开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为内核调度线程的不可预期性，比如一个线程把自己的时间片用完了。内核可能会把它调度出去，把另一个就绪的任务换进来。为了保证数据和逻辑的一致性，在一些可能产生 racing 的地方，必须加锁。而锁的引入进一步影响了性能和并发的粒度。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以为了避免这些问题，我们引入了协程的概念，在用户态实现 m:n 的映射。让线程自己调度自己。正是因为这种用户态线程是互相协作的，只有当一个线程主动把 CPU 让出来，另一个已经就绪的线程才能继续运行。这也是为什么协程叫做&quot;`协程`&quot;的原因。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;协程的基本要素&quot;&gt;协程的基本要素&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;协程要能自己调度自己，需要满足下面几个要求&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;协程在让出 CPU 的时候，需要保存现场。这样当它以后继续执行的时候，能记得起来之前在做什么，然后继续当时未完成的任务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协程在让出 CPU 的时候，能找到另外一个就绪的协程，恢复它当初保存的现场。帮助它回忆起来之前的事情。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这有点像晚上睡前看完书的时候，大家会在书里面夹一个书签，记住看到哪一页了。下次再翻开书的时候，找到书签的位置就能从上次停下来的地方继续看。只不过一个系统里面可能会有成百上千个线程，每个线程都有自己的&quot;`书签`&quot;。一般来说，协程库提供两个基本的操作：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;yield / swap out: 把控制权让出来，保存自己的状态。也就是插书签。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;resume / swap in: 获取控制权，恢复自己的状态。也就是根据书签的位置，继续读书。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;协程的实现&quot;&gt;协程的实现&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;书签和上下文&quot;&gt;书签和上下文&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;书签保存的信息只有一个页码。但是对于一个线程来说，它在 CPU 上执行的状态对应着更多的信息。我们先看一个特例--------子函数的调用。假设我们在 &lt;code&gt;main()&lt;/code&gt; 里面调用之前定义的函数 &lt;code&gt;func()&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;rouge highlight&quot;&gt;&lt;code data-lang=&quot;c++&quot;&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;n&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了让 &lt;code&gt;func()&lt;/code&gt; 返回时，&lt;code&gt;main()&lt;/code&gt; 能继续它当时未尽的事业，很明显，它需要&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;在跳转到 &lt;code&gt;func()&lt;/code&gt; 的起始地址之前，保存当下的 &lt;code&gt;%ip&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;再把 &lt;code&gt;%ip&lt;/code&gt; 改成 &lt;code&gt;func()&lt;/code&gt; 的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;func()&lt;/code&gt; 在返回的时候，需要把 &lt;code&gt;%ip&lt;/code&gt; 恢复成之前保存的 版本。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;x86 很贴心的提供了 &lt;code&gt;CALL&lt;/code&gt; 和 &lt;code&gt;RET&lt;/code&gt; 两个指令。前者把 &lt;code&gt;%ip&lt;/code&gt; 压栈，再根据 &lt;code&gt;CALL&lt;/code&gt; 的参数更新 &lt;code&gt;%ip&lt;/code&gt;。要是大家还能回忆相对寻址、绝对寻址的话，&lt;code&gt;CALL&lt;/code&gt; 是支持这些寻址方式的。要是目标地址不在一个 &lt;code&gt;%cs&lt;/code&gt; 段，它还能把当前 &lt;code&gt;%cs&lt;/code&gt; 也一并保存了。&lt;code&gt;RET&lt;/code&gt; 执行的是相反的功能。它把栈上的地址恢复回 &lt;code&gt;%cs&lt;/code&gt; 和 &lt;code&gt;%ip&lt;/code&gt;，如果 &lt;code&gt;RET&lt;/code&gt; 还有参数的话，还顺带着把栈上的垃圾清理一下，也就是退栈。通常来说，调用方会把一些参数放到栈上，而参数的个数一般是确定的。所以被调用方在返回的时候，把那些参数从栈上清除也是理所当然的事情。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以说 &lt;code&gt;CALL&lt;/code&gt; 和 &lt;code&gt;RET&lt;/code&gt; 给了线程订了一张往返票，让它从一个地方走到另外一个地方出个差，然后再回来。 除了 &lt;code&gt;%ip&lt;/code&gt;，根据 amd64 或者 x86-64 的 ABI 调用规范，在函数调用的时候，下面的寄存器是调用方负责的:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;​&lt;code&gt;%rax&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;​&lt;code&gt;%rcx​&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;​%rdx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%rdi&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%rsi&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%r8&lt;/code&gt; 到 &lt;code&gt;%r11&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;换句话说，如果调用方觉得它无所谓函数返回之后这些寄存器的状态是否改变了，那么它完全可以选择不保存它们。其中，函数调用的前六个参数保存在 &lt;code&gt;%rdi&lt;/code&gt;, &lt;code&gt;%rsi&lt;/code&gt;，&lt;code&gt;%rdx&lt;/code&gt;，&lt;code&gt;%rcx&lt;/code&gt;, &lt;code&gt;%r8d&lt;/code&gt;, &lt;code&gt;%r9d&lt;/code&gt;。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;而被调用方则有义务保存：&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%rbx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%rbp&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%rsp&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;%r12&lt;/code&gt; 到 &lt;code&gt;%r15&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;也就是说，在函数返回之后，这些寄存器的值应该保持不变。这些要求定义了一个函数调用的行为规范，确保编译器能编译出有效率的代码，而不用花时间分析被调用的函数到底修改了哪些寄存器。所以一般来说，我们的 &lt;code&gt;yield&lt;/code&gt; 实现也应该遵守这些基本的规范，保证调用方行为不受到干扰。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么从一个线程到另外一个线程呢？除了函数调用规范要求的那些寄存器，还有哪些状态需要保存呢？&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://man7.org/linux/man-pages/man7/pthreads.7.html&quot;&gt;pthread(7)&lt;/a&gt; 总结了一下。它说，POSIX.1 要求一个进程里面的线程有共同的一系列属性，比如说 &lt;code&gt;process ID&lt;/code&gt;、&lt;code&gt;uid&lt;/code&gt;、文件描述符以及 signal handler。它们也有自己的独立的属性，比如 &lt;code&gt;errno&lt;/code&gt;、&lt;code&gt;signalprocmask&lt;/code&gt; 还有 &lt;code&gt;sigaltstack&lt;/code&gt;。这些属性有着各自不同的实现方式。&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;errno&lt;/code&gt; 它是 libc 实现的接口，让 libc 的函数能告诉调用方具体的错误号。 libc 一般把它保存在 &lt;code&gt;%fs&lt;/code&gt; 段里面。但是如果我们不需要:&lt;/p&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt; int ret  = fstat(...);
 yield_to(another_thread);
 if (ret != 0) {
   perror(&quot;fstat failed&quot;);
 }&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;那么就没有必要保存和恢复 &lt;code&gt;errno&lt;/code&gt; 了。&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sigprocmask&lt;/code&gt; 如果调度的线程 &lt;a href=&quot;https://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_sigmask.html&quot;&gt;sigmask&lt;/a&gt; 不一样，那么我们的确需要保存恢复它们各自的 &lt;code&gt;sigprocmask&lt;/code&gt;。但是如果它们的 sigmask 都一样的话，就可以不用管这个属性了。&lt;code&gt;sigaltstack&lt;/code&gt; 也是类似的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;函数调用使用栈来保存返回地址，传递一些参数。而每个线程都有自己的栈。在切换线程的时候，&lt;code&gt;%rsp&lt;/code&gt; 和 &lt;code&gt;%rbp&lt;/code&gt; 也需要指向新的线程自己的栈。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浮点处理器的运行环境。这包括一系列寄存器。可以参考 &lt;code&gt;FSTENV&lt;/code&gt; 和 &lt;code&gt;FLDENV&lt;/code&gt; 这两个指令。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;libc-的书签&quot;&gt;libc 的书签&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;我们管这些林林总总的状态叫做&quot;`上下文`&quot;。 为了保存和恢复上下文，libc 提供了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;setjmp()&lt;/code&gt; 保存当前的 &lt;code&gt;%rbx&lt;/code&gt;, &lt;code&gt;%rbp&lt;/code&gt;, &lt;code&gt;%r12&lt;/code&gt;, &lt;code&gt;%r13&lt;/code&gt;, &lt;code&gt;%r14&lt;/code&gt;, &lt;code&gt;%r15&lt;/code&gt;, &lt;code&gt;%rsp&lt;/code&gt;, &lt;code&gt;%rip&lt;/code&gt; 到指定的 &lt;code&gt;jmp_buf&lt;/code&gt; 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;longjmp()&lt;/code&gt; 从指定的 &lt;code&gt;jmp_buf&lt;/code&gt; 恢复 &lt;code&gt;%rbx&lt;/code&gt;, &lt;code&gt;%rbp&lt;/code&gt;, &lt;code&gt;%r12&lt;/code&gt;, &lt;code&gt;%r13&lt;/code&gt;, &lt;code&gt;%r14&lt;/code&gt;, &lt;code&gt;%r15&lt;/code&gt;, &lt;code&gt;%rsp&lt;/code&gt; 中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;可以参考 &lt;a href=&quot;http://git.musl-libc.org/cgit/musl/tree/src/setjmp/x86_64/setjmp.s&quot;&gt;musl-libc 的实现&lt;/a&gt;。可以说 &lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 是相当简练的。只提供了两个功能，一个是记录当前的位置，另一个是跳转到指定的位置。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;但是 &lt;a href=&quot;https://sourceware.org/git/?p=glibc.git;a=blob;f=setjmp/longjmp.c;h=686ab1964b4cf5848cd7505d6ca2c00dce5722aa;hb=HEAD&quot;&gt;glibc 的 longjmp&lt;/a&gt; 还更啰嗦一些，它在调用平台相关的&lt;code&gt;__longjmp()&lt;/code&gt;之前，还调用了&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;_longjmp_unwind()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__sigprocmask()&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;libc-的-context&quot;&gt;libc 的 context&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;虽然 &lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 很简练。但是它们只能允许我们回到一个已知的地方。这和之前书签的例子很像，如果之前没有用 &lt;code&gt;setjmp()&lt;/code&gt; 得到 &lt;code&gt;jmp_buf&lt;/code&gt;，那么是无法跳转到 &lt;code&gt;jmp_buf&lt;/code&gt; 指示的地方的。如果我们希望实现协程的话。假设我们一开始启动了一个 POSIX 线程，当这个线程执行的函数希望 &lt;code&gt;yield&lt;/code&gt;，把执行权交给另一个任务，而这个任务还从没执行过。那么 不手动修改&lt;code&gt;jmp_buf&lt;/code&gt; 是无法实现这个功能的。读者可能会说，如果开始这个新任务的函数之前执行过，那么是不是在函数开始的时候用 &lt;code&gt;setjmp()&lt;/code&gt;加个书签就可以了呢？这样会导致两个协程互相重用一个栈，导致原来的线程在返回时可能会读到错误的数据，也可能干脆跑飞掉。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;所以 glibc 干脆提供了下面这几个函数:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;literalblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre&gt;int getcontext(ucontext_t *ucp);
int setcontext(const ucontext_t *ucp);
void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...);
int swapcontext(ucontext_t *oucp, const ucontext_t *ucp);&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;提供了比 &lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 更强大的功能。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;getcontext()&lt;/code&gt; 记录当前的上下文。这个上下文可以作为一个模板，如果我们需要让它使用另一个栈，没问题！如果我们想让调度它的时候，运行 &lt;code&gt;serve_request()&lt;/code&gt;，好的！对了，这个函数还应该有几个参数，嗯，我想在这里设置这些参数&amp;#8230;&amp;#8203;&amp;#8230;&amp;#8203;当然可以！这些函数满足了用户对协程的所有要求。但是它们也带来了一些问题&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;过于完整的线程支持。&lt;code&gt;setcontext()&lt;/code&gt; 和 &lt;code&gt;swapcontext()&lt;/code&gt; 除了做了 &lt;code&gt;longjmp()&lt;/code&gt; 的工作，还：&lt;/p&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;用系统调用设置 &lt;code&gt;sigprocmask&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置 &lt;code&gt;%fs&lt;/code&gt;，这是段寄存器。TLS 的变量都保存在这里面。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不跨平台。https://pubs.opengroup.org/onlinepubs/009695399/functions/getcontext.html[POSIX.1] 已经把这几个函数去掉了。musl-libc 干脆[12][不实现他们]。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 &lt;code&gt;context&lt;/code&gt; 串起来。调用当初设置的函数，要是执行完了，看看 &lt;code&gt;uc_link&lt;/code&gt;，要是还有下一个 context。有的话，再调用 &lt;code&gt;setcontext()&lt;/code&gt;，开始执行它。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;seastar-的-thread&quot;&gt;Seastar 的 thread&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Seastar 为了避免使用重量级的 &lt;code&gt;swapcontext()&lt;/code&gt; 进行上下文切换，只是在开始的时候用 &lt;code&gt;getcontext()&lt;/code&gt; 和 &lt;code&gt;makecontext()&lt;/code&gt; 来初始化 context，而在平时调度的时候继续用 &lt;code&gt;setjmp()&lt;/code&gt; 和 &lt;code&gt;longjmp()&lt;/code&gt; 的组合。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;首先，每个用户态线程都有自己的 context，这个 context 包含&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个 128KB 的栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个 &lt;code&gt;jmp_buf&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指向原来的 &lt;code&gt;context&lt;/code&gt; 的指针&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;在这里，ucontext 就像是一个通向 &lt;code&gt;jmp_buf&lt;/code&gt; 的跳板。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;在初始化用户态线程的时候，Seastar 新建一个 ucontext，让它使用自己的栈，并把它指向一个静态函数 &lt;code&gt;s_main()&lt;/code&gt;，这个函数的参数其实就是 &lt;code&gt;thread_context&lt;/code&gt; 的地址，所以它得以调用 &lt;code&gt;this-&amp;gt;main()&lt;/code&gt;。后者才会调用真正的任务函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个线程都用 TLS 保存着自己的 &lt;code&gt;thread_context&lt;/code&gt; ，在工作线程调度到新的任务的时候，新的任务对应着新的 &lt;code&gt;thread_context&lt;/code&gt; 实例。在这个新的 &lt;code&gt;thread_context&lt;/code&gt; 开始运行之前，我们把当前的 context 作为成员变量保存在新的 &lt;code&gt;thread_context&lt;/code&gt; 里面。然后用 &lt;code&gt;setjmp()&lt;/code&gt; 把当前上下文保存在原来的 context 中。这时保存了原来 context 的上下文。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不过我们并不保存这个新建的 ucontext，我们的目标是调度到 &lt;code&gt;this-&amp;gt;main()&lt;/code&gt;。接下来用 &lt;code&gt;setcontext()&lt;/code&gt; 跳转到这个 ucontext 完成调度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一次要 &lt;code&gt;yield&lt;/code&gt; 就简单很多，只需要 &lt;code&gt;setjmp(this-&amp;gt;jmpbuf)&lt;/code&gt;，然后 &lt;code&gt;longjmp(link-&amp;gt;jmpbuf)&lt;/code&gt; 就行了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类似的，如果是 &lt;code&gt;resume&lt;/code&gt;，则是相反的操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果希望销毁这个用户态线程，则直接 &lt;code&gt;longjmp(link-&amp;gt;jmpbuf)&lt;/code&gt; 。跳过保留上下文的步骤。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;boostcontext&quot;&gt;Boost::context&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;code&gt;Boost::context&lt;/code&gt; 用汇编实现了平台相关的 &lt;code&gt;fcontext_t&lt;/code&gt; ，它的性能据说比 &lt;code&gt;ucontext_&lt;/code&gt; &lt;a href=&quot;https://www.boost.org/doc/libs/1_73_0/libs/context/doc/html/context/performance.html&quot;&gt;高一到两个数量级&lt;/a&gt; 。&lt;code&gt;fcontext_&lt;/code&gt; &lt;a href=&quot;https://github.com/boostorg/context/blob/7c481a8fb6db3a3b6c981e7b27f02064d1efb499/src/asm/jump_x86_64_sysv_elf_gas.S&quot;&gt;保存的上下文&lt;/a&gt; 有&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;MXCSR&lt;/code&gt; 中的控制字。x86 上 &lt;a href=&quot;https://xem.github.io/minix86/manual/intel-x86-and-64-manual-vol1/o_7281d5ea06a5b67a-240.html&quot;&gt;SSE/SSE2 用于保存浮点控制和状态的寄存器&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;FPCR&lt;/code&gt; 即 X87 FPU control word。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;这两个寄存器状态和 &lt;a href=&quot;https://en.wikipedia.org/wiki/Transactional_Synchronization_Extensions&quot;&gt;Intel TSX&lt;/a&gt; 机制有关系。TSX (Intel Transactional Synchronisation Extensions) 是 Intel 实现的硬件内存事务机制，可以粗略地理解，它使用 L1 cache 跟踪读集合和写集合，如果出现冲突的话，就放弃当前核上的修改，不把它刷到内存里面去，导致不一致。我们可以在另外一篇文章里面继续讨论内存一致性、可见性和多核系统里面乱序执行的问题。不过这里保存它们的原因是因为，如果浮点 TSX 的事务中发现浮点状态字有变化，那么这个事务肯定会https://www.boost.org/doc/libs/master/libs/fiber/doc/html/fiber/speculation.html[终止]。所以为了支持 TSX，Boost 也保存这些浮点寄存器。顺便说一下，内核里面是不能用浮点操作的。所以那边我们不需要关心这种问题。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;基于这套实现，Boost 实现了自己的协程库。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;seastar-devel 上的https://groups.google.com/g/seastar-dev/c/ncjU57iz7uk/m/7zye5ujiDAAJ[讨论] 也是围绕着这一点。 Christian 觉得手工实现 &lt;code&gt;longjmp()&lt;/code&gt; 会比较高效。Avi 提到当初他也考虑过 &lt;code&gt;Boost::context&lt;/code&gt;。因为它比较简单明了，同时没有 glibc 中 &lt;code&gt;_longjmp_unwind()&lt;/code&gt; 和 &lt;code&gt;__sigprocmask()&lt;/code&gt; 的开销，所以对于广大的 glibc 用户来说，使用 &lt;code&gt;Boost::context&lt;/code&gt; 性能会更好一些。 不过 &lt;code&gt;Boost::context&lt;/code&gt; 在 1.55/1.56 中的实现还不成熟。为了精炼版的 &lt;code&gt;longjmp()&lt;/code&gt;，只能有两条路，&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist arabic&quot;&gt;
&lt;ol class=&quot;arabic&quot;&gt;
&lt;li&gt;
&lt;p&gt;要求用户使用新版的 Boost&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把 &lt;code&gt;fcontext_t&lt;/code&gt; 使用的汇编代码移植到 Seastar 里面去。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;不过 Avi 提到，glibc 中的 &lt;code&gt;longjmp()&lt;/code&gt; 在上下文切换操作中占用的时间其实并不算多。所以就没有必要手撸汇编了。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="x86" /><summary type="html">这篇文章起源于 seastar-devel 上的一个https://groups.google.com/g/seastar-dev/c/ncjU57iz7uk/m/7zye5ujiDAAJ[讨论]。在开始之前，我们先说一下协程的背景。 因为讨论涉及特定的操作系统、处理器系统架构以及调用约定，如果没有特殊说明的话，下面都以 sysv, amd64 和现代的 Linux 为例。</summary></entry><entry><title type="html">开场白</title><link href="https://blog.k3fu.xyz/misc/2020/08/08/hello-world.html" rel="alternate" type="text/html" title="开场白" /><published>2020-08-08T00:00:00+00:00</published><updated>2020-08-08T00:00:00+00:00</updated><id>https://blog.k3fu.xyz/misc/2020/08/08/hello-world</id><content type="html" xml:base="https://blog.k3fu.xyz/misc/2020/08/08/hello-world.html">&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;为了记录，也为了提高自己，写个 blog。&lt;/p&gt;
&lt;/div&gt;</content><author><name>Kefu Chai</name><email>tchaikov@gmail.com</email></author><category term="misc" /><summary type="html">为了记录，也为了提高自己，写个 blog。</summary></entry></feed>