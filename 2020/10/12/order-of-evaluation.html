<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.2.6
    Copyright 2016-2020 Sylhare
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css" />

    <!--Favicon-->
    <link rel="shortcut icon" href="" type="image/x-icon" />

    <!-- Canonical -->
    <link
      rel="canonical"
      href="https://blog.k3fu.xyz/2020/10/12/order-of-evaluation.html"
    />

    <!-- RSS -->
    <link
      rel="alternate"
      type="application/atom+xml"
      title="some random rants"
      href="https://blog.k3fu.xyz/feed.xml"
    />

    <!-- KaTeX 0.12.0 -->
    <!-- if you have any issue check https://github.com/KaTeX/KaTeX -->

    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script
      defer
      src="/assets/js/vendor/auto-render.min.js"
      onload="renderMathInElement(document.body);"
    ></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = "cookie-notice-dismissed-https://blog.k3fu.xyz";
      const isCookieConsent = "";
      const analyticsName = "";
    </script>

    <!-- seo tags -->
    <meta property="og:image" content="https://blog.k3fu.xyz/" />
    <!-- Begin Jekyll SEO tag v2.6.1 -->
    <title>求值的顺序 | some random rants</title>
    <meta name="generator" content="Jekyll v4.1.1" />
    <meta property="og:title" content="求值的顺序" />
    <meta name="author" content="Kefu Chai" />
    <meta property="og:locale" content="en" />
    <meta
      name="description"
      content="用 Seastar 的时候，常常需要推迟一个对象的析构。于是问题来了。"
    />
    <meta
      property="og:description"
      content="用 Seastar 的时候，常常需要推迟一个对象的析构。于是问题来了。"
    />
    <link
      rel="canonical"
      href="https://blog.k3fu.xyz/2020/10/12/order-of-evaluation.html"
    />
    <meta
      property="og:url"
      content="https://blog.k3fu.xyz/2020/10/12/order-of-evaluation.html"
    />
    <meta property="og:site_name" content="some random rants" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2020-10-12T00:00:00+00:00"
    />
    <script type="application/ld+json">
      {
        "description": "用 Seastar 的时候，常常需要推迟一个对象的析构。于是问题来了。",
        "url": "https://blog.k3fu.xyz/2020/10/12/order-of-evaluation.html",
        "@type": "BlogPosting",
        "headline": "求值的顺序",
        "dateModified": "2020-10-12T00:00:00+00:00",
        "datePublished": "2020-10-12T00:00:00+00:00",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://blog.k3fu.xyz/2020/10/12/order-of-evaluation.html"
        },
        "author": { "@type": "Person", "name": "Kefu Chai" },
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <!-- RSS -->
    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://blog.k3fu.xyz/feed.xml"
      title="some random rants"
    />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="求值的顺序" />
    <meta
      name="twitter:description"
      content="用 Seastar 的时候，常常需要推迟一个对象的析构。于是问题来了。平时，我们这样写程序：void scan(func_t&amp;&amp; f){  Node root = get_root();  return root.scan(std::move(f));}但是用 Seastar 的话，因为 get_..."
    />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:image" content="https://blog.k3fu.xyz/" />
  </head>

  <body>
    <header class="site-header">
      <!-- Logo and title -->
      <div class="branding">
        <h1 class="site-title">
          <a aria-label="some random rants" href="/">
            some random rants
          </a>
        </h1>
      </div>

      <!-- Toggle menu -->
      <nav class="clear">
        <a aria-label="pull" id="pull" class="toggle" href="#">
          <i class="fa fa-bars fa-lg"></i>
        </a>

        <!-- Menu -->
        <ul class="hide">
          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="关于" title="关于" href="/about/">
              关于
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="搜索" title="搜索" href="/search/">
              <i class="fa fa-search" aria-hidden="true"></i>
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="Tags" title="Tags" href="/tags/">
              <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
          </li>
        </ul>
      </nav>
    </header>

    <div class="content">
      <article>
        <header id="main" style="">
          <div class="title-padder">
            <h1
              id="%E6%B1%82%E5%80%BC%E7%9A%84%E9%A1%BA%E5%BA%8F"
              class="title"
            >
              求值的顺序
            </h1>

            <div class="post-info">
              <p class="meta">
                October 12, 2020
              </p>
            </div>
          </div>
        </header>

        <section class="post-content">
          <div class="paragraph">
            <p>用 Seastar 的时候，常常需要推迟一个对象的析构。于是问题来了。</p>
          </div>
          <div class="paragraph">
            <p>平时，我们这样写程序：</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre
                class="rouge highlight"
              ><code data-lang="c++"><span class="kt">void</span> <span class="nf">scan</span><span class="p">(</span><span class="n">func_t</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">Node</span> <span class="n">root</span> <span class="o">=</span> <span class="n">get_root</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
<span class="p">}</span></code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              但是用 Seastar 的话，因为
              <code>get_root()</code>
              可能会阻塞，我们可能可以把代码写成下面这样：
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre
                class="rouge highlight"
              ><code data-lang="c++"><span class="n">seastar</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;&gt;</span> <span class="n">scan</span><span class="p">(</span><span class="n">func_t</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">get_root</span><span class="p">().</span><span class="n">then</span><span class="p">([</span><span class="n">f</span><span class="o">=</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">)](</span><span class="n">Node</span><span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>
              那么既然 <code>get_root()</code> 是异步的，那么等到调用
              <code>then()</code> 的时候，<code>f</code>
              会不会已经析构了呢？我们是不是应该这么写？
            </p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre
                class="rouge highlight"
              ><code data-lang="c++"><span class="n">seastar</span><span class="o">::</span><span class="n">future</span><span class="o">&lt;&gt;</span> <span class="n">scan</span><span class="p">(</span><span class="n">func_t</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">seastar</span><span class="o">::</span><span class="n">do_with</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">f</span><span class="p">),</span> <span class="p">[</span><span class="k">this</span><span class="p">](</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">get_root</span><span class="p">().</span><span class="n">then</span><span class="p">([</span><span class="o">&amp;</span><span class="n">f</span><span class="p">](</span><span class="n">Node</span><span class="o">&amp;&amp;</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">root</span><span class="p">.</span><span class="n">scan</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span></code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>这里就是例子：</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre
                class="rouge highlight"
              ><code data-lang="c++"><span class="k">struct</span> <span class="nc">foo_t</span> <span class="p">{</span>
  <span class="n">foo_t</span><span class="o">&amp;</span> <span class="n">func</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"func("</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">gen</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"gen("</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">")"</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">foo_t</span> <span class="n">foo</span><span class="p">;</span>
  <span class="n">foo</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">func</span><span class="p">(</span><span class="n">gen</span><span class="p">(</span><span class="mi">2</span><span class="p">));</span>
<span class="p">}</span></code></pre>
            </div>
          </div>
          <div class="paragraph">
            <p>的输出是:</p>
          </div>
          <div class="listingblock">
            <div class="content">
              <pre>
 func(1)
 gen(2)
 func(2)</pre
              >
            </div>
          </div>
          <div class="paragraph">
            <p>
              由此可知，<code>gen(2)</code> 是在
              <code>func(1)</code> 返回之后才调用的。 而
              <code>get_root()</code> 里面的代码如果是异步调用的话，可能在
              <code>scan()</code>
              返回的时候也还没有“完成”。因为异步调用返回的是一个
              <code>future</code> ，如果 future state 当时还没有准备好，那么
              <code>.then(func)</code> 则会把 <code>func</code> 包装成一个 task
              等待调度。
            </p>
          </div>
          <div class="paragraph">
            <p>
              但是从 C&#43;&#43; 的角度来说呢？简化版本的代码中，有这么个表达式
            </p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img
                src="/images/diag-9285d44a0dc2f44729db42b65a8b841d.png"
                alt="Diagram"
                width="630"
                height="210"
              />
            </div>
          </div>
          <div class="paragraph">
            <p>
              很明显，这里的 AST 的树根是个函数调用。n4659 中，
              <a
                href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2017/n4659.pdf"
                >expr.call</a
              >
              一节说道
            </p>
          </div>
          <div class="quoteblock">
            <blockquote>
              <div class="paragraph">
                <p>
                  A function call is a postfix expression followed by
                  parentheses containing a possibly empty, comma-separated list
                  of <em>initializer-clauses</em> which constitute the arguments
                  to the function.
                </p>
              </div>
            </blockquote>
          </div>
          <div class="paragraph">
            <p>接着标准规定了函数参数的求值顺序</p>
          </div>
          <div class="quoteblock">
            <blockquote>
              <div class="paragraph">
                <p>
                  The <em>postfix-expression</em> is sequenced before each
                  <em>expression</em> in the <em>expression-list</em> and any
                  default argument. The initialization of a parameter, including
                  every associated value computation and side effect, is
                  indeterminately sequenced with respect to that of any other
                  parameter.
                </p>
              </div>
            </blockquote>
          </div>
          <div class="paragraph">
            <p>
              用<a href="https://en.cppreference.com/w/cpp/language/eval_order"
                >通俗易懂的话</a
              >，就是：
            </p>
          </div>
          <div class="quoteblock">
            <blockquote>
              <div class="paragraph">
                <p>
                  When calling a function (whether or not the function is
                  inline, and whether or not explicit function call syntax is
                  used), every value computation and side effect associated with
                  any argument expression, or with the postfix expression
                  designating the called function, is sequenced before execution
                  of every expression or statement in the body of the called
                  function.
                </p>
              </div>
            </blockquote>
          </div>
          <div class="paragraph">
            <p>
              所以，我们这个例子里面 <code>.then()</code> 有两个参数，在真正调用
              <code>.then()</code> 之前，我们必须先对这两个参数求值。
            </p>
          </div>
          <div class="ulist">
            <ul>
              <li>
                <p>
                  一个是 <code>this</code>，它的值由
                  <code>get_root()</code> 返回，为了得到这个参数必须对
                  <code>get_root()</code> 求值。
                </p>
              </li>
              <li>
                <p>
                  另一个是一个 lambda 表达式，它的值由 capture list
                  和后面的函数体决定。但是请注意，要对这个表达式求值并不需要执行这个
                  lambda 表达式。它的值就是一个 lambda 表达式。
                </p>
              </li>
            </ul>
          </div>
          <div class="paragraph">
            <p>
              所以在调用 <code>.then()</code> 之前，<code>f</code>
              的值就被稳妥地保存在第二个参数里面了，并且因为我们是 capture by
              move，所以第二个参数析构的时候，<code>f</code>
              也会随之而去。我们并不需要为它专门做一个
              <code>seastar::do_with()</code>
              用智能指针保存它的值，延长其生命周期。
            </p>
          </div>
          <div class="paragraph">
            <p>
              回到一开始的
              <code>foo_t</code>
              的那个例子，其实它有些许误导。我们按照结合律，可以把这个表达式拆成这么几个
            </p>
          </div>
          <div class="imageblock">
            <div class="content">
              <img
                src="/images/diag-12f3688866fca34d79a454bfb30b7c72.png"
                alt="Diagram"
                width="560"
                height="196"
              />
            </div>
          </div>
          <div class="paragraph">
            <p>
              所以对第二个 <code>.func()</code> 求值，我们必须先对
              <code>foo.func(1)</code> 和
              <code>gen(2)</code> 求值，当然它们的顺序不一定。然后再调用
              <code>foo.func(2)</code>。
            </p>
          </div>
          <div class="paragraph">
            <p>
              但是和前文 <code>scan()</code> 的例子不一样，<code>scan()</code>
              的第二个参数是个 lambda 表达式，为了对它求值，我们必须初始化
              lambda 表达式中的 capture
              列表。所以看上去好像有“写在后面的代码反而在之前执行了”的错觉。但是如果把语法关系理清楚，这个问题就迎刃而解了。
            </p>
          </div>
        </section>

        <!-- Social media shares -->

        <!-- Tag list -->

        <footer>
          <div class="tag-list">
            <div class="meta">Tag</div>

            <a class="button" href="/tags#c%2B%2B">
              <p><i class="fa fa-tag fa-fw"></i> c++</p>
            </a>
          </div>
        </footer>
      </article>

      <!-- Disqus -->

      <!-- Post navigation -->

      <div id="post-nav">
        <div id="next-post">
          <a alt="Read the Docs 之路" href="/2020/10/02/cython-doc.html">
            <p>Next post</p>
            Read the Docs 之路
          </a>
        </div>
      </div>

      <!-- To change color of links in the page -->
      <style>
        header#main {
          background-repeat: no-repeat;
        }
      </style>
    </div>
    <footer class="site-footer">
      <p class="text">
        Powered by <a href="https://jekyllrb.com/">Jekyll</a> with
        <a href="https://github.com/sylhare/Type-on-Strap">Type on Strap</a>
      </p>
      <div class="footer-icons">
        <ul>
          <!-- Social icons from Font Awesome, if enabled -->
        </ul>
      </div>
    </footer>
  </body>
</html>
