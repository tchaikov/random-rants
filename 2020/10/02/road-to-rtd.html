<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.2.6
    Copyright 2016-2020 Sylhare
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1"
    />

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css" />

    <!--Favicon-->
    <link rel="shortcut icon" href="" type="image/x-icon" />

    <!-- Canonical -->
    <link
      rel="canonical"
      href="https://blog.k3fu.xyz/2020/10/02/road-to-rtd.html"
    />

    <!-- RSS -->
    <link
      rel="alternate"
      type="application/atom+xml"
      title="some random rants"
      href="https://blog.k3fu.xyz/feed.xml"
    />

    <!-- KaTeX 0.12.0 -->
    <!-- if you have any issue check https://github.com/KaTeX/KaTeX -->

    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script
      defer
      src="/assets/js/vendor/auto-render.min.js"
      onload="renderMathInElement(document.body);"
    ></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = "cookie-notice-dismissed-https://blog.k3fu.xyz";
      const isCookieConsent = "";
      const analyticsName = "";
    </script>

    <!-- seo tags -->
    <meta property="og:image" content="https://blog.k3fu.xyz/" />
    <!-- Begin Jekyll SEO tag v2.7.1 -->
    <title>Read the Docs 之路 | some random rants</title>
    <meta name="generator" content="Jekyll v4.1.1" />
    <meta property="og:title" content="Read the Docs 之路" />
    <meta name="author" content="Kefu Chai" />
    <meta property="og:locale" content="en" />
    <meta
      name="description"
      content="最近为了支持多单词的准确搜索，把 Ceph 的文档编译和 host 转移到了 Read the Docs 上。但是还有一些问题。"
    />
    <meta
      property="og:description"
      content="最近为了支持多单词的准确搜索，把 Ceph 的文档编译和 host 转移到了 Read the Docs 上。但是还有一些问题。"
    />
    <link
      rel="canonical"
      href="https://blog.k3fu.xyz/2020/10/02/road-to-rtd.html"
    />
    <meta
      property="og:url"
      content="https://blog.k3fu.xyz/2020/10/02/road-to-rtd.html"
    />
    <meta property="og:site_name" content="some random rants" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2020-10-02T00:00:00+00:00"
    />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="Read the Docs 之路" />
    <script type="application/ld+json">
      {
        "description": "最近为了支持多单词的准确搜索，把 Ceph 的文档编译和 host 转移到了 Read the Docs 上。但是还有一些问题。",
        "url": "https://blog.k3fu.xyz/2020/10/02/road-to-rtd.html",
        "@type": "BlogPosting",
        "headline": "Read the Docs 之路",
        "dateModified": "2020-10-02T00:00:00+00:00",
        "datePublished": "2020-10-02T00:00:00+00:00",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://blog.k3fu.xyz/2020/10/02/road-to-rtd.html"
        },
        "author": { "@type": "Person", "name": "Kefu Chai" },
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <!-- RSS -->
    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://blog.k3fu.xyz/feed.xml"
      title="some random rants"
    />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="Read the Docs 之路" />
    <meta
      name="twitter:description"
      content="最近为了支持多单词的准确搜索，把 Ceph 的文档编译和 host 转移到了 Read the Docs 上。但是还有一些问题。Ceph 里的 API 文档Sphinx 的搜索假的 librados方案Sphinx 能看见的预处理结果加入 stub 函数浏览器能看到的Ceph 里的 API 文档Ceph 用 Sp..."
    />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:image" content="https://blog.k3fu.xyz/" />
  </head>

  <body>
    <header class="site-header">
      <!-- Logo and title -->
      <div class="branding">
        <h1 class="site-title">
          <a aria-label="some random rants" href="/"> some random rants </a>
        </h1>
      </div>

      <!-- Toggle menu -->
      <nav class="clear">
        <a aria-label="pull" id="pull" class="toggle" href="#">
          <i class="fa fa-bars fa-lg"></i>
        </a>

        <!-- Menu -->
        <ul class="hide">
          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="关于" title="关于" href="/about/">
              关于
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="搜索" title="搜索" href="/search/">
              <i class="fa fa-search" aria-hidden="true"></i>
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="Tags" title="Tags" href="/tags/">
              <i class="fa fa-tags" aria-hidden="true"></i>
            </a>
          </li>
        </ul>
      </nav>
    </header>

    <div class="content">
      <article>
        <header id="main" style="">
          <div class="title-padder">
            <h1 id="Read+the+Docs+%E4%B9%8B%E8%B7%AF" class="title">
              Read the Docs 之路
            </h1>

            <div class="post-info">
              <p class="meta">October 2, 2020</p>
            </div>
          </div>
        </header>

        <section class="post-content">
          <div id="preamble">
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  最近为了支持多单词的准确搜索，把 Ceph 的文档编译和 host
                  转移到了
                  <a href="https://readthedocs.org">Read the Docs</a>
                  上。但是还有一些问题。
                </p>
              </div>
              <div id="toc" class="toc">
                <div id="toctitle" class="title"></div>
                <ul class="sectlevel1">
                  <li><a href="#ceph-里的-api-文档">Ceph 里的 API 文档</a></li>
                  <li><a href="#sphinx-的搜索">Sphinx 的搜索</a></li>
                  <li><a href="#假的-librados">假的 librados</a></li>
                  <li>
                    <a href="#方案">方案</a>
                    <ul class="sectlevel2">
                      <li>
                        <a href="#sphinx-能看见的预处理结果"
                          >Sphinx 能看见的预处理结果</a
                        >
                      </li>
                      <li><a href="#加入-stub-函数">加入 stub 函数</a></li>
                      <li><a href="#浏览器能看到的">浏览器能看到的</a></li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="ceph-里的-api-文档">Ceph 里的 API 文档</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  Ceph 用
                  <a href="https://www.sphinx-doc.org/">Sphinx</a>
                  编译文档。它作为一个平台提供
                  librados，让大家可以用它写程序。librados
                  有各种语言的绑定，其中一些有对应的文档：
                </p>
              </div>
              <div class="ulist">
                <ul>
                  <li>
                    <p>
                      C: 用
                      <a href="https://breathe.readthedocs.io/">Breathe</a> 的
                      <a
                        href="https://breathe.readthedocs.io/en/latest/directives.html#autodoxygenfile"
                        >autodoxygenfile</a
                      >
                      directive
                    </p>
                  </li>
                  <li>
                    <p>
                      C&#43;&#43;: 还没有加上去。不过我觉得用 Breathe 和 Doxygen
                      的组合应该就够了
                    </p>
                  </li>
                  <li>
                    <p>
                      Python: Sphinx 有内置的支持，即
                      <a
                        href="https://www.sphinx-doc.org/en/master/usage/extensions/autodoc.html"
                        >sphinx.ext.autodoc</a
                      >
                      扩展。我们主要用它的 <code>automethod</code> directive
                    </p>
                  </li>
                  <li>
                    <p>
                      OpenAPI: 用
                      <a href="https://github.com/sphinx-contrib/openapi"
                        >sphinxcontrib.openapi</a
                      >
                      提供的 <code>openapi</code> directive
                    </p>
                  </li>
                </ul>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="sphinx-的搜索">Sphinx 的搜索</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  Sphinx 内置有搜索功能，它也支持多词搜索，但是通常我们希望搜索
                  source code 的话，Sphinx 会返回所有包含 source code
                  的文档，即使文档里面出现的是 "code source" 或者 "source of
                  code"。换言之，它不是我们习惯上的多词搜索。这个问题其他开发者也碰到了，在
                  Sphinx 上有相关的
                  <a href="https://github.com/sphinx-doc/sphinx/issues/3301"
                    >issue</a
                  >。我研究了一下，这个问题在于 Sphinx
                  搜索的实现比较直接。它分这么几步
                </p>
              </div>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>
                      分词。每种语言的分词都不一样。值得一提的是，中文分词用的是<a
                        href="https://github.com/fxsjy/jieba"
                        >“结巴”分词</a
                      >
                    </p>
                  </li>
                  <li>
                    <p>
                      逐词预处理，用对应语言的 stemming
                      规则把词归一化。英语的实现可以参考<a
                        href="https://github.com/sphinx-doc/sphinx/blob/master/sphinx/search/en.py"
                        >这里</a
                      >
                    </p>
                    <div class="olist loweralpha">
                      <ol class="loweralpha" type="a">
                        <li>
                          <p>
                            去掉后缀。比如说 apples 这个词就会变成
                            apple。civilize 则会变成 civil。
                          </p>
                        </li>
                        <li>
                          <p>
                            去掉常见的介词、连词和代词。比如说 at、and 和 they
                            就会被去掉。
                          </p>
                        </li>
                      </ol>
                    </div>
                  </li>
                  <li>
                    <p>
                      把索引关系加入倒排表。组织成一个大数据结构，保存在磁盘上。
                    </p>
                  </li>
                  <li>
                    <p>在搜索的时候，javascript 会直接从这个表里面找。</p>
                  </li>
                </ol>
              </div>
              <div class="paragraph">
                <p>
                  所以可以想见，如果我们搜索 "fuse support" 想看看 Ceph 对 FUSE
                  的支持，它会返回 mount.fuse.ceph 的
                  <a
                    href="https://docs.ceph.com/en/latest/man/8/mount.fuse.ceph/"
                    >manpage</a
                  >。这虽然也不算离谱，但是里面出现的 support 是这么一句话
                </p>
              </div>
              <div class="quoteblock">
                <blockquote>
                  <div class="paragraph">
                    <p>The old format /etc/fstab entries are also supported:</p>
                  </div>
                </blockquote>
              </div>
              <div class="paragraph">
                <p>
                  通篇没有出现 "fuse support" 这个序列。搜索返回了 32 篇文章，后
                  31 篇 文章被检索到的关键字就是
                  unsupported。这个很可能不是我们想要的。而 RTD 的多词搜索的<a
                    href="https://docs.ceph.com/en/latest/search/?q=fuse+support"
                    >结果</a
                  >要好很多。对于不挑剔的读者基本上够用了。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  那为什么要纠结多词搜索呢？因为我们很多命令是多个单词构成的。比如说
                </p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre
                    class="rouge highlight"
                  ><code data-lang="shell">ceph <span class="nb">df</span></code></pre>
                </div>
              </div>
              <div class="paragraph">
                <p>
                  要是用户想搜索 "ceph
                  df"，多词搜索要是能精确匹配，问题不就能解决了吗？那有没有其他办法呢？
                </p>
              </div>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>
                      google 的站内搜索。但是 google
                      是一个商业公司。有的人可能会浑身不自在，如果他用一个广告公司的搜索。虽然在这个世界上，我们和商业公司有千丝万缕的联系，但是，哎。让我们留一点理想主义的念想吧。
                    </p>
                  </li>
                  <li>
                    <p>
                      直接用 Read the Docs 的一揽子方案。它和
                      <a href="https://travis-ci.org">travis</a>
                      这些服务很像，不仅内置了 CI 的功能，也能帮着 host
                      这些静态页面。对我们很合适。但是它的 build
                      流程是很死的。看看它的<a
                        href="https://docs.readthedocs.io/en/stable/config-file/v2.html"
                        >配置文件</a
                      >就知道了。这是为一个纯 Python
                      项目度身定制的。我们后文分析这个限制的影响。
                    </p>
                  </li>
                  <li>
                    <p>
                      其他 sphinx search
                      plugin。找了一圈，没有不收费的。功能比较好的也需要自己搭建
                      <a href="https://www.elastic.co/products/elasticsearch"
                        >Elasticsearch</a
                      >。RTD 开源了他们的<a
                        href="https://github.com/readthedocs/readthedocs-sphinx-search"
                        >方案</a
                      >。但是一想到要挠我们实验室小哥的门，我就知趣地把爪子收起来了。
                    </p>
                  </li>
                </ol>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="假的-librados">假的 librados</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>Read the Docs 的搜索不错，但是它的限制也很明显。</p>
              </div>
              <div class="ulist">
                <ul>
                  <li>
                    <p>
                      只能通过
                      <code>requirements.txt</code> 安装第三方依赖。那么
                      <code>requirements.txt</code> 到底是啥呢？它是 pip 用来给
                      <code>pip install</code> 传参数的。
                      <a
                        href="https://pip.pypa.io/en/stable/reference/pip_install/#requirements-file-format"
                        >文档</a
                      >说得明白。
                    </p>
                  </li>
                  <li>
                    <p>
                      也可以用 setuptools 或者 pip 安装源码里面的 Python 项目。
                    </p>
                  </li>
                  <li>
                    <p>
                      没有预处理阶段。<code>pip</code> 装好了，直接就是
                      <code>sphinx-build</code>。
                    </p>
                  </li>
                </ul>
              </div>
              <div class="paragraph">
                <p>我们回到各种语言的绑定：</p>
              </div>
              <div class="ulist">
                <ul>
                  <li>
                    <p>
                      C:
                      <a href="https://breathe.readthedocs.io/">Breathe</a>
                      其实本身并不能解析 C
                      代码里面的注释，也不能理解头文件。它事实上担当的角色是
                      Doxygen 产生的 XML 文件到 Sphinx 中间的桥梁。但是如果这些
                      XML 不存在，巧妇难为无米之炊。所以它会调用用 Doxygen
                      预处理一下指定的文件。但是问题来了，doxygen
                      怎么安装呢？它是一个 C++ 的项目。
                    </p>
                  </li>
                  <li>
                    <p>
                      Python: <code>automethod</code> 读取制定方法的
                      docstring，产生 Sphinx 的文档。最近一部分代码用上了
                      <a href="https://www.python.org/dev/peps/pep-0484/"
                        >PEP484</a
                      >
                      风格的标注，所以我们也用
                      <a
                        href="https://github.com/agronholm/sphinx-autodoc-typehints"
                        >sphinx_autodoc_typehints</a
                      >
                      来把这些标注变成 Sphinx 文档。这两种办法都要求 Sphinx 的
                      Python 环境能访问被处理的 Python 扩展 (模块)。
                    </p>
                  </li>
                  <li>
                    <p>
                      OpenAPI: <code>openapi</code> 读取的是一个 yaml
                      文件。我们目前解决这个问题的办法是直接把这个文件放到了
                      repo 里面。但是大家都知道这个 yaml
                      文件其实是从代码产生的。把预处理的结果放到 repo
                      里面显然不是一个最好的方案，在现阶段这是一个折中。
                    </p>
                  </li>
                </ul>
              </div>
              <div class="paragraph">
                <p>
                  但是对于 Python API 来说，以 python-rados 为例，它是用
                  <a href="https://cython.org">Cython</a> 编写的 Python
                  扩展，它的底层则是 librados C
                  API。我们编译文档的时候其实并不需要一个功能上完备的
                  librados，我们只需要让 sphinx 能导入 python-rados
                  就行了。sphinx 并不会真正运行 python-rados
                  的函数，它只会读取代码里面的元数据。所以 Ceph
                  里面用了一个比较取巧的<a
                    href="https://github.com/ceph/ceph/blob/master/admin/build-doc"
                    >方法</a
                  >。
                </p>
              </div>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>
                      为 <code>lib/librados.so</code> 建立一个空链接，指向
                      <code>lib/librados.so.1</code>
                    </p>
                  </li>
                  <li>
                    <p>用 GCC 编译一个空的 <code>lib/librados.so.1</code></p>
                  </li>
                  <li>
                    <p>
                      用 <code>pip</code> 安装 python-rados，pip 会自动执行
                      <code>setup.py</code> 脚本，后者会
                    </p>
                    <div class="olist loweralpha">
                      <ol class="loweralpha" type="a">
                        <li>
                          <p>
                            调用 Cython 编译对应的 rados.pyx，生成 C 代码，然后
                          </p>
                        </li>
                        <li>
                          <p>
                            GCC
                            继续用指定源代码里的头文件目录，刚才生成的空动态链接库，生成
                            rados 的 Python 扩展。
                          </p>
                        </li>
                      </ol>
                    </div>
                  </li>
                  <li>
                    <p>
                      至此，rados 的 python 扩展编译好了。但是它链接的
                      <code>librados.so</code> 只是个空壳子。如果有人希望
                      <code>import rados</code>
                      ，一定会出错。因为那些符号都不存在呢。所以我们用
                      <code>nm</code> 分析这个 Python
                      extension，找出它引用的所有符号，看看它有没有 librados API
                      的前缀。把这些符号，其实也是函数，统一写成
                      <code>void func(void) {}</code> 的样子，用管道交给 GCC
                      生成新的
                      <code>lib/librados.so.1</code> 。虽然它是假的，但是至少
                      <code>import</code> 的时候就不会出错了。
                    </p>
                  </li>
                </ol>
              </div>
              <div class="imageblock">
                <div class="content">
                  <img
                    src="/images/diag-575fae6deb6a6d2a191da4c460feaf0f.png"
                    alt="Diagram"
                    width="1010"
                    height="336"
                  />
                </div>
              </div>
              <div class="paragraph">
                <p>
                  OpenAPI 文档的 yaml
                  文件的产生过程要简单很多，但是也需要使用我们自己编写的 python
                  脚本。但是 RTD 的
                  <code>requirements.txt</code> 没法实现这么复杂的预处理逻辑。
                </p>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="方案">方案</h2>
            <div class="sectionbody">
              <div class="sect2">
                <h3 id="sphinx-能看见的预处理结果">
                  Sphinx 能看见的预处理结果
                </h3>
                <div class="paragraph">
                  <p>
                    为了能有一个 librados，我们可以在
                    <a href="https://pypi.org">PyPI</a> 注册一个项目，让 Ceph
                    发布新版本的时候也更新它。同时，我们的文档编译流程也能直接从
                    PyPI 安装 python-rados。openapi.yaml
                    其实也可以放在这里面。具体说就是
                  </p>
                </div>
                <div class="olist arabic">
                  <ol class="arabic">
                    <li>
                      <p>
                        注册 python-rados 项目。其他 Python 绑定也同理，比如
                        cephfs、rgw、rbd。
                      </p>
                    </li>
                    <li>
                      <p>
                        一旦修改任何 Python 绑定的 pyx，就需要发布一个新版。
                      </p>
                    </li>
                    <li>
                      <p>
                        让 <code>ceph/admin/doc-read-the-docs.txt</code> 安装
                        python-rados， python-cephfs 等。
                      </p>
                    </li>
                  </ol>
                </div>
              </div>
              <div class="sect2">
                <h3 id="加入-stub-函数">加入 stub 函数</h3>
                <div class="paragraph">
                  <p>
                    在编译文档的时候，在
                    <code>rados.pyx</code> 中实现所有使用到的 C
                    函数。不过需要注意，这些函数也应该暴露出来给 python-cephfs
                    它们用。当然，只有在编译文档的时候才这么做。
                  </p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="浏览器能看到的">浏览器能看到的</h3>
                <div class="paragraph">
                  <p>
                    另外一个办法就是保留我们的 CI 流程，让它编译 API
                    相关的文档，然后让 RTD 的文档引用我们自己编译的文档。这需要
                  </p>
                </div>
                <div class="olist arabic">
                  <ol class="arabic">
                    <li>
                      <p>
                        新建一个域名，专门用来保存 API
                        文档。题外话，它也可以用来保存 CI 产生的文档。
                      </p>
                    </li>
                    <li>
                      <p>修改文档里面所有引用 API 文档的超链接，加入条件：</p>
                      <div class="ulist">
                        <ul>
                          <li>
                            <p>如果是 RTD 编译的话，就链接到刚才的域名</p>
                          </li>
                          <li>
                            <p>其他情况，就使用相对路径</p>
                          </li>
                        </ul>
                      </div>
                    </li>
                  </ol>
                </div>
              </div>
            </div>
          </div>
        </section>

        <!-- Social media shares -->

        <!-- Tag list -->

        <footer>
          <div class="tag-list">
            <div class="meta">Tags</div>

            <a class="button" href="/tags#ceph">
              <p><i class="fa fa-tag fa-fw"></i> ceph</p>
            </a>

            <a class="button" href="/tags#ci">
              <p><i class="fa fa-tag fa-fw"></i> ci</p>
            </a>
          </div>
        </footer>
      </article>

      <!-- Disqus -->

      <!-- Post navigation -->

      <div id="post-nav">
        <div id="previous-post">
          <a alt="求值的顺序" href="/2020/10/12/order-of-evaluation.html">
            <p>Previous post</p>
            求值的顺序
          </a>
        </div>

        <div id="next-post">
          <a alt="std::error_code" href="/2020/09/30/error-code.html">
            <p>Next post</p>
            std::error_code
          </a>
        </div>
      </div>

      <!-- To change color of links in the page -->
      <style>
        header#main {
          background-repeat: no-repeat;
        }
      </style>
    </div>
    <footer class="site-footer">
      <p class="text">
        Powered by <a href="https://jekyllrb.com/">Jekyll</a> with
        <a href="https://github.com/sylhare/Type-on-Strap">Type on Strap</a>
      </p>
      <div class="footer-icons">
        <ul>
          <!-- Social icons from Font Awesome, if enabled -->
        </ul>
      </div>
    </footer>
  </body>
</html>
