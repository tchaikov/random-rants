<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.4.4
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=0.5, maximum-scale=5"
    />

    <!-- Theme Mode-->

    <script>
      const isAutoTheme = true;
      document.documentElement.setAttribute(
        "data-theme",
        sessionStorage.getItem("theme")
      );
    </script>

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css" />

    <!--Favicon-->
    <link rel="shortcut icon" href="" type="image/x-icon" />

    <!-- KaTeX 0.15.2 -->

    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script
      defer
      src="/assets/js/vendor/auto-render.min.js"
      onload="renderMathInElement(document.body);"
    ></script>

    <!-- Mermaid 9.1.1 -->

    <!-- Simple Jekyll Search 1.10.0 -->
    <script
      src="/assets/js/vendor/simple-jekyll-search.min.js"
      type="text/javascript"
    ></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = "cookie-notice-dismissed-https://blog.k3fu.xyz";
      const isCookieConsent = "";
      const analyticsName = "";
      const analyticsNameGA4 = "";
    </script>

    <!-- seo tags -->
    <meta property="og:image" content="https://blog.k3fu.xyz/" />

    <meta property="og:type" content="website" />

    <!-- Begin Jekyll SEO tag v2.7.1 -->
    <title>maybe_yield_awaiter | some random rants</title>
    <meta name="generator" content="Jekyll v4.1.1" />
    <meta property="og:title" content="maybe_yield_awaiter" />
    <meta name="author" content="Kefu Chai" />
    <meta property="og:locale" content="en" />
    <meta
      name="description"
      content="说说 awaiter 的生命周期，和最近一位同事发现的 maybe_yield_awaiter 的 bug。"
    />
    <meta
      property="og:description"
      content="说说 awaiter 的生命周期，和最近一位同事发现的 maybe_yield_awaiter 的 bug。"
    />
    <link
      rel="canonical"
      href="https://blog.k3fu.xyz/2023/07/26/maybe-yield.html"
    />
    <meta
      property="og:url"
      content="https://blog.k3fu.xyz/2023/07/26/maybe-yield.html"
    />
    <meta property="og:site_name" content="some random rants" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2023-07-26T00:00:00+00:00"
    />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="maybe_yield_awaiter" />
    <script type="application/ld+json">
      {
        "author": { "@type": "Person", "name": "Kefu Chai" },
        "description": "说说 awaiter 的生命周期，和最近一位同事发现的 maybe_yield_awaiter 的 bug。",
        "url": "https://blog.k3fu.xyz/2023/07/26/maybe-yield.html",
        "@type": "BlogPosting",
        "headline": "maybe_yield_awaiter",
        "dateModified": "2023-07-26T00:00:00+00:00",
        "datePublished": "2023-07-26T00:00:00+00:00",
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://blog.k3fu.xyz/2023/07/26/maybe-yield.html"
        },
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <!-- RSS -->
    <link
      rel="alternate"
      type="application/atom+xml"
      title="some random rants"
      href="https://blog.k3fu.xyz/feed.xml"
    />
    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://blog.k3fu.xyz/feed.xml"
      title="some random rants"
    />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="maybe_yield_awaiter" />
    <meta
      name="twitter:description"
      content="说说 awaiter 的生命周期，和最近一位同事发现的 maybe_yield_awaiter 的 bug。Seastar 中的协程可以用 maybe_yield_awaiter 中途把 CPU 出让给 (yield)别人。一个协程如果流程很长，而且它运气也很好，没有被打断的话，那么就会长时间地占用 CPU，导致..."
    />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:image" content="https://blog.k3fu.xyz/" />
    <meta name="twitter:image:alt" content="maybe_yield_awaiter" />
  </head>

  <body>
    <header class="site-header">
      <!-- Logo and title -->
      <div class="branding">
        <a class="site-title" aria-label="some random rants" href="/">
          some random rants
        </a>
      </div>

      <!-- Toggle menu -->
      <nav class="clear">
        <a aria-label="pull" id="pull" class="toggle" href="#">
          <i class="fas fa-bars fa-lg"></i>
        </a>

        <!-- Menu -->
        <ul class="hide">
          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="关于" title="关于" href="/about/">
              关于
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="搜索" title="搜索" href="/search/">
              <i class="fas fa-search" aria-hidden="true"></i>
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="Tags" title="Tags" href="/tags/">
              <i class="fas fa-tags" aria-hidden="true"></i>
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a
              id="theme-toggle"
              title="maybe_yield_awaiter "
              aria-label="maybe_yield_awaiter"
              onclick="themeToggle()"
            ></a>
          </li>
        </ul>
      </nav>
    </header>

    <div class="content">
      <article>
        <header id="main" style="">
          <div class="title-padder">
            <h1 id="maybe_yield_awaiter" class="title">maybe_yield_awaiter</h1>

            <div class="post-info">
              <p class="meta">July 26, 2023</p>
            </div>
          </div>
        </header>

        <section class="post-content">
          <div id="preamble">
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  说说 awaiter 的生命周期，和最近一位同事发现的
                  <code>maybe_yield_awaiter</code> 的 bug。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  Seastar 中的协程可以用 <code>maybe_yield_awaiter</code> 中途把
                  CPU 出让给 (yield)
                  别人。一个协程如果流程很长，而且它运气也很好，没有被打断的话，那么就会长时间地占用
                  CPU，导致这个核上的其他任务被饿死。我们知道，协程之所有叫做“协”程，就是因为协程和协程大家都是谦谦君子，互相礼让，这样才能有比较好的响应和延迟。<code
                    >maybe_yield_awaiter</code
                  >
                  被用来检查当前是不是有正在亟待处理的事件。如果有的话，它就会抢占当前的协程，把它手里的
                  CPU 借用一会儿，把急事完成了，再把 CPU 还回来。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  比如说，如果协程有个很大的循环，处理上万个元素，那么我们很可能会在循环里面插上几个
                </p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre
                    class="rouge highlight"
                  ><code data-lang="c++"><span class="k">co_await</span> <span class="n">coroutine</span><span class="o">::</span><span class="n">maybe_yield</span><span class="p">();</span></code></pre>
                </div>
              </div>
              <div class="paragraph">
                <p>
                  让这个协程也能照顾一下其他人的需要，避免产生饥饿 (starve)
                  的情况，导致 reactor 出现 stall 告警。
                </p>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="co_await">co_await</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  在讨论 bug 之前，还是需要和大家一起再复习一下
                  <code>co_await</code> 。毕竟协程是比较高层的抽象，而
                  C&#43;&#43;20
                  的协程又很灵活，需要编译器和协程库，乃至用户程序的通力协作才能完成工作。
                  C&#43;&#43; 中的
                  <code>co_await</code>
                  是个操作符，后面跟着操作数，即一个表达式：
                </p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre
                    class="rouge highlight"
                  ><code data-lang="c++"><span class="k">co_await</span> <span class="n">expr</span></code></pre>
                </div>
              </div>
              <div class="paragraph">
                <p>
                  中的 <code>expr</code> 需要根据具体情况转换成 awaitable，这样
                  <code>co_await</code> 才能知道下一步是<span
                    class="line-through"
                    >走还是留</span
                  >继续还是歇会儿再来。在这里，
                  <code>maybe_yield()</code> 构造一个
                  <code>maybe_yield</code> 的 awaitable 对象，它的
                  <code>co_await</code>
                  操作符的实现的返回值是个 prvalue。所以按照
                  <a
                    href="https://en.cppreference.com/w/cpp/language/coroutines#co_await"
                    >cppreference</a
                  >
                  的说法，最终的 awaiter 是这个 prvalue
                  <a
                    href="https://en.cppreference.com/w/cpp/language/implicit_conversion#Temporary_materialization"
                    >materialized</a
                  >
                  之后的临时对象。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  不管怎么样，我们找到了 awaitable 的最终所在：故事的主角
                  <code>maybe_yield_awaiter</code>
                  。这个临时对象和调用者协程定义的其他局部变量一样，存活在栈上。具体说，存活在
                  coroutine frame 上，在
                  <code>maybe_yield_awaiter::await_ready()</code> 告诉 coroutine
                  runtime 它要暂停运行之后，
                  <code>maybe_yield_awaiter::await_suspend()</code>
                  把自己直接挂到任务队列上去，要求被调度恢复执行。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  <code>maybe_yield_awaiter</code>
                  等待的结果一旦出现，它就得以恢复运行，虽然这里的结果是
                  <code>void</code>，
                  <code>maybe_yield_awaiter::await_resume()</code>
                  仍然会被调用，它负责为
                  <code>co_await</code> 的调用方提供返回值，毕竟
                  <code>co_await expr</code> 是允许返回值的。
                </p>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="task-和-waiting_task">task 和 waiting_task()</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  前面提到， <code>maybe_yield_awaiter</code> 可以用来出让
                  CPU。但是需要重点提出的是，
                  <code>maybe_yield_awaiter</code> 是继承自
                  <code>task</code> 的。那么什么是 <code>task</code> 呢？
                </p>
              </div>
              <div class="paragraph">
                <p>
                  在 Seastar 中，<code>task</code>
                  代表着一个可调度的最小的任务单位，如果大家看看
                  <code>future::schedule()</code> 就会注意到，它其实直接
                  <code>new</code> 了一个 task。如果这个 task
                  不能立即返回的话，它会被当成参数传给
                  <code>::seastar::schedule()</code> 。而
                  <code>seastar::schedule()</code> 的作用就是把
                  <code>task</code> 加到任务队列上去。在调度器调度执行
                  <code>task</code> 的时候，它会调用
                  <code>task&#8594;run_and_dispose()</code> 。请注意，这里的
                  <code>task</code> 就是
                  <code>maybe_yield_awaiter</code>
                  这个对象的地址。所以可以看出来，我们有个前提，即在这个 task
                  调度完成之前，这个指针都是有效的。因为
                  <code>maybe_yield_awaiter</code> 应该保存在调用者的 coroutine
                  frame 上，所以 <code>*this</code> 在
                  <code>maybe_yield_awaiter::await_resume()</code>
                  返回前都一直是有效的。自然这个前提是成立的。这里把和
                  <code>task</code> 相关的函数摘录下来：
                </p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre
                    class="rouge highlight"
                  ><code data-lang="c++"><span class="k">struct</span> <span class="nc">maybe_yield_awaiter</span> <span class="k">final</span> <span class="o">:</span> <span class="n">task</span> <span class="p">{</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="n">coroutine_handle_t</span> <span class="n">when_ready</span><span class="p">;</span>
    <span class="n">task</span><span class="o">*</span> <span class="n">main_coroutine_task</span><span class="p">;</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
    <span class="kt">void</span> <span class="n">await_suspend</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">coroutine_handle</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">h</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">when_ready</span> <span class="o">=</span> <span class="n">h</span><span class="p">;</span>
        <span class="n">main_coroutine_task</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">h</span><span class="p">.</span><span class="n">promise</span><span class="p">();</span> <span class="c1">// for waiting_task()</span>
        <span class="n">schedule</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">run_and_dispose</span><span class="p">()</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">when_ready</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
        <span class="c1">// No need to delete, this is allocated on the coroutine frame</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="n">task</span><span class="o">*</span> <span class="n">waiting_task</span><span class="p">()</span> <span class="k">noexcept</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">main_coroutine_task</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre>
                </div>
              </div>
              <div class="paragraph">
                <p>
                  那么问题来了，
                  <code>waiting_task()</code> 是做什么用的呢？每个
                  <code>task</code> 都会实现它，这里，
                  <code>maybe_yield_awaiter</code>
                  返回的是它调用者的地址，而且，有意思的是，虽然
                  <code>maybe_yield_awaiter::await_suspend()</code>
                  是个模板函数，它却对 <code>T</code> 有着很强的假设。它要求
                  <code>std::coroutine_handle&lt;T&gt;::promise()</code>
                  的类型是个 <code>task</code> ！换句话说，它认为它的调用者的
                  promise 肯定是个 <code>task</code> 。我们去看看
                  <code>coroutine_traits_base::promise_type</code>
                  ，它还真的是个 <code>task</code> 。如果每个
                  <code>task</code> 都知道自己调用者的
                  <code>task</code
                  >，那么如果说协程从最外面的调用者一层一层地调用到最里面，构成了调用的链条。那么我们用
                  <code>waiting_task()</code>
                  其实也可以从最里面一层一层地，遍历这个链条的所有环节。如果大家用过
                  gdb 的话，就能意识到，这其实可以实现
                  <code>backtrace</code> 类似的功能，<code>backtrace</code> 通过
                  <code>$bp</code> 能找到之前的栈顶。而 Seastar 通过
                  <code>waiting_task()</code>
                  调用栈里面更高一层，道理是类似的。用图表示：
                </p>
              </div>
              <div class="imageblock">
                <div class="content">
                  <img
                    src="/images/diag-3f2ac577e2ce911434c66496c3d3270e.png"
                    alt="Diagram"
                    width="520"
                    height="238"
                  />
                </div>
              </div>
              <div class="paragraph">
                <p>
                  Seastar 中的 <code>current_tasktrace()</code> 用 Python
                  伪代码可以这么写：
                </p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre
                    class="rouge highlight"
                  ><code data-lang="python"><span class="k">def</span> <span class="nf">current_tasktrace</span><span class="p">():</span>
  <span class="n">stack_traces</span> <span class="o">=</span> <span class="p">[]</span>
  <span class="n">task</span> <span class="o">=</span> <span class="n">local_engine</span><span class="o">-&gt;</span><span class="n">current_task</span><span class="p">()</span>
  <span class="k">while</span> <span class="n">task</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">stack_traces</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">task_entry</span><span class="p">(</span><span class="n">task</span><span class="p">))</span>
    <span class="n">task</span> <span class="o">=</span> <span class="n">task</span><span class="p">.</span><span class="n">waiting_task</span><span class="p">()</span>
  <span class="k">return</span> <span class="n">stack_traces</span></code></pre>
                </div>
              </div>
              <div class="paragraph">
                <p>
                  folly 甚至专门有好几期
                  <a
                    href="https://developers.facebook.com/blog/post/2021/09/16/async-stack-traces-folly-Introduction/"
                    >blog</a
                  >
                  介绍它家的 stack trace 是怎么实现的。协程 backtrace
                  对于程序员的重要性可见一斑。要在生产环境里面使用的话，
                  backtrace 的支持是必不可少的。
                </p>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="问题分析">问题分析</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  在普通的程序调用中，有压栈就要有退栈。协程也是一样的，在调用子协程的时候，
                  <code>schedule(this)</code> 会把自己作为 task
                  挂到执行队列上去，当调度器执行 task 的时候，把
                  <code>_current_task</code> 设置成指向这个
                  <code>task</code> 指针。结合该 task 的
                  <code>waiting_task()</code>
                  方法，就能一层一层地回到最外层的调用者。当子协程退出的时候，它就需要把
                  <code>_current_task</code> 改回来，设置成调用者的 task ，即
                  <code>main_coroutine_task</code> 。因为
                  <code>maybe_yield_awaiter</code> 和 C&#43;&#43;20 之前的
                  Seastar
                  的协程不一样，它不是通过把一系列表达式串联起来形成的程序执行流程，而是借助
                  C&#43;&#43; 编译器、标准库和用户实现的 awaiter
                  完成的。前者在前序 future 完成之后，后面的 future
                  在调度时，会执行 <code>schedule()</code> 的动作，这样可以确保
                  <code>_current_task</code> 一直指向的是最新的
                  task。但是后者如果通过 awaiter
                  来实现子协程的话，而且子协程又是以
                  <code>task</code>
                  的形式被调用的话，那么在子协程准备回到父协程的时候，就需要把当时调用自己时
                  <code>schedule(this)</code> 产生的副作用消除掉，即如前所述
                </p>
              </div>
              <div class="listingblock">
                <div class="content">
                  <pre
                    class="rouge highlight"
                  ><code data-lang="c++"><span class="n">engine</span><span class="p">().</span><span class="n">_current_task</span> <span class="o">=</span> <span class="n">main_coroutine_task</span><span class="p">;</span></code></pre>
                </div>
              </div>
              <div class="paragraph">
                <p>
                  这样，如果父协程出错的话，那么它的 backtrace
                  才是准确的，否则第一个 frame 就会指向一个已经被释放的地址，即
                  use-after-free 。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  那么我们是不是真的需要在 backtrace 里面包含
                  <code>maybe_yield_awaiter</code> 呢？这里引用一下 folly blog
                  的话
                </p>
              </div>
              <div class="quoteblock">
                <blockquote>
                  <div class="paragraph">
                    <p>
                      Probably the most frequent place where developers see
                      stack traces is when programs crash. The folly library
                      already provides a signal handler that prints the stack
                      trace of the thread that is causing the program to crash.
                    </p>
                  </div>
                </blockquote>
              </div>
              <div class="paragraph">
                <p>
                  所以大家平时都是发现有个地方出问题了，才会看看那个地方到底在哪里。而
                  <code>maybe_yield()</code>
                  是一个不会出问题的地方，它做的事情就是什么都不做。自然也不会出错，或者崩溃。举例来说，在一个多线程的程序崩溃的时候，使用
                  GDB 的
                  <code>thread apply all backtrace</code>
                  命令我们可以看到程序每个线程的
                  backtrace。对协程的程序来说，利用刚才提到的
                  <code>_current_task</code> 和
                  <code>waiting_task()</code> ，我们也可以手搓出来个协程版的
                  <code>coroutine apply all backtrace</code>。而这些 backtrace
                  里面是不会包含那个做好事 yield
                  的协程的，因为人家做好事不留名，把运行的机会让给了别人。留名的那位是正在运行的协程。因此，在
                  <code>maybe_yield_awaiter</code> 里面实现
                  <code>waiting_task()</code> 并没有意义，更进一步，把它实现成
                  <code>task</code> 也不再有意义了。因为它的作用就是
                </p>
              </div>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>是否需要 yield</p>
                  </li>
                  <li>
                    <p>
                      yield
                      的话，在挂起之前，把父协程的挂在执行队列上。说明它已经准备好了，
                      随时可以运行。
                    </p>
                  </li>
                </ol>
              </div>
              <div class="paragraph">
                <p>
                  这些都不需要 <code>task</code> 参与。所以
                  <a href="https://github.com/michoecho">Michał</a> 的
                  <a href="https://github.com/scylladb/seastar/pull/1760"
                    >修正</a
                  >
                  也很简单明了：
                </p>
              </div>
              <div class="ulist">
                <ul>
                  <li>
                    <p>直接实现了前面两点</p>
                  </li>
                  <li>
                    <p>把 <code>task</code> 的继承关系去掉了。</p>
                  </li>
                </ul>
              </div>
            </div>
          </div>
        </section>

        <!-- Social media shares -->

        <!-- Tag list -->

        <div class="tag-list">
          <ul>
            <li class="meta">Tag</li>

            <li>
              <a class="button" href="/tags#seastar">
                <p><i class="fas fa-tag fa-fw fa-sm"></i> seastar</p>
              </a>
            </li>
          </ul>
        </div>
      </article>

      <!-- Post navigation -->

      <div id="post-nav">
        <div id="next-post">
          <a alt="io_uring 和 EAGAIN" href="/2022/10/18/iouring-eagain.html">
            <p>Next post</p>
            io_uring 和 EAGAIN
          </a>
        </div>
      </div>

      <!--Utterances-->

      <!-- Cusdis -->
      <div
        class="comments"
        id="cusdis_thread"
        data-host="https://cusdis.com"
        data-app-id="12e099bc-c554-4827-aeb8-e425c83d8176"
        data-page-id="_posts/2023-07-26-maybe-yield.adoc"
        data-page-url="/2023/07/26/maybe-yield.html"
        data-page-title="maybe_yield_awaiter"
        data-theme="auto"
      ></div>

      <script async src="https://cusdis.com/js/cusdis.es.js"></script>

      <!-- Disqus -->

      <!-- To change color of links in the page -->
      <style>
        header#main {
          background-size: cover;
          background-repeat: no-repeat;
          background-position: center;
        }
      </style>
    </div>
    <footer class="site-footer">
      <p class="text">
        Powered by <a href="https://jekyllrb.com/">Jekyll</a> with
        <a href="https://github.com/sylhare/Type-on-Strap">Type on Strap</a>
      </p>
      <div class="footer-icons">
        <ul>
          <!-- Social icons from Font Awesome, if enabled -->
        </ul>
      </div>
    </footer>
  </body>
</html>
