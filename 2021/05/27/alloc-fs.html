<!DOCTYPE html>
<!--
    Type on Strap jekyll theme v2.4.3
    Theme free for personal and commercial use under the MIT license
    https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE
-->
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1, minimum-scale=0.5, maximum-scale=5"
    />

    <!-- Theme Mode-->

    <script>
      const isAutoTheme = true;
      document.documentElement.setAttribute(
        "data-theme",
        sessionStorage.getItem("theme")
      );
    </script>

    <!-- Main JS (navbar.js, katex_init.js and masonry_init.js)-->
    <script defer src="/assets/js/main.min.js"></script>

    <!-- CSS -->
    <link rel="stylesheet" href="/assets/css/main.css" />

    <!--Favicon-->
    <link rel="shortcut icon" href="" type="image/x-icon" />

    <!-- KaTeX 0.15.2 -->

    <script defer src="/assets/js/vendor/katex.min.js"></script>
    <script
      defer
      src="/assets/js/vendor/auto-render.min.js"
      onload="renderMathInElement(document.body);"
    ></script>

    <!-- Mermaid 9.1.1 -->

    <!-- Simple Jekyll Search 1.10.0 -->
    <script
      src="/assets/js/vendor/simple-jekyll-search.min.js"
      type="text/javascript"
    ></script>

    <!-- Google Analytics / Cookie Consent -->
    <script>
      const cookieName = "cookie-notice-dismissed-https://blog.k3fu.xyz";
      const isCookieConsent = "";
      const analyticsName = "";
      const analyticsNameGA4 = "";
    </script>

    <!-- seo tags -->
    <meta property="og:image" content="https://blog.k3fu.xyz/" />

    <meta property="og:type" content="website" />

    <!-- Begin Jekyll SEO tag v2.7.1 -->
    <title>从 metaslabs allocator 说起 | some random rants</title>
    <meta name="generator" content="Jekyll v4.1.1" />
    <meta property="og:title" content="从 metaslabs allocator 说起" />
    <meta name="author" content="Kefu Chai" />
    <meta property="og:locale" content="en" />
    <meta
      name="description"
      content="系统设计里面有很多开放问题。解决问题的策略是基于经验不断演进的。"
    />
    <meta
      property="og:description"
      content="系统设计里面有很多开放问题。解决问题的策略是基于经验不断演进的。"
    />
    <link
      rel="canonical"
      href="https://blog.k3fu.xyz/2021/05/27/alloc-fs.html"
    />
    <meta
      property="og:url"
      content="https://blog.k3fu.xyz/2021/05/27/alloc-fs.html"
    />
    <meta property="og:site_name" content="some random rants" />
    <meta property="og:type" content="article" />
    <meta
      property="article:published_time"
      content="2021-05-27T00:00:00+00:00"
    />
    <meta name="twitter:card" content="summary" />
    <meta property="twitter:title" content="从 metaslabs allocator 说起" />
    <script type="application/ld+json">
      {
        "datePublished": "2021-05-27T00:00:00+00:00",
        "author": { "@type": "Person", "name": "Kefu Chai" },
        "mainEntityOfPage": {
          "@type": "WebPage",
          "@id": "https://blog.k3fu.xyz/2021/05/27/alloc-fs.html"
        },
        "description": "系统设计里面有很多开放问题。解决问题的策略是基于经验不断演进的。",
        "url": "https://blog.k3fu.xyz/2021/05/27/alloc-fs.html",
        "@type": "BlogPosting",
        "headline": "从 metaslabs allocator 说起",
        "dateModified": "2021-05-27T00:00:00+00:00",
        "@context": "https://schema.org"
      }
    </script>
    <!-- End Jekyll SEO tag -->

    <!-- RSS -->
    <link
      rel="alternate"
      type="application/atom+xml"
      title="some random rants"
      href="https://blog.k3fu.xyz/feed.xml"
    />
    <link
      type="application/atom+xml"
      rel="alternate"
      href="https://blog.k3fu.xyz/feed.xml"
      title="some random rants"
    />

    <!-- Twitter Cards -->
    <meta name="twitter:title" content="从 metaslabs allocator 说起" />
    <meta
      name="twitter:description"
      content="系统设计里面有很多开放问题。解决问题的策略是基于经验不断演进的。ceph 的 bluestore 有好几种 allocator。其中的 AvlAllocator 基本就是 ZFS 的 df (Dynamic Fit) Block Allocator 的 C++ 移植版。所以要清楚 AvlAllocator，就绕不..."
    />

    <meta name="twitter:card" content="summary" />
    <meta name="twitter:image" content="https://blog.k3fu.xyz/" />
    <meta name="twitter:image:alt" content="从 metaslabs allocator 说起" />
  </head>

  <body>
    <header class="site-header">
      <!-- Logo and title -->
      <div class="branding">
        <a class="site-title" aria-label="some random rants" href="/">
          some random rants
        </a>
      </div>

      <!-- Toggle menu -->
      <nav class="clear">
        <a aria-label="pull" id="pull" class="toggle" href="#">
          <i class="fas fa-bars fa-lg"></i>
        </a>

        <!-- Menu -->
        <ul class="hide">
          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="关于" title="关于" href="/about/">
              关于
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="搜索" title="搜索" href="/search/">
              <i class="fas fa-search" aria-hidden="true"></i>
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a class="clear" aria-label="Tags" title="Tags" href="/tags/">
              <i class="fas fa-tags" aria-hidden="true"></i>
            </a>
          </li>

          <li class="separator">|</li>
          <li>
            <a
              id="theme-toggle"
              title="从 metaslabs allocator 说起 "
              aria-label="从 metaslabs allocator 说起"
              onclick="themeToggle()"
            ></a>
          </li>
        </ul>
      </nav>
    </header>

    <div class="content">
      <article>
        <header id="main" style="">
          <div class="title-padder">
            <h1
              id="%E4%BB%8E+metaslabs+allocator+%E8%AF%B4%E8%B5%B7"
              class="title"
            >
              从 metaslabs allocator 说起
            </h1>

            <div class="post-info">
              <p class="meta">May 27, 2021</p>
            </div>
          </div>
        </header>

        <section class="post-content">
          <div id="preamble">
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  系统设计里面有很多开放问题。解决问题的策略是基于经验不断演进的。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  ceph 的 bluestore 有好几种 allocator。其中的 AvlAllocator
                  基本就是 ZFS 的 df (Dynamic Fit) Block Allocator 的 C++
                  移植版。所以要清楚 AvlAllocator，就绕不开 ZFS 的前辈。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  那么什么是
                  <a
                    href="https://github.com/openzfs/zfs/blob/60ffc1c460e4cdf3c3ca12c8840fd0675a98ed0d/module/zfs/metaslab.c#L1666"
                    >df allocator</a
                  >
                  呢？它和 metaslab 又有什么关系呢？故事要从 slab allocator
                  说起。
                </p>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="slab-allocator">slab allocator</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  我们知道 allocator
                  设计需要解决的问题就是在高效分配内存空间的同时最小化碎片。如果我们使用
                  first-fit
                  在空闲列表里面找指定大小的空闲块，搜索是快了，但是它可能产生更大的内部碎片。best-fit
                  虽然看上去很好，而且它会产生很小的内部碎片，这些碎片就像下脚料一样，很难利用了，因此性能其实也不见得就能改进很多。buddy
                  算法中所有的内存块都按照二的幂向上取整，这样方便搜索和方便回收，和合并伙伴内存块。但是这样也会造成相当的碎片，而且在频繁地内存分配和回收的时候，积极地合并策略也会浪费
                  CPU cycle。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  根据观察，系统里面经常会分配释放特定大小的内存块，比如说一个异步的分布式系统里面可能会分配大量的
                  mutex 来细粒度地管理它的
                  inode，每次构造和析构都对应着内存子系统的分配内存和释放内存的操作。有一个解决的办法就是维护一个专门的列表，保存特定大小的
                  extent。加入刚才说的 mutex 大小是 43
                  字节，那么我们可能就会用一个列表保存一系列大小为 43
                  字节的内存块。这样分配和释放这样大小的内存的速度就是 O(1)
                  的。这种列表根据具体的应用场景可以有好几个，要是 inode
                  的大小是固定的话，inode
                  也可以有个专门的列表。但是这样处理也带来了问题，到底应该为这种专用列表分配多少内存呢？还有一个重要的问题，就是内核里面频繁地创建和析构内核对象本身也会耗费大量的
                  CPU 资源，这种开销甚至比为这些对象分配内存的开销还要高。slab
                  allocator 应运而生。
                </p>
              </div>
              <div class="paragraph">
                <p>
                  slab allocator 最初是 Jeff Bonwick 为 Solaris
                  内核设计的，后来这个算法也用到了 zfs 和其他操作系统里面。slab
                  算法中的每个 slab，都对应着一类固定大小的对象。比如说 slab#1
                  就专门服务大小为 14 bytes 的对象，slab#2 对应 23 bytes
                  对象。在这个基础上，我们还有专门类型的 slab，比如专门提供
                  inode 的 slab，或者专门提供 mutex 的
                  slab，它们可以省去初始化和销毁对应类型对象的开销。每个 slab
                  由一个或多个物理地址连续的内存页构成。slab
                  从这一系列内存页为给定大小的对象分配内存。“专用列表”的思想其实是一种
                  cache，用来缓存特定大小内存块的分配信息。<code
                    >kmem_cache</code
                  >
                  中的 <code>slab_partial</code> 是一个 slab
                  的双向链表，其中每个元素都是一个 slab。当某个 slab 所有的
                  对象都回收的时候，这个 slab 就从
                  <code>slabs_partial</code> 移动到了
                  <code>slabs_free</code> 里面去，如果一个 slab
                  里面所有的页都分配了，那么这个 slab 就会加入
                  <code>slabs_full</code>。分配内存的时候先从
                  <code>slabs_partial</code> 里面找，找不到的时候才看
                  <code>slabs_free</code>。这样分配对象的时候更高效一些。
                </p>
              </div>
              <div class="imageblock">
                <div class="content">
                  <img
                    src="/images/diag-14afd5907efc8e5a56152af0db936dc3.png"
                    alt="Diagram"
                    width="1150"
                    height="294"
                  />
                </div>
              </div>
              <div class="paragraph">
                <p>
                  如果你在看的是 Linux，很可能你看的版本里面的 slab 已经<a
                    href="https://lwn.net/Articles/565097/"
                    >改</a
                  ><a href="https://lwn.net/Articles/629152/">进</a
                  ><a href="https://lwn.net/Articles/564381/">很多</a
                  >，不大一样了。
                </p>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="metaslab-allocator">metaslab allocator</h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  ZFS
                  作为当初所说的终极文件系统，包揽了从文件系统，卷管理系统，到块设备管理的所有工作。它引入了一个概念叫做
                  zpool，所以不管是裸设备还是 raid
                  设备都可以一股脑地扔到这个池子里，交给 ZFS 全权管理。所以 ZFS
                  的 allocator 要分配一个 extent 有三步：
                </p>
              </div>
              <div class="olist arabic">
                <ol class="arabic">
                  <li>
                    <p>
                      选择设备 (dynamic striping):
                      目标是让各个设备的空间使用率尽量平均。为了达成这个目标
                    </p>
                    <div class="olist loweralpha">
                      <ol class="loweralpha" type="a">
                        <li>
                          <p>稍微倾向于选择使用率低的设备</p>
                        </li>
                        <li>
                          <p>
                            如果其他因素都差不多，那么用
                            round-robin。但是粒度需要合适。因为如果粒度大了，比如每次都分个
                            1GB，那么顺序读写的时候，请求都会往一个设备上招呼，设备间的并发性就没法用上了。但是粒度太小也不好，比如说分了
                            4KB，就找下一个设备了，那么 buffer 和 cache
                            的效果就会大打折扣。zfs 发现 512K 是个比较合适的值。
                          </p>
                        </li>
                        <li>
                          <p>
                            ZFS 的数据在刷到数据盘之前，会先以 ZIL (ZFS Intent
                            Log) 的形式先落盘。这有点像 bluestore 里面 journal
                            的设计。ZFS 希望能通过引入这个 write cache
                            的机制，让写操作的数据先保存在比较快的设备 (SLOG)
                            上，之后再刷到目标设备，这样客户请求可以更快地完成。在需要低延迟低大量写数据时，就会使用
                            round-robin
                            调度设备，用类似扫射的方式，充分利用多设备的带宽。
                          </p>
                        </li>
                        <li>
                          <p>
                            striping
                            的策略可以根据数据的类型不同而不同。比如大块的顺序访问，小的随机访问，生命周期比较短的数据，比如刚才说的
                            ZIL，还有 dnode 这种保存 metadata 的数据。其中 dnode
                            有些类似普通文件系统里面的
                            inode。这些都是值得进一步挖掘和研究的地方。
                          </p>
                        </li>
                        <li>
                          <p>如果发现有设备性能不好，就应该尽量不使用它。</p>
                        </li>
                      </ol>
                    </div>
                  </li>
                  <li>
                    <p>
                      选择 metaslab:
                      每个设备都被切分成多个的区域，每个区域就是一个 slab。slab
                      的数量一般在 200 个左右。为什么是 200
                      个？其实也没有做很多分析。所以这个数字可能不是最优的。metaslab
                      0 在最靠外的磁道上，metaslab 200 在磁盘最靠里的磁道。每个
                      metaslab 都有个对应的 space map 用来跟踪 metaslab
                      的空闲空间。space map
                      是一个日志，记录着分配和回收的操作。所以分配空间的时候就会在
                      space map 最后面加一条记录，说明分配了哪个
                      extent，回收的时候也类似。需要注意的是，如果 space map
                      还不在内存里面，就需要从硬盘的 space map 日志重建。
                    </p>
                    <div class="olist loweralpha">
                      <ol class="loweralpha" type="a">
                        <li>
                          <p>
                            我们假设磁盘的扇区在磁道上分布基本是均匀的，而磁盘转动的角速度是恒定的。所以在外圈柱面
                            (cyliner)
                            的数据分布会比内圈的数据分布更密集，比例就是磁道的半径。<a
                              href="https://en.wikipedia.org/wiki/Logical_block_addressing"
                              >LBA 的寻址模式</a
                            >下，地址越低的 LBA
                            地址，对应的柱面就越靠外面。所以为了访问速度考虑，我们更希望用
                            LBA 地址更低的 metaslab。
                          </p>
                        </li>
                      </ol>
                    </div>
                  </li>
                  <li>
                    <p>
                      选择 block: ZFS 确定 metaslab 之后，就会从这个 metaslab
                      里面分配 block 或者说 extent。它首先从磁盘上读取对应的
                      space
                      map，然后重放它的分配和回收记录，用来更新内存里面用来表示空闲空间的
                      b-tree，树里面的节点对应空闲的 extent，树按照 extent 的
                      offset
                      排序。有了这个树就可以高效地分配连续的空间。同时它也是一个压缩
                      space map
                      的手段。如果分配和回收的操作很多互相抵消了，换句话说，如果树的规模很小，那么
                      ZFS 会重建硬盘上的 space
                      map，把它更新成内存里面那个更小的版本。space map
                      的设计有这么几个好处
                    </p>
                    <div class="olist loweralpha">
                      <ol class="loweralpha" type="a">
                        <li>
                          <p>
                            不需要初始化。一开始的时候，树里面只有一个
                            extent，表示整个设备是空闲的。
                          </p>
                        </li>
                        <li>
                          <p>
                            伸缩性好。无论管理的空间多大，内存里面会缓存 space
                            map 的最后一个 block。这一点是 bitmap 望尘莫及的。
                          </p>
                        </li>
                        <li>
                          <p>
                            性能没有痛点(pathology)，即不会因为特定的使用模式造成性能急剧降低。不管是分配和回收的模式怎样，space
                            map 的更新都很迅速。不管是 B-tree 还是
                            bitmap，在随机回收的时候，对数据结构的更新也是随机的，而且会产生很多写操作。虽然我们可以推迟更新下面的数据结构，把最近释放的
                            extent
                            保存在一个列表里面，等到这个列表太大了，再把它排序压缩，写回下面的
                            B-tree 或
                            bitmap，以期更好的性能，和写操作的局部性。但是 space
                            map 在这方面基本没有影响，因为它本身就是个 free
                            list。它记录 free 的方式就是写日志。
                          </p>
                        </li>
                        <li>
                          <p>
                            pool 很满或者很空的时候，space map 的都很快。不像
                            bitmap 在很满的时候搜索空闲块会更花时间。
                          </p>
                        </li>
                      </ol>
                    </div>
                  </li>
                </ol>
              </div>
              <div class="paragraph">
                <p>
                  其实还有第四步，如果 metaslab 里面没有能满足的
                  range，就选择一个新的 metaslab。然是如果根本没有能满足要求的
                  metaslab，而且也检查过了所有的设备。ZFS 就开始 gang！“gang”
                  的意思就是把这个大的请求拆解成多个不连续的小的请求，希望它们合起来能满足要求。所谓“gang”也有点三个臭皮匠顶一个诸葛亮的意思。但是这是
                  allocator 的最后一招了。不到万不得已，allocator 不会
                  gang，因为这样会产生非常多的碎片。
                </p>
              </div>
              <div class="imageblock">
                <div class="content">
                  <img
                    src="/images/diag-3fe849d4c2745b53fb3abc79e22872ac.png"
                    alt="Diagram"
                    width="610"
                    height="602"
                  />
                </div>
              </div>
              <div class="admonitionblock note">
                <table>
                  <tr>
                    <td class="icon">
                      <i class="fa icon-note" title="Note"></i>
                    </td>
                    <td class="content">
                      早先 ZFS 早期使用 AVL 树来保存 space map，但是后来因为 AVL
                      树太耗费内存了，每个节点都需要额外用 48 byte 保存 AVL
                      树需要的信息，每个 extent 都有自己的节点，所以对于海量的小
                      extent，这样的开销是巨大的。所以 ZFS 后来<a
                        href="https://www.illumos.org/issues/11971"
                        >改用</a
                      >了 b-tree。至于为什么一开始选择
                      AVL。其实也没有什么特别的考虑，主要是作者在实现 metaslab
                      allocator 的时候，Solaris 内核里面已经有 AVL
                      树了，所以就用了它。理论上说，红黑树也是可以用的。只要它里面的元素是有序的就行。
                    </td>
                  </tr>
                </table>
              </div>
              <div class="sect2">
                <h3 id="space-map">space map</h3>
                <div class="paragraph">
                  <p>
                    space map 在内存里面由 <code>ms_tree</code> 和
                    <code>ms_size_tree</code> 表示。其中 “ms” 是 MetaSlab
                    的缩写。两者保存的是同样的信息。
                  </p>
                </div>
                <div class="ulist">
                  <ul>
                    <li>
                      <p>
                        <code>ms_tree</code>
                        中的空闲空间是按照它们的地址排序的。这样方便合并相邻的
                        extent。
                      </p>
                    </li>
                    <li>
                      <p>
                        <code>ms_size_tree</code>
                        则是按照大小排序的。这样可以根据需要 extent
                        的大小来搜索。
                      </p>
                    </li>
                  </ul>
                </div>
                <div class="paragraph">
                  <p>
                    在 Paul Dagnelie 的
                    <a href="https://www.youtube.com/watch?v=LZpaTGNvalE"
                      >Metaslab Allocation Performance</a
                    >
                    里面提到，为了减少内存的压力，甚至可以在
                    <code>ms_size_tree</code> 里面保存部分的
                    range。因为对于比较小的 alloc 请求来说，顺着 cursor
                    找，一般来说很容易在放弃之前找到足够大的 extent。所以只要
                    <code>ms_tree</code> 里面能找到就够了。让
                    <code>ms_size_tree</code> 保存比较大的 range，那些 extent
                    才是比较难找到的。
                  </p>
                </div>
              </div>
              <div class="sect2">
                <h3 id="选择-rangeextentblock-的策略">
                  选择 range/extent/block 的策略
                </h3>
                <div class="paragraph">
                  <p>
                    这些策略使用 cursor
                    记录上次分配的位置，希望下次分配的时候，用 first-fit
                    的策略从上次分配的位置开始找，希望能紧接着在上次 extent
                    的后面分配新的空间。这样当大量写入数据的时候，下层的块设备能把这些地址连续的写操作合并起来，达到更好的性能。这对于磁盘是很有效的优化策略，对
                    SSD 可能也能改进性能。毕竟，谁不喜欢顺序写呢。
                  </p>
                </div>
                <div class="sect3">
                  <h4 id="cf-cursor-fit-allocator">
                    CF (Cursor Fit) Allocator
                  </h4>
                  <div class="paragraph">
                    <p>这个算法只用了两个 cursor。</p>
                  </div>
                  <div class="olist arabic">
                    <ol class="arabic">
                      <li>
                        <p>
                          根据 <code>ms_size_tree</code> 找到最大的一个 metaslab
                        </p>
                      </li>
                      <li>
                        <p>
                          让 <code>cursor</code> 和
                          <code>cursor_end</code> 分别指向 metaslab 的两端
                        </p>
                      </li>
                      <li>
                        <p>
                          每次分配新的空间都往前移动 <code>cursor</code>，直到
                          <code>cursor_end</code>。这表示 slab
                          里面的空间用完了，这时候就找一个新的 slab。
                        </p>
                      </li>
                    </ol>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="df-dynamic-fit-allocator">
                    DF (Dynamic Fit) Allocator
                  </h4>
                  <div class="paragraph">
                    <p>
                      所谓 “dynamic” 是指算法会根据具体情况动态地在 best-fit 和
                      first-fit 两个算法中选择。这个算法用一个 cursor
                      指向上次分配 extent 结束的地方。
                    </p>
                  </div>
                  <div class="ulist">
                    <ul>
                      <li>
                        <p>
                          如果 slab 的剩余空间小于设定值，就根据需要 extent
                          的大小，找够大的就行。
                        </p>
                      </li>
                      <li>
                        <p>
                          如果剩余空间还比较大，为了局部性，首先继续上次结束的地方搜索。搜索的范围由
                          <code>metaslab_df_max_search</code>
                          限定，如果超过这个大小还找不到，就退化成按照大小搜索。只要找到和需要大小相同或者更大的
                          extent 就行。
                        </p>
                      </li>
                    </ul>
                  </div>
                  <div class="paragraph">
                    <p>
                      每次分配到 extent，都会推进
                      <code>ms_lbas[bits_of_alignment]</code> 让它指向新分配
                      extent 结束的位置。这样相同对齐要求的 extent
                      就会从相邻的位置分配出来，不过这并不能防止其他对齐大小的
                      extent 也出现在同一区域中。
                    </p>
                  </div>
                </div>
                <div class="sect3">
                  <h4 id="ndf-new-dynamic-fit-clump-allocator">
                    NDF (New Dynamic Fit / clump) Allocator
                  </h4>
                  <div class="paragraph">
                    <p>
                      clump，即“扎堆”。其实这个名字更能说明这个算法的用意。它希望主动地为请求的大小选择成倍的更大的空间，预期接下来会出现多个相同大小的请求。
                    </p>
                  </div>
                  <div class="ulist">
                    <ul>
                      <li>
                        <p>
                          先在 <code>ms_tree</code> 里面找
                          <code>[cursor, cursor+size)</code> 的
                          extent，如果找到足够大的 extent。就把
                          <code>cursor</code> 往前移动 <code>size</code>
                        </p>
                      </li>
                      <li>
                        <p>
                          找不到的话，就在
                          <code>ms_size_tree</code> 里面先找大小为 2<sup
                            >metaslab_ndf_clump_shift</sup
                          >
                          倍 <code>size</code> 的 range，等找着了，就把
                          <code>cursor</code>
                          指向它，以它作为新的基地，发展成为这种对齐 extent
                          扎堆的地方。当然，新“基地”的大小是按照当前 slab
                          的最大空闲空间为上限的。
                        </p>
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="sect1">
            <h2 id="bluestore-里的-avl-allocator">
              bluestore 里的 Avl Allocator
            </h2>
            <div class="sectionbody">
              <div class="paragraph">
                <p>
                  AvlAllocator 基本上是 ZFS 的 DF Allocator 较早版本的 C++
                  移植。它继续用 AVL tree 来保存 space
                  map。但是不同之处在于，bluestore 里面的 AvlAllocator 并没有
                  <a
                    href="https://utcc.utoronto.ca/~cks/space/blog/solaris/ZFSGangBlocks"
                    >gang</a
                  >
                  的机制。所以 AvlAllocator 必须自己实现它。
                </p>
              </div>
            </div>
          </div>
        </section>

        <!-- Social media shares -->

        <!-- Tag list -->

        <div class="tag-list">
          <ul>
            <li class="meta">Tag</li>

            <li>
              <a class="button" href="/tags#fs">
                <p><i class="fas fa-tag fa-fw fa-sm"></i> fs</p>
              </a>
            </li>
          </ul>
        </div>
      </article>

      <!-- Post navigation -->

      <div id="post-nav">
        <div id="previous-post">
          <a alt="Seastar 和 SPDK" href="/2021/08/28/spdk-seastar.html">
            <p>Previous post</p>
            Seastar 和 SPDK
          </a>
        </div>

        <div id="next-post">
          <a
            alt="Log-strucutured Filesystem 和垃圾收集"
            href="/2021/05/16/gc-fs.html"
          >
            <p>Next post</p>
            Log-strucutured Filesystem 和垃圾收集
          </a>
        </div>
      </div>

      <!--Utterances-->

      <!-- Cusdis -->
      <div
        class="comments"
        id="cusdis_thread"
        data-host="https://cusdis.com"
        data-app-id="12e099bc-c554-4827-aeb8-e425c83d8176"
        data-page-id="_posts/2021-05-27-alloc-fs.adoc"
        data-page-url="/2021/05/27/alloc-fs.html"
        data-page-title="从 metaslabs allocator 说起"
        data-theme="auto"
      ></div>

      <script async src="https://cusdis.com/js/cusdis.es.js"></script>

      <!-- Disqus -->

      <!-- To change color of links in the page -->
      <style>
        header#main {
          background-size: cover;
          background-repeat: no-repeat;
          background-position: center;
        }
      </style>
    </div>
    <footer class="site-footer">
      <p class="text">
        Powered by <a href="https://jekyllrb.com/">Jekyll</a> with
        <a href="https://github.com/sylhare/Type-on-Strap">Type on Strap</a>
      </p>
      <div class="footer-icons">
        <ul>
          <!-- Social icons from Font Awesome, if enabled -->
        </ul>
      </div>
    </footer>
  </body>
</html>
